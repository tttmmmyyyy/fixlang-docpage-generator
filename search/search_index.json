{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>This page contains the documentation of the following projects and modules (and \"Std\"): </p> <ul> <li>asynctask@1.1.1<ul> <li>AsyncTask</li> </ul> </li> <li>binary-heap@0.1.1<ul> <li>BinaryHeap, BinaryHeap.BinaryArrayTree</li> </ul> </li> <li>character@1.0.1<ul> <li>Character</li> </ul> </li> <li>hash@1.0.1<ul> <li>Hash</li> </ul> </li> <li>hashmap@1.1.2<ul> <li>HashMap</li> </ul> </li> <li>hashset@v1.1.1<ul> <li>HashSet</li> </ul> </li> <li>math@1.1.2<ul> <li>Math</li> </ul> </li> <li>minilib-app@0.5.1<ul> <li>Minilib.App.Clap</li> </ul> </li> <li>minilib-binary@0.5.1<ul> <li>Minilib.Encoding.Base64, Minilib.Encoding.Binary, Minilib.Text.Hex</li> </ul> </li> <li>minilib-collection@0.5.1<ul> <li>Minilib.Collection.Deque, Minilib.Collection.OrderedMap, Minilib.Collection.RBTree, Minilib.Collection.TreeMap, Minilib.Collection.TreeSet</li> </ul> </li> <li>minilib-common@0.5.2<ul> <li>Minilib.Common.Assert, Minilib.Common.Common, Minilib.Common.TimeEx, Minilib.Testing.UnitTest, Minilib.Text.StringEx, Minilib.Trait.Traversable</li> </ul> </li> <li>minilib-comonad@0.5.1<ul> <li>Minilib.Comonad.Env, Minilib.Comonad.IdentityC, Minilib.Comonad.Traced, Minilib.Trait.Comonad</li> </ul> </li> <li>minilib-crypto@0.5.1<ul> <li>Minilib.Crypto.AES, Minilib.Crypto.AES.GCM, Minilib.Crypto.HMAC, Minilib.Crypto.HMAC.HmacMD5, Minilib.Crypto.HMAC.HmacSHA1, Minilib.Crypto.HMAC.HmacSHA256, Minilib.Crypto.MD5, Minilib.Crypto.SHA1, Minilib.Crypto.SHA256, Minilib.Crypto.SHA512</li> </ul> </li> <li>minilib-io@0.5.1<ul> <li>Minilib.IO.Errno, Minilib.IO.FileSystem, Minilib.IO.Path, Minilib.IO.Platform, Minilib.IO.Signal</li> </ul> </li> <li>minilib-json@0.5.1<ul> <li>Minilib.Encoding.Json, Minilib.Encoding.Json.JsonDecoder, Minilib.Encoding.Json.JsonEncoder</li> </ul> </li> <li>minilib-math@0.5.1<ul> <li>Minilib.Math.BigFloat, Minilib.Math.BigInt, Minilib.Math.BigNat, Minilib.Math.Complex, Minilib.Math.Euclid, Minilib.Math.Modular, Minilib.Math.Polynomial, Minilib.Math.Rational, Minilib.Math.Ring, Minilib.Math.Types</li> </ul> </li> <li>minilib-media@0.5.1<ul> <li>Minilib.Media.Image, Minilib.Media.Png, Minilib.Media.Svg</li> </ul> </li> <li>minilib-monad@0.5.1<ul> <li>Minilib.Functor.Pair, Minilib.Monad.Cont, Minilib.Monad.Error, Minilib.Monad.IO, Minilib.Monad.Identity, Minilib.Monad.Option, Minilib.Monad.Reader, Minilib.Monad.Result, Minilib.Monad.State, Minilib.Monad.Trans, Minilib.Monad.Writer, Minilib.Trait.Monoid, Minilib.Trait.Semigroup</li> </ul> </li> <li>minilib-net@0.5.1<ul> <li>Minilib.Net.HTML, Minilib.Net.HttpServer, Minilib.Net.Request, Minilib.Net.Router, Minilib.Net.Tcp, Minilib.Net.URL</li> </ul> </li> <li>minilib-random@0.5.2<ul> <li>Minilib.Common.RandomEx, Minilib.Crypto.SecureRandom, Minilib.Monad.FreeRandom, Minilib.Monad.Random, Minilib.Random.XorShift, Minilib.Trait.Lifter, Minilib.Trait.Rng</li> </ul> </li> <li>minilib-text@0.5.2<ul> <li>Minilib.Text.SimpleParser, Minilib.Text.Unicode</li> </ul> </li> <li>minilib-thread@0.5.1<ul> <li>Minilib.Thread.Channel, Minilib.Thread.Future, Minilib.Thread.TaskPool</li> </ul> </li> <li>minilib-xml@0.5.1<ul> <li>Minilib.Encoding.Xml, Minilib.Encoding.Xml.XmlHelpers, Minilib.Encoding.Xml.XmlParser</li> </ul> </li> <li>random@1.1.1<ul> <li>Random</li> </ul> </li> <li>regexp@1.1.1<ul> <li>RegExp, RegExp.RegExpNFA, RegExp.RegExpPattern, RegExp.SimpleParser, RegExp.StringEx</li> </ul> </li> <li>subprocess@1.0.4<ul> <li>Subprocess</li> </ul> </li> <li>time@1.0.1<ul> <li>Time</li> </ul> </li> </ul> <p>This page was generated by fixlang-docpage-generator.</p>"},{"location":"AsyncTask/","title":"AsyncTask","text":"<p>Defined in asynctask@1.1.1</p> <p>This module provides a way to run tasks asynchronously.</p> <p>Importing this module automatically enables <code>--threaded</code> flag of the compiler. Note that this causes some overhead even for a single-threaded program.</p>"},{"location":"AsyncTask/#values","title":"Values","text":""},{"location":"AsyncTask/#namespace-asynctask","title":"namespace AsyncTask","text":""},{"location":"AsyncTask/#_run_task_function","title":"_run_task_function","text":"<p>Type: <code>Std::Box (() -&gt; Std::Ptr) -&gt; Std::Ptr</code></p> <p>Evaluate the boxed lazy pointer.</p>"},{"location":"AsyncTask/#get","title":"get","text":"<p>Type: <code>AsyncTask::Task a -&gt; a</code></p> <p>Gets the result of a task.</p> <p>This function blocks the current thread until the task is finished.</p>"},{"location":"AsyncTask/#make","title":"make","text":"<p>Type: <code>(() -&gt; a) -&gt; AsyncTask::Task a</code></p> <p>Makes a task which performs a computation asynchronously.</p> <p>Example:</p> <pre><code>module Main;\nimport AsyncTask;\n\nmain : IO ();\nmain = (\n    let sum_range = |from, to| (\n        loop((0, from), |(sum, i)| (\n            if i == to { break $ sum };\n            continue $ (sum + i, i + 1)\n        ))\n    );\n    let n = 1000000000;\n    // Compute the sum of numbers from 0 to n/2 - 1.\n    // This task will be executed asynchronously (if you are using multi-core CPU).\n    let sum_former = AsyncTask::make(|_| sum_range(0, n/2));\n    // Compute the sum of numbers from n/2 to n.\n    // We perfom this in the current thread while waiting for the result of the former task.\n    let sum_latter = sum_range(n/2, n);\n    // Sum up the results of the two computations.\n    let sum = sum_former.get + sum_latter;\n    // Then the sum should be n * (n - 1) / 2.\n    assert_eq(|_|\"\", sum, n * (n - 1) / 2);;\n    println $\n        \"Sum of numbers from 0 to \" + (n - 1).to_string +\n        \" is \" + sum_former.get.to_string + \" + \" + sum_latter.to_string +\n        \" = \" + sum.to_string + \".\"\n);\n</code></pre>"},{"location":"AsyncTask/#number_of_processors","title":"number_of_processors","text":"<p>Type: <code>Std::I64</code></p> <p>Gets the number of processors (CPU cores) currently available. This is implemented by calling <code>sysconf(_SC_NPROCESSORS_ONLN)</code>. The runtime pools as many threads as this number to execute asynchronous tasks.</p>"},{"location":"AsyncTask/#namespace-asynctaskasynciotask","title":"namespace AsyncTask::AsyncIOTask","text":""},{"location":"AsyncTask/#get_1","title":"get","text":"<p>Type: <code>AsyncTask::AsyncIOTask::IOTask a -&gt; Std::IO a</code></p> <p>Get the result of an asynchronous I/O action.</p>"},{"location":"AsyncTask/#make_1","title":"make","text":"<p>Type: <code>Std::IO a -&gt; Std::IO (AsyncTask::AsyncIOTask::IOTask a)</code></p> <p>An <code>IO</code> version of <code>AsyncTask::make</code>.</p> <p>Example:</p> <pre><code>module Main;\nimport AsyncTask;\n\nmain : IO ();\nmain = (\n    let print_ten : I64 -&gt; IO () = |task_num| (\n        loop_m(0, |i| (\n            if i == 10 {\n                break_m $ ()\n            } else {\n                let msg = \"task number: \" + task_num.to_string + \", i: \" + i.to_string;\n                msg.println;;\n                continue_m $ i + 1\n            }\n        ))\n    );\n    (*AsyncIOTask::make(print_ten(0))).get;;\n    (*AsyncIOTask::make(print_ten(1))).get;;\n    pure()\n);\n</code></pre>"},{"location":"AsyncTask/#namespace-asynctaskvar","title":"namespace AsyncTask::Var","text":""},{"location":"AsyncTask/#get_2","title":"get","text":"<p>Type: <code>AsyncTask::Var::Var a -&gt; Std::IO a</code></p> <p>Get a value stored in a <code>Var</code>.</p>"},{"location":"AsyncTask/#lock","title":"lock","text":"<p>Type: <code>(a -&gt; Std::IO b) -&gt; AsyncTask::Var::Var a -&gt; Std::IO b</code></p> <p><code>var.lock(act)</code> performs an action on the value in <code>var</code> while locking <code>var</code> to prevent it from being changed by another thread.</p>"},{"location":"AsyncTask/#make_2","title":"make","text":"<p>Type: <code>a -&gt; Std::IO (AsyncTask::Var::Var a)</code></p> <p>Create a new <code>Var</code> object.</p>"},{"location":"AsyncTask/#mod","title":"mod","text":"<p>Type: <code>(a -&gt; a) -&gt; AsyncTask::Var::Var a -&gt; Std::IO ()</code></p> <p>Atomically modifies a value in a <code>Var</code>.</p>"},{"location":"AsyncTask/#set","title":"set","text":"<p>Type: <code>a -&gt; AsyncTask::Var::Var a -&gt; Std::IO ()</code></p> <p>Set a value to a <code>Var</code>.</p>"},{"location":"AsyncTask/#wait","title":"wait","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; AsyncTask::Var::Var a -&gt; Std::IO ()</code></p> <p><code>var.wait(cond)</code> waits until <code>cond</code> on the value of <code>var</code> is satisfied.</p> <p>Note that it is not assured that <code>cond</code> is satisfied after <code>wait</code> returned; the value in <code>var</code> may be changed after <code>cond</code> is evaluated.</p>"},{"location":"AsyncTask/#wait_and_lock","title":"wait_and_lock","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; (a -&gt; Std::IO b) -&gt; AsyncTask::Var::Var a -&gt; Std::IO b</code></p> <p><code>var.wait_and_lock(cond, act)</code> waits until <code>cond</code> on the value of <code>var</code> is satisfied, then performs <code>act</code> on the value in <code>var</code> while locking <code>var</code> to prevent it from being changed by another thread.</p>"},{"location":"AsyncTask/#types-and-aliases","title":"Types and aliases","text":""},{"location":"AsyncTask/#namespace-asynctask_1","title":"namespace AsyncTask","text":""},{"location":"AsyncTask/#task","title":"Task","text":"<p>Defined as: <code>type Task a = unbox struct { ...fields... }</code></p> <p>A type for a computation task that runs asynchronously.</p>"},{"location":"AsyncTask/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>Std::FFI::Destructor AsyncTask::TaskHandle</code></p>"},{"location":"AsyncTask/#taskhandle","title":"TaskHandle","text":"<p>Defined as: <code>type TaskHandle = Std::Ptr</code></p> <p>A native handle of a task. This type is used only for implementation.</p>"},{"location":"AsyncTask/#namespace-asynctaskasynciotask_1","title":"namespace AsyncTask::AsyncIOTask","text":""},{"location":"AsyncTask/#iotask","title":"IOTask","text":"<p>Defined as: <code>type IOTask a = unbox struct { ...fields... }</code></p> <p>A type for an I/O action that can be run asynchronously.</p>"},{"location":"AsyncTask/#field-_task","title":"field <code>_task</code>","text":"<p>Type: <code>AsyncTask::Task (Std::IO::IOState, a)</code></p>"},{"location":"AsyncTask/#namespace-asynctaskvar_1","title":"namespace AsyncTask::Var","text":""},{"location":"AsyncTask/#var","title":"Var","text":"<p>Defined as: <code>type Var a = unbox struct { ...fields... }</code></p> <p>A type of variable which can be modified from multiple threads.</p> <pre><code>module Main;\nimport AsyncTask;\n\nmain : IO ();\nmain = (\n    let logger = *Var::make([]); // A mutable array of strings.\n\n    // Launch multiple threads, and log in which order each thread is executed.\n    let num_threads = number_of_processors * 2;\n    Iterator::range(0, num_threads).fold_m((), |i, _| (\n        AsyncIOTask::make(\n            logger.lock(|logs| (\n                let count = logs.get_size;\n                let msg = \"Thread \" + i.to_string + \" is running at \" + count.to_string +\n                    if count % 10 == 1 { \"st\" } else if count % 10 == 2 { \"nd\" } else if count % 10 == 3 { \"rd\" } else { \"th\" };\n                let msg = msg + if i == count { \".\" } else { \"!\" };\n                logger.set(logs.push_back(msg))\n            ))\n        )\n    ));;\n\n    // Wait until all threads are finished.\n    +logger.wait(|logs| logs.get_size == num_threads);\n\n    println $ (*logger.get).to_iter.join(\"\\n\")\n);\n</code></pre>"},{"location":"AsyncTask/#field-_dtor","title":"field <code>_dtor</code>","text":"<p>Type: <code>Std::FFI::Destructor AsyncTask::Var::VarHandle</code></p>"},{"location":"AsyncTask/#varhandle","title":"VarHandle","text":"<p>Defined as: <code>type VarHandle = Std::Ptr</code></p>"},{"location":"AsyncTask/#varvalue","title":"VarValue","text":"<p>Defined as: <code>type VarValue a = box struct { ...fields... }</code></p>"},{"location":"AsyncTask/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"AsyncTask/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"AsyncTask/#trait-implementations","title":"Trait implementations","text":""},{"location":"BinaryHeap.BinaryArrayTree/","title":"BinaryHeap.BinaryArrayTree","text":"<p>Defined in binary-heap@0.1.1</p>"},{"location":"BinaryHeap.BinaryArrayTree/#values","title":"Values","text":""},{"location":"BinaryHeap.BinaryArrayTree/#namespace-binaryheapbinaryarraytreebinaryarraytree","title":"namespace BinaryHeap.BinaryArrayTree::BinaryArrayTree","text":""},{"location":"BinaryHeap.BinaryArrayTree/#child_idx_l","title":"child_idx_l","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Get the index of the left child</p>"},{"location":"BinaryHeap.BinaryArrayTree/#child_idx_r","title":"child_idx_r","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Get the index of the right child</p>"},{"location":"BinaryHeap.BinaryArrayTree/#parent_idx_uncheck","title":"parent_idx_uncheck","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Get the index of the parent This function does not check if the index is valid.</p>"},{"location":"BinaryHeap.BinaryArrayTree/#types-and-aliases","title":"Types and aliases","text":""},{"location":"BinaryHeap.BinaryArrayTree/#namespace-binaryheapbinaryarraytree","title":"namespace BinaryHeap.BinaryArrayTree","text":""},{"location":"BinaryHeap.BinaryArrayTree/#binaryarraytree","title":"BinaryArrayTree","text":"<p>Defined as: <code>type BinaryArrayTree e = Std::Array e</code></p> <p>The tree is stored in a vector.</p>"},{"location":"BinaryHeap.BinaryArrayTree/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"BinaryHeap.BinaryArrayTree/#trait-implementations","title":"Trait implementations","text":""},{"location":"BinaryHeap/","title":"BinaryHeap","text":"<p>Defined in binary-heap@0.1.1</p> <p>This module provides a binary heap implementation.</p>"},{"location":"BinaryHeap/#values","title":"Values","text":""},{"location":"BinaryHeap/#namespace-binaryheapbinaryheap","title":"namespace BinaryHeap::BinaryHeap","text":""},{"location":"BinaryHeap/#_at","title":"_at","text":"<p>Type: <code>Std::I64 -&gt; BinaryHeap::BinaryHeap p e -&gt; e</code></p>"},{"location":"BinaryHeap/#_set","title":"_set","text":"<p>Type: <code>Std::I64 -&gt; e -&gt; BinaryHeap::BinaryHeap p e -&gt; BinaryHeap::BinaryHeap p e</code></p>"},{"location":"BinaryHeap/#_to_string","title":"_to_string","text":"<p>Type: <code>[e : Std::ToString] BinaryHeap::BinaryHeap p e -&gt; Std::String</code></p>"},{"location":"BinaryHeap/#empty","title":"empty","text":"<p>Type: <code>p -&gt; BinaryHeap::BinaryHeap p e</code></p> <p>Create an empty heap.</p> <p>The first argument is the priority object.</p>"},{"location":"BinaryHeap/#get_size","title":"get_size","text":"<p>Type: <code>BinaryHeap::BinaryHeap p e -&gt; Std::I64</code></p> <p>Get the size of the heap.</p>"},{"location":"BinaryHeap/#get_top","title":"get_top","text":"<p>Type: <code>BinaryHeap::BinaryHeap p e -&gt; Std::Option e</code></p> <p>Get the most prioritized element in the heap.</p> <p>This function returns <code>none()</code> if the heap is empty.</p> <p>This function does not remove the element.</p>"},{"location":"BinaryHeap/#pop","title":"pop","text":"<p>Type: <code>[p : BinaryHeap::Priority, BinaryHeap::Priority::Elem p = e] BinaryHeap::BinaryHeap p e -&gt; BinaryHeap::BinaryHeap p e</code></p> <p>Pop the most prioritized element from the heap.</p>"},{"location":"BinaryHeap/#push","title":"push","text":"<p>Type: <code>[p : BinaryHeap::Priority, BinaryHeap::Priority::Elem p = e] e -&gt; BinaryHeap::BinaryHeap p e -&gt; BinaryHeap::BinaryHeap p e</code></p> <p>Push an element to the heap.</p>"},{"location":"BinaryHeap/#namespace-binaryheapmaxbinaryheap","title":"namespace BinaryHeap::MaxBinaryHeap","text":""},{"location":"BinaryHeap/#empty_1","title":"empty","text":"<p>Type: <code>BinaryHeap::MaxBinaryHeap e</code></p> <p>Create an empty maximum heap.</p>"},{"location":"BinaryHeap/#namespace-binaryheapminbinaryheap","title":"namespace BinaryHeap::MinBinaryHeap","text":""},{"location":"BinaryHeap/#empty_2","title":"empty","text":"<p>Type: <code>BinaryHeap::MinBinaryHeap e</code></p> <p>Create an empty minimum heap.</p>"},{"location":"BinaryHeap/#namespace-binaryheappriority","title":"namespace BinaryHeap::Priority","text":""},{"location":"BinaryHeap/#compare","title":"compare","text":"<p>Type: <code>[p : BinaryHeap::Priority] BinaryHeap::Priority::Elem p -&gt; BinaryHeap::Priority::Elem p -&gt; p -&gt; Std::Bool</code></p> <p>Compare two elements.</p> <p>Returns true iff the first element has less priority than the second element.</p>"},{"location":"BinaryHeap/#types-and-aliases","title":"Types and aliases","text":""},{"location":"BinaryHeap/#namespace-binaryheap","title":"namespace BinaryHeap","text":""},{"location":"BinaryHeap/#binaryheap_1","title":"BinaryHeap","text":"<p>Defined as: <code>type BinaryHeap p e = unbox struct { ...fields... }</code></p> <p>The binary heap.</p> <p>The first type parameter is the type of the priority object to be used. The type must implement the <code>Priority</code> trait.</p> <p>The priority objects that prioritize the maximum or minimum value based on comparison with the <code>LessThan</code> trait are provided in this module (<code>PriorityMaximum</code> and <code>PriorityMinimum</code>). It is recommended to use the <code>MaxBinaryHeap</code> and <code>MinBinaryHeap</code> type aliases when using them.</p>"},{"location":"BinaryHeap/#field-_d","title":"field <code>_d</code>","text":"<p>Type: <code>Std::Array e</code></p>"},{"location":"BinaryHeap/#field-_p","title":"field <code>_p</code>","text":"<p>Type: <code>p</code></p>"},{"location":"BinaryHeap/#maxbinaryheap","title":"MaxBinaryHeap","text":"<p>Defined as: <code>type MaxBinaryHeap e = BinaryHeap::BinaryHeap (BinaryHeap::PriorityMaximum e) e</code></p> <p>The maximum binary heap.</p>"},{"location":"BinaryHeap/#minbinaryheap","title":"MinBinaryHeap","text":"<p>Defined as: <code>type MinBinaryHeap e = BinaryHeap::BinaryHeap (BinaryHeap::PriorityMinimum e) e</code></p> <p>The minimum binary heap.</p>"},{"location":"BinaryHeap/#prioritymaximum","title":"PriorityMaximum","text":"<p>Defined as: <code>type PriorityMaximum e = unbox struct { ...fields... }</code></p> <p>Priority object that prioritizes the larger element under comparison by <code>LessThan</code>.</p>"},{"location":"BinaryHeap/#priorityminimum","title":"PriorityMinimum","text":"<p>Defined as: <code>type PriorityMinimum e = unbox struct { ...fields... }</code></p> <p>Priority object that prioritizes the smaller element under comparison by <code>LessThan</code>.</p>"},{"location":"BinaryHeap/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"BinaryHeap/#namespace-binaryheap_1","title":"namespace BinaryHeap","text":""},{"location":"BinaryHeap/#trait-p-priority","title":"trait <code>p : Priority</code>","text":"<p>The trait for priority objects.</p>"},{"location":"BinaryHeap/#type-elem","title":"type <code>Elem</code>","text":"<p>Defined as: <code>Elem p</code></p> <p>The element to be compared.</p>"},{"location":"BinaryHeap/#method-compare","title":"method <code>compare</code>","text":"<p>Type: <code>BinaryHeap::Priority::Elem p -&gt; BinaryHeap::Priority::Elem p -&gt; p -&gt; Std::Bool</code></p> <p>Compare two elements.</p> <p>Returns true iff the first element has less priority than the second element.</p>"},{"location":"BinaryHeap/#trait-implementations","title":"Trait implementations","text":""},{"location":"BinaryHeap/#impl-e-stdlessthan-binaryheapprioritymaximum-e-binaryheappriority","title":"impl <code>[e : Std::LessThan] BinaryHeap::PriorityMaximum e : BinaryHeap::Priority</code>","text":""},{"location":"BinaryHeap/#impl-e-stdlessthan-binaryheappriorityminimum-e-binaryheappriority","title":"impl <code>[e : Std::LessThan] BinaryHeap::PriorityMinimum e : BinaryHeap::Priority</code>","text":""},{"location":"Character/","title":"Character","text":"<p>Defined in character@1.0.1</p> <p>This module provides wrapper functions of C functions defined in ctypes.h.</p>"},{"location":"Character/#values","title":"Values","text":""},{"location":"Character/#namespace-character","title":"namespace Character","text":""},{"location":"Character/#is_alnum","title":"is_alnum","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_alpha","title":"is_alpha","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_blank","title":"is_blank","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_cntrl","title":"is_cntrl","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_digit","title":"is_digit","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_graph","title":"is_graph","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_lower","title":"is_lower","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_print","title":"is_print","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_punct","title":"is_punct","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_space","title":"is_space","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_upper","title":"is_upper","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#is_xdigit","title":"is_xdigit","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p>"},{"location":"Character/#to_lower","title":"to_lower","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p>"},{"location":"Character/#to_upper","title":"to_upper","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p>"},{"location":"Character/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Character/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Character/#trait-implementations","title":"Trait implementations","text":""},{"location":"Hash/","title":"Hash","text":"<p>Defined in hash@1.0.1</p> <p>Provides the <code>Hash</code> trait and related traits, and basic hashing functions.</p>"},{"location":"Hash/#values","title":"Values","text":""},{"location":"Hash/#namespace-hash","title":"namespace Hash","text":""},{"location":"Hash/#combine_hash","title":"combine_hash","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Combines two hashes.</p> <p>Using method described in https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes.</p>"},{"location":"Hash/#namespace-hashhash","title":"namespace Hash::Hash","text":""},{"location":"Hash/#hash_1","title":"hash","text":"<p>Type: <code>[a : Hash::Hash] a -&gt; Std::U64</code></p>"},{"location":"Hash/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Hash/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Hash/#namespace-hash_1","title":"namespace Hash","text":""},{"location":"Hash/#trait-a-hash","title":"trait <code>a : Hash</code>","text":"<p>Hashable types.</p>"},{"location":"Hash/#method-hash","title":"method <code>hash</code>","text":"<p>Type: <code>a -&gt; Std::U64</code></p>"},{"location":"Hash/#trait-implementations","title":"Trait implementations","text":""},{"location":"Hash/#impl-a-hashhash-b-hashhash-a-b-hashhash","title":"impl <code>[a : Hash::Hash, b : Hash::Hash] (a, b) : Hash::Hash</code>","text":""},{"location":"Hash/#impl-a-hashhash-stdarray-a-hashhash","title":"impl <code>[a : Hash::Hash] Std::Array a : Hash::Hash</code>","text":""},{"location":"Hash/#impl-stdi64-hashhash","title":"impl <code>Std::I64 : Hash::Hash</code>","text":""},{"location":"Hash/#impl-stdstring-hashhash","title":"impl <code>Std::String : Hash::Hash</code>","text":""},{"location":"Hash/#impl-stdu64-hashhash","title":"impl <code>Std::U64 : Hash::Hash</code>","text":""},{"location":"Hash/#impl-stdu8-hashhash","title":"impl <code>Std::U8 : Hash::Hash</code>","text":""},{"location":"HashMap/","title":"HashMap","text":"<p>Defined in hashmap@1.1.2</p>"},{"location":"HashMap/#values","title":"Values","text":""},{"location":"HashMap/#namespace-hashmap","title":"namespace HashMap","text":""},{"location":"HashMap/#_find_place","title":"_find_place","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashMap::HashMap k v -&gt; (Std::I64, Std::Option Std::I64)</code></p> <p>Finds the place where an element with a key is stored. Returns pair of (index in hash table, index in bucket).</p>"},{"location":"HashMap/#_get_pot_geq","title":"_get_pot_geq","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Gets a POT (power-of-two) value which is less than or equal to the given value. This is used for calculating capacity value.</p>"},{"location":"HashMap/#contains_key","title":"contains_key","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashMap::HashMap k v -&gt; Std::Bool</code></p> <p>Checks whether a hashmap contains a key.</p>"},{"location":"HashMap/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; HashMap::HashMap k v</code></p> <p>Creates an empty HashMap which is reserved so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"HashMap/#erase","title":"erase","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashMap::HashMap k v -&gt; HashMap::HashMap k v</code></p> <p>Erases an element from a HashMap.</p>"},{"location":"HashMap/#find","title":"find","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashMap::HashMap k v -&gt; Std::Option v</code></p> <p>Finds an element from a HashMap.</p>"},{"location":"HashMap/#find_or","title":"find_or","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; v -&gt; HashMap::HashMap k v -&gt; v</code></p> <p>Finds an element from a HashMap. If the map doesn't contain the key, it returns the given default value.</p>"},{"location":"HashMap/#get_capacity","title":"get_capacity","text":"<p>Type: <code>HashMap::HashMap k v -&gt; Std::I64</code></p> <p>Gets capacity of a HashMap.</p>"},{"location":"HashMap/#get_size","title":"get_size","text":"<p>Type: <code>HashMap::HashMap k v -&gt; Std::I64</code></p> <p>Gets size (number of elements) of a HashMap.</p>"},{"location":"HashMap/#insert","title":"insert","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; v -&gt; HashMap::HashMap k v -&gt; HashMap::HashMap k v</code></p> <p>Inserts an element into a HashMap.</p>"},{"location":"HashMap/#reserve","title":"reserve","text":"<p>Type: <code>[k : Hash::HashKey] Std::I64 -&gt; HashMap::HashMap k v -&gt; HashMap::HashMap k v</code></p> <p>Reserves a HashMap so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"HashMap/#to_iter","title":"to_iter","text":"<p>Type: <code>HashMap::HashMap k v -&gt; HashMap::HashMapIterator (k, v)</code></p> <p>Converts a HashMap into an iterator.</p>"},{"location":"HashMap/#types-and-aliases","title":"Types and aliases","text":""},{"location":"HashMap/#namespace-hashmap_1","title":"namespace HashMap","text":""},{"location":"HashMap/#hashmap_1","title":"HashMap","text":"<p>Defined as: <code>type HashMap k v = unbox struct { ...fields... }</code></p>"},{"location":"HashMap/#field-_table","title":"field <code>_table</code>","text":"<p>Type: <code>Std::Array (Std::Array (Std::Option (k, v)))</code></p>"},{"location":"HashMap/#field-_size","title":"field <code>_size</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"HashMap/#hashmapiterator","title":"HashMapIterator","text":"<p>Defined as: <code>type HashMapIterator kv = Std::Iterator::FlattenIterator (Std::Iterator::MapIterator Std::Iterator::RangeIterator Std::I64 (Std::Iterator::FlattenIterator (Std::Iterator::MapIterator Std::Iterator::RangeIterator Std::I64 (Std::Option::OptionIterator (Std::Option kv))) (Std::Option::OptionIterator (Std::Option kv)))) (Std::Iterator::FlattenIterator (Std::Iterator::MapIterator Std::Iterator::RangeIterator Std::I64 (Std::Option::OptionIterator (Std::Option kv))) (Std::Option::OptionIterator (Std::Option kv)))</code></p>"},{"location":"HashMap/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"HashMap/#trait-implementations","title":"Trait implementations","text":""},{"location":"HashSet/","title":"HashSet","text":"<p>Defined in hashset@1.1.1</p>"},{"location":"HashSet/#values","title":"Values","text":""},{"location":"HashSet/#namespace-hashset","title":"namespace HashSet","text":""},{"location":"HashSet/#contains","title":"contains","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashSet::HashSet k -&gt; Std::Bool</code></p> <p>Checks whether a hashset contains an element.</p>"},{"location":"HashSet/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; HashSet::HashSet k</code></p> <p>Creates an empty HashSet which is reserved so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"HashSet/#erase","title":"erase","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashSet::HashSet k -&gt; HashSet::HashSet k</code></p> <p>Erases an element from a HashSet.</p>"},{"location":"HashSet/#from_iter","title":"from_iter","text":"<p>Type: <code>[k : Hash::HashKey, it : Std::Iterator, Std::Iterator::Item it = k] it -&gt; HashSet::HashSet k</code></p> <p>Constructs a HashSet from an iterator of elements.</p>"},{"location":"HashSet/#get_capacity","title":"get_capacity","text":"<p>Type: <code>HashSet::HashSet k -&gt; Std::I64</code></p> <p>Gets capacity of a HashSet.</p>"},{"location":"HashSet/#get_size","title":"get_size","text":"<p>Type: <code>HashSet::HashSet k -&gt; Std::I64</code></p> <p>Gets size (number of elements) of a HashSet.</p>"},{"location":"HashSet/#insert","title":"insert","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; HashSet::HashSet k -&gt; HashSet::HashSet k</code></p> <p>Inserts an element into a HashSet.</p>"},{"location":"HashSet/#intersect","title":"intersect","text":"<p>Type: <code>[k : Hash::HashKey] HashSet::HashSet k -&gt; HashSet::HashSet k -&gt; HashSet::HashSet k</code></p> <p>Calculates intersection of two Hashsets.</p>"},{"location":"HashSet/#merge","title":"merge","text":"<p>Type: <code>[k : Hash::HashKey] HashSet::HashSet k -&gt; HashSet::HashSet k -&gt; HashSet::HashSet k</code></p> <p>Calculates union of two HashSets.</p>"},{"location":"HashSet/#reserve","title":"reserve","text":"<p>Type: <code>[k : Hash::HashKey] Std::I64 -&gt; HashSet::HashSet k -&gt; HashSet::HashSet k</code></p> <p>Reserves a HashSet so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"HashSet/#to_iter","title":"to_iter","text":"<p>Type: <code>HashSet::HashSet k -&gt; HashSet::HashSetIterator k</code></p> <p>Converts a HashSet into an iterator.</p>"},{"location":"HashSet/#types-and-aliases","title":"Types and aliases","text":""},{"location":"HashSet/#namespace-hashset_1","title":"namespace HashSet","text":""},{"location":"HashSet/#hashset_1","title":"HashSet","text":"<p>Defined as: <code>type HashSet k = unbox struct { ...fields... }</code></p>"},{"location":"HashSet/#field-_hashmap","title":"field <code>_hashmap</code>","text":"<p>Type: <code>HashMap::HashMap k ()</code></p>"},{"location":"HashSet/#hashsetiterator","title":"HashSetIterator","text":"<p>Defined as: <code>type HashSetIterator a = Std::Iterator::MapIterator (HashMap::HashMapIterator (a, ())) (a, ()) a</code></p>"},{"location":"HashSet/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"HashSet/#trait-implementations","title":"Trait implementations","text":""},{"location":"Math/","title":"Math","text":"<p>Defined in math@1.1.2</p> <p>A math library.</p> <p>This module requires <code>libm</code> installed.</p>"},{"location":"Math/#values","title":"Values","text":""},{"location":"Math/#namespace-math","title":"namespace Math","text":""},{"location":"Math/#_gcd_nonneg","title":"_gcd_nonneg","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates greatest common divisor of two non-negative integers.</p>"},{"location":"Math/#acos","title":"acos","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates arc cosine of the argument.</p> <p>This is wrapper of C's acos.</p>"},{"location":"Math/#asin","title":"asin","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates arc sine of the argument.</p> <p>This is wrapper of C's asin.</p>"},{"location":"Math/#atan","title":"atan","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates arc tangent of the argument.</p> <p>This is wrapper of C's atan.</p>"},{"location":"Math/#atan2","title":"atan2","text":"<p>Type: <code>Std::F64 -&gt; Std::F64 -&gt; Std::F64</code></p> <p><code>atan2(y, x)</code> calculates an angle t such that (cos(t), sin(t)) is parallel to (x, y).</p> <p>This is wrapper of C's atan2.</p>"},{"location":"Math/#binomial_coefficients","title":"binomial_coefficients","text":"<p>Type: <code>Std::I64 -&gt; Std::Array (Std::Array Std::I64)</code></p> <p>Calculates table (2-dimensional array) of binomial coefficients.</p> <p>Deprecated: this function will be moved to another project in the future.</p> <p><code>binomial_coefficients(m)</code> evaluates to an array of arrays <code>table</code> where <code>table.@(n).@(r)</code> is the binomial coefficient \"binom(n, r)\" for 0 &lt;= n &lt;= m and 0 &lt;= r &lt;= n. Here <code>m</code> has to be less than or equal to 66 to avoid overflow.</p>"},{"location":"Math/#ceil","title":"ceil","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the smallest integral value not less than the argument.</p> <p>This is wrapper of C's ceil.</p>"},{"location":"Math/#cos","title":"cos","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the cosine of the argument.</p> <p>This is wrapper of C's cos.</p>"},{"location":"Math/#cosh","title":"cosh","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the hyperbolic cosine of the argument.</p> <p>This is wrapper of C's cosh.</p>"},{"location":"Math/#e32","title":"e32","text":"<p>Type: <code>Std::F32</code></p> <p>Napier's constant as F32</p>"},{"location":"Math/#e64","title":"e64","text":"<p>Type: <code>Std::F64</code></p> <p>Napier's constant as F64</p>"},{"location":"Math/#exp","title":"exp","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the natural exponential of the argument.</p> <p>This is wrapper of C's exp.</p>"},{"location":"Math/#floor","title":"floor","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the largest integral value not greater than the argument.</p> <p>This is wrapper of C's floor.</p>"},{"location":"Math/#fmod","title":"fmod","text":"<p>Type: <code>Std::F64 -&gt; Std::F64 -&gt; Std::F64</code></p> <p>Calculates the floating point remainder of division.</p> <p><code>x.fmod(y)</code> evaluates to the remainder of dividing x by y.</p> <p>This is wrapper of C's fmod.</p>"},{"location":"Math/#frexp","title":"frexp","text":"<p>Type: <code>Std::F64 -&gt; (Std::F64, Std::I32)</code></p> <p>Splits a floating point number to normalized fraction and an exponent.</p> <p>This is wrapper of C's frexp.</p>"},{"location":"Math/#gcd","title":"gcd","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates greatest common divisor of two integers. Deprecated: this function will be moved to another project in the future.</p> <p>NOTE: currently, this function does not support I64::minimum.</p>"},{"location":"Math/#ldexp","title":"ldexp","text":"<p>Type: <code>Std::I32 -&gt; Std::F64 -&gt; Std::F64</code></p> <p>Multiplies a floating point number by power of two.</p> <p>This is wrapper of C's ldexp.</p>"},{"location":"Math/#log","title":"log","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates natural logarithm.</p> <p>This is wrapper of C's log.</p>"},{"location":"Math/#log10","title":"log10","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates base-10 logarithm.</p> <p>This is wrapper of C's log10.</p>"},{"location":"Math/#modf","title":"modf","text":"<p>Type: <code>Std::F64 -&gt; (Std::F64, Std::F64)</code></p> <p>Converts a floating pointer number into the pair of fractional part and integral part.</p> <p>This is wrapper of C's modf.</p>"},{"location":"Math/#pi32","title":"pi32","text":"<p>Type: <code>Std::F32</code></p> <p>pi as F32</p>"},{"location":"Math/#pi64","title":"pi64","text":"<p>Type: <code>Std::F64</code></p> <p>pi as F64</p>"},{"location":"Math/#pow","title":"pow","text":"<p>Type: <code>Std::F64 -&gt; Std::F64 -&gt; Std::F64</code></p> <p>Power function.</p> <p><code>x.pow(y)</code> evaluates to x^y.</p> <p>This is wrapper of C's pow.</p>"},{"location":"Math/#sin","title":"sin","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the sine of the argument.</p> <p>This is wrapper of C's sin.</p>"},{"location":"Math/#sinh","title":"sinh","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the hyperbolic sine of the argument.</p> <p>This is wrapper of C's sinh.</p>"},{"location":"Math/#sqrt","title":"sqrt","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates square root of the argument.</p> <p>This is wrapper of C's sqrt.</p>"},{"location":"Math/#tan","title":"tan","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the tangent of the argument.</p> <p>This is wrapper of C's tan.</p>"},{"location":"Math/#tanh","title":"tanh","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Calculates the hyperbolic tangent of the argument.</p> <p>This is wrapper of C's tanh.</p>"},{"location":"Math/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Math/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Math/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.App.Clap/","title":"Minilib.App.Clap","text":"<p>Defined in minilib-app@0.5.1</p> <p>Command line argument parser. Inspired by <code>clap</code> crate of Rust.</p>"},{"location":"Minilib.App.Clap/#values","title":"Values","text":""},{"location":"Minilib.App.Clap/#namespace-minilibappclaparg","title":"namespace Minilib.App.Clap::Arg","text":""},{"location":"Minilib.App.Clap/#_is_option","title":"_is_option","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#_is_positional","title":"_is_positional","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#_long_to_string","title":"_long_to_string","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_option_matches","title":"_option_matches","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg -&gt; Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#_positional_to_string","title":"_positional_to_string","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_short_to_string","title":"_short_to_string","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#default_value","title":"default_value","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@default_value</code>.</p>"},{"location":"Minilib.App.Clap/#help","title":"help","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@help</code>.</p>"},{"location":"Minilib.App.Clap/#long","title":"long","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@long</code>.</p>"},{"location":"Minilib.App.Clap/#new","title":"new","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg</code></p> <p>Creates new argument.</p>"},{"location":"Minilib.App.Clap/#required","title":"required","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@required</code> to true.</p>"},{"location":"Minilib.App.Clap/#short","title":"short","text":"<p>Type: <code>Std::U8 -&gt; Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@short</code>.</p>"},{"location":"Minilib.App.Clap/#takes_multiple_values","title":"takes_multiple_values","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@takes_value</code> to true, <code>@multiple_values</code> to true, and <code>@action</code> to <code>append()</code>.</p>"},{"location":"Minilib.App.Clap/#takes_value","title":"takes_value","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@takes_value</code> to true, and <code>@action</code> to <code>set()</code>.</p>"},{"location":"Minilib.App.Clap/#value_name","title":"value_name","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Arg</code></p> <p>Sets <code>@value_name</code>.</p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclapargmatches","title":"namespace Minilib.App.Clap::ArgMatches","text":""},{"location":"Minilib.App.Clap/#_mod_values","title":"_mod_values","text":"<p>Type: <code>Std::String -&gt; (Std::Array Std::String -&gt; Std::Array Std::String) -&gt; Minilib.App.Clap::ArgMatches -&gt; Minilib.App.Clap::ArgMatches</code></p>"},{"location":"Minilib.App.Clap/#_set_values","title":"_set_values","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::String -&gt; Minilib.App.Clap::ArgMatches -&gt; Minilib.App.Clap::ArgMatches</code></p>"},{"location":"Minilib.App.Clap/#empty","title":"empty","text":"<p>Type: <code>Minilib.App.Clap::ArgMatches</code></p> <p>An empty <code>ArgMatches</code> structure.</p>"},{"location":"Minilib.App.Clap/#get_many","title":"get_many","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::ArgMatches -&gt; Std::Option (Std::Array Std::String)</code></p> <p>Gets the array of argument values with the specified ID.</p>"},{"location":"Minilib.App.Clap/#get_one","title":"get_one","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::ArgMatches -&gt; Std::Option Std::String</code></p> <p>Gets the value of the argument with the specified ID.</p>"},{"location":"Minilib.App.Clap/#subcommand","title":"subcommand","text":"<p>Type: <code>Minilib.App.Clap::ArgMatches -&gt; Std::Option (Std::String, Minilib.App.Clap::ArgMatches)</code></p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclapargparser","title":"namespace Minilib.App.Clap::ArgParser","text":""},{"location":"Minilib.App.Clap/#_increment_value","title":"_increment_value","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Increments the value as an integer.</p>"},{"location":"Minilib.App.Clap/#_perform_action","title":"_perform_action","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Performs the action set in <code>arg</code>.</p>"},{"location":"Minilib.App.Clap/#_process_option_arg","title":"_process_option_arg","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Treats the current input as an optional argument.</p>"},{"location":"Minilib.App.Clap/#_process_positional_arg","title":"_process_positional_arg","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Treats the current input as a positional argument.</p>"},{"location":"Minilib.App.Clap/#_remove_arg","title":"_remove_arg","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Remove <code>arg</code> from the remaining args.</p>"},{"location":"Minilib.App.Clap/#_set_or_append_value","title":"_set_or_append_value","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Takes the current input as a value and performs a <code>set</code> or <code>append</code> action.</p>"},{"location":"Minilib.App.Clap/#advance","title":"advance","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg (Std::String, Minilib.App.Clap::ArgParser::ArgParser)</code></p> <p>Proceed to next input.</p>"},{"location":"Minilib.App.Clap/#append_value","title":"append_value","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Adds a value to the array of values in <code>arg</code>.</p>"},{"location":"Minilib.App.Clap/#check_required_args_present","title":"check_required_args_present","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Check whether the required argument values are set. Reports an error if the value is not set.</p>"},{"location":"Minilib.App.Clap/#get_input","title":"get_input","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p>Get the current input.</p>"},{"location":"Minilib.App.Clap/#make","title":"make","text":"<p>Type: <code>Std::Array Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Creates an <code>ArgParser</code> based on the input array and command.</p>"},{"location":"Minilib.App.Clap/#no_inputs","title":"no_inputs","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Bool</code></p> <p>Returns True if there are no more inputs. Returns False if there is more input.</p>"},{"location":"Minilib.App.Clap/#parse_args","title":"parse_args","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Parse the actual command line argument array and set the value of <code>Arg</code>.</p>"},{"location":"Minilib.App.Clap/#set_default_if_not_present","title":"set_default_if_not_present","text":"<p>Type: <code>Minilib.App.Clap::ArgParser::ArgParser -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>If no value is set for the argument, set the default value.</p>"},{"location":"Minilib.App.Clap/#set_value","title":"set_value","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String -&gt; Minilib.App.Clap::ArgParser::ArgParser -&gt; Minilib.App.Clap::ArgParser::ArgParser</code></p> <p>Set the value to <code>arg</code>.</p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclapcommand","title":"namespace Minilib.App.Clap::Command","text":""},{"location":"Minilib.App.Clap/#_default_args","title":"_default_args","text":"<p>Type: <code>Std::Array Minilib.App.Clap::Arg</code></p>"},{"location":"Minilib.App.Clap/#_get_submatches_from","title":"_get_submatches_from","text":"<p>Type: <code>Std::Array Std::String -&gt; Minilib.App.Clap::Command -&gt; Std::Result Std::ErrMsg (Std::String, Minilib.App.Clap::ArgMatches)</code></p>"},{"location":"Minilib.App.Clap/#about","title":"about","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the description about the command.</p>"},{"location":"Minilib.App.Clap/#arg","title":"arg","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Add an argument definition to the command.</p>"},{"location":"Minilib.App.Clap/#author","title":"author","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the author of the command.</p>"},{"location":"Minilib.App.Clap/#bin_name","title":"bin_name","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the name of the executable binary of the command.</p>"},{"location":"Minilib.App.Clap/#display_name","title":"display_name","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the display name of the command.</p>"},{"location":"Minilib.App.Clap/#get_matches","title":"get_matches","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Std::IO::IOFail Minilib.App.Clap::ArgMatches</code></p> <p>Parse command line arguments based on <code>IO::get_args</code>. If <code>--help</code> or <code>--version</code> is specified, the help string or version string will be returned as <code>throw</code>.</p>"},{"location":"Minilib.App.Clap/#get_matches_from","title":"get_matches_from","text":"<p>Type: <code>Std::Array Std::String -&gt; Minilib.App.Clap::Command -&gt; Std::Result Std::ErrMsg Minilib.App.Clap::ArgMatches</code></p> <p>Parses command line arguments based on the specified input array. If <code>--help</code> or <code>--version</code> is specified, the help string or version string will be returned as the error message.</p>"},{"location":"Minilib.App.Clap/#name","title":"name","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the name of the command.</p>"},{"location":"Minilib.App.Clap/#new_1","title":"new","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command</code></p> <p>Creates a command structure by specifying the command name.</p>"},{"location":"Minilib.App.Clap/#render_help","title":"render_help","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Std::String</code></p> <p>Generates a help string based on the help template.</p>"},{"location":"Minilib.App.Clap/#render_version","title":"render_version","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Std::String</code></p> <p>Generates a version string based on the version template.</p>"},{"location":"Minilib.App.Clap/#subcommand_1","title":"subcommand","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Add a subcommand to the command.</p>"},{"location":"Minilib.App.Clap/#version","title":"version","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::Command -&gt; Minilib.App.Clap::Command</code></p> <p>Sets the version of the command.</p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclaphelptemplate","title":"namespace Minilib.App.Clap::HelpTemplate","text":""},{"location":"Minilib.App.Clap/#_default_help","title":"_default_help","text":"<p>Type: <code>Minilib.App.Clap::HelpTemplate</code></p>"},{"location":"Minilib.App.Clap/#_default_version","title":"_default_version","text":"<p>Type: <code>Minilib.App.Clap::HelpTemplate</code></p>"},{"location":"Minilib.App.Clap/#_format_all_args","title":"_format_all_args","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Minilib.App.Clap::HelpTemplate -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_format_arg","title":"_format_arg","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_format_option","title":"_format_option","text":"<p>Type: <code>Minilib.App.Clap::Arg -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_format_subcommand","title":"_format_subcommand","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#_format_usage","title":"_format_usage","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Minilib.App.Clap::HelpTemplate -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#format","title":"format","text":"<p>Type: <code>Minilib.App.Clap::Command -&gt; Minilib.App.Clap::HelpTemplate -&gt; Std::String</code></p>"},{"location":"Minilib.App.Clap/#new_2","title":"new","text":"<p>Type: <code>Std::String -&gt; Minilib.App.Clap::HelpTemplate</code></p>"},{"location":"Minilib.App.Clap/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.App.Clap/#namespace-minilibappclap","title":"namespace Minilib.App.Clap","text":""},{"location":"Minilib.App.Clap/#arg_1","title":"Arg","text":"<p>Defined as: <code>type Arg = unbox struct { ...fields... }</code></p> <p>A structure that defines arguments. Arguments can be either optional or positional arguments. If either <code>short</code> or <code>long</code> is set, it becomes an optional argument. Otherwise, it is a positional argument.</p>"},{"location":"Minilib.App.Clap/#field-id","title":"field <code>id</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-short","title":"field <code>short</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Minilib.App.Clap/#field-long","title":"field <code>long</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-required","title":"field <code>required</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#field-takes_value","title":"field <code>takes_value</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#field-multiple_values","title":"field <code>multiple_values</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#field-default_value","title":"field <code>default_value</code>","text":"<p>Type: <code>Std::Option Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-value_name","title":"field <code>value_name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-help","title":"field <code>help</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-action","title":"field <code>action</code>","text":"<p>Type: <code>Minilib.App.Clap::ArgAction::ArgAction</code></p>"},{"location":"Minilib.App.Clap/#argmatches","title":"ArgMatches","text":"<p>Defined as: <code>type ArgMatches = box struct { ...fields... }</code></p> <p>A structure representing the result of parsing command line arguments.</p>"},{"location":"Minilib.App.Clap/#field-subcommand","title":"field <code>subcommand</code>","text":"<p>Type: <code>Std::Option (Std::String, Minilib.App.Clap::ArgMatches)</code></p>"},{"location":"Minilib.App.Clap/#field-map","title":"field <code>map</code>","text":"<p>Type: <code>HashMap::HashMap Std::String (Std::Array Std::String)</code></p>"},{"location":"Minilib.App.Clap/#command","title":"Command","text":"<p>Defined as: <code>type Command = box struct { ...fields... }</code></p> <p>A structure representing a command (ie. application).</p>"},{"location":"Minilib.App.Clap/#field-name","title":"field <code>name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-bin_name","title":"field <code>bin_name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-display_name","title":"field <code>display_name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-subcommand_path","title":"field <code>subcommand_path</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-version","title":"field <code>version</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-author","title":"field <code>author</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-about","title":"field <code>about</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-subcommands","title":"field <code>subcommands</code>","text":"<p>Type: <code>Std::Array Minilib.App.Clap::Command</code></p>"},{"location":"Minilib.App.Clap/#field-args","title":"field <code>args</code>","text":"<p>Type: <code>Std::Array Minilib.App.Clap::Arg</code></p>"},{"location":"Minilib.App.Clap/#field-help_template","title":"field <code>help_template</code>","text":"<p>Type: <code>Minilib.App.Clap::HelpTemplate</code></p>"},{"location":"Minilib.App.Clap/#field-version_template","title":"field <code>version_template</code>","text":"<p>Type: <code>Minilib.App.Clap::HelpTemplate</code></p>"},{"location":"Minilib.App.Clap/#helptemplate","title":"HelpTemplate","text":"<p>Defined as: <code>type HelpTemplate = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.App.Clap/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclapargaction","title":"namespace Minilib.App.Clap::ArgAction","text":""},{"location":"Minilib.App.Clap/#argaction","title":"ArgAction","text":"<p>Defined as: <code>type ArgAction = unbox union { ...variants... }</code></p> <p>The action taken when the argument is parsed.</p>"},{"location":"Minilib.App.Clap/#variant-set","title":"variant <code>set</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-append","title":"variant <code>append</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-set_true","title":"variant <code>set_true</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-set_false","title":"variant <code>set_false</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-increment","title":"variant <code>increment</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-help","title":"variant <code>help</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#variant-version","title":"variant <code>version</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.App.Clap/#namespace-minilibappclapargparser_1","title":"namespace Minilib.App.Clap::ArgParser","text":""},{"location":"Minilib.App.Clap/#argparser","title":"ArgParser","text":"<p>Defined as: <code>type ArgParser = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.App.Clap/#field-command","title":"field <code>command</code>","text":"<p>Type: <code>Minilib.App.Clap::Command</code></p>"},{"location":"Minilib.App.Clap/#field-remaining_args","title":"field <code>remaining_args</code>","text":"<p>Type: <code>Std::Iterator::DynIterator Minilib.App.Clap::Arg</code></p>"},{"location":"Minilib.App.Clap/#field-matches","title":"field <code>matches</code>","text":"<p>Type: <code>Minilib.App.Clap::ArgMatches</code></p>"},{"location":"Minilib.App.Clap/#field-inputs","title":"field <code>inputs</code>","text":"<p>Type: <code>Std::Iterator::DynIterator Std::String</code></p>"},{"location":"Minilib.App.Clap/#field-positional_only","title":"field <code>positional_only</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.App.Clap/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.App.Clap/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.App.Clap/#impl-minilibappclaparg-stdtostring","title":"impl <code>Minilib.App.Clap::Arg : Std::ToString</code>","text":""},{"location":"Minilib.Collection.Deque/","title":"Minilib.Collection.Deque","text":"<p>Defined in minilib-collection@0.5.1</p> <p>Deque (double-ended queue). Deque can be used as a FIFO such as a message queue. When used as a FIFO, the amortized costs of <code>push_back()</code> and <code>pop_front()</code> are <code>O(1)</code>.</p>"},{"location":"Minilib.Collection.Deque/#values","title":"Values","text":""},{"location":"Minilib.Collection.Deque/#namespace-minilibcollectiondequedeque","title":"namespace Minilib.Collection.Deque::Deque","text":""},{"location":"Minilib.Collection.Deque/#_reverse_array","title":"_reverse_array","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a</code></p> <p>Reverses an array.</p>"},{"location":"Minilib.Collection.Deque/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Collection.Deque::Deque a</code></p> <p>Creates an empty double-ended queue.</p>"},{"location":"Minilib.Collection.Deque/#get_back","title":"get_back","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Std::Option a</code></p> <p>Gets the back element of the queue.</p>"},{"location":"Minilib.Collection.Deque/#get_front","title":"get_front","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Std::Option a</code></p> <p>Gets the front element of the queue.</p>"},{"location":"Minilib.Collection.Deque/#get_size","title":"get_size","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Std::I64</code></p> <p>Gets the size of the queue.</p>"},{"location":"Minilib.Collection.Deque/#is_empty","title":"is_empty","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Std::Bool</code></p> <p>Returns true iff the queue is empty.</p>"},{"location":"Minilib.Collection.Deque/#pop_back","title":"pop_back","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Minilib.Collection.Deque::Deque a</code></p> <p>Pops an element from the back of the queue. If the queue is empty, it does nothing.</p>"},{"location":"Minilib.Collection.Deque/#pop_front","title":"pop_front","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Minilib.Collection.Deque::Deque a</code></p> <p>Pops an element from the front of the queue. If the queue is empty, it does nothing.</p>"},{"location":"Minilib.Collection.Deque/#push_back","title":"push_back","text":"<p>Type: <code>a -&gt; Minilib.Collection.Deque::Deque a -&gt; Minilib.Collection.Deque::Deque a</code></p> <p>Pushes an element to the back of the queue.</p>"},{"location":"Minilib.Collection.Deque/#push_front","title":"push_front","text":"<p>Type: <code>a -&gt; Minilib.Collection.Deque::Deque a -&gt; Minilib.Collection.Deque::Deque a</code></p> <p>Pushes an element to the front of the queue.</p>"},{"location":"Minilib.Collection.Deque/#to_iter","title":"to_iter","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a -&gt; Minilib.Collection.Deque::Deque::DequeIterator a</code></p> <p>Returns an iterator of elements.</p>"},{"location":"Minilib.Collection.Deque/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Collection.Deque/#namespace-minilibcollectiondeque","title":"namespace Minilib.Collection.Deque","text":""},{"location":"Minilib.Collection.Deque/#deque","title":"Deque","text":"<p>Defined as: <code>type Deque a = unbox struct { ...fields... }</code></p> <p>A type that represents a double-ended queue.</p>"},{"location":"Minilib.Collection.Deque/#field-front","title":"field <code>front</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Minilib.Collection.Deque/#field-back","title":"field <code>back</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Minilib.Collection.Deque/#namespace-minilibcollectiondequedeque_1","title":"namespace Minilib.Collection.Deque::Deque","text":""},{"location":"Minilib.Collection.Deque/#dequeiterator","title":"DequeIterator","text":"<p>Defined as: <code>type DequeIterator a = Std::Iterator::AppendIterator (Std::Iterator::ReverseIterator (Std::Iterator::ArrayIterator a) a) (Std::Iterator::ArrayIterator a)</code></p>"},{"location":"Minilib.Collection.Deque/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Collection.Deque/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Collection.OrderedMap/","title":"Minilib.Collection.OrderedMap","text":"<p>Defined in minilib-collection@0.5.1</p> <p>Ordered map. This is similar to HashMap except it preserves the order of entries.</p>"},{"location":"Minilib.Collection.OrderedMap/#values","title":"Values","text":""},{"location":"Minilib.Collection.OrderedMap/#namespace-minilibcollectionorderedmaporderedmap","title":"namespace Minilib.Collection.OrderedMap::OrderedMap","text":""},{"location":"Minilib.Collection.OrderedMap/#contains_key","title":"contains_key","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Std::Bool</code></p> <p>Check whether an OrderedMap contains a key.</p>"},{"location":"Minilib.Collection.OrderedMap/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Collection.OrderedMap::OrderedMap k v</code></p> <p>Create an empty OrderedMap which is reserved so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"Minilib.Collection.OrderedMap/#erase","title":"erase","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Minilib.Collection.OrderedMap::OrderedMap k v</code></p> <p>Erase an element from an OrderedMap.</p>"},{"location":"Minilib.Collection.OrderedMap/#find","title":"find","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Std::Option v</code></p> <p>Find an element from an OrderedMap.</p>"},{"location":"Minilib.Collection.OrderedMap/#find_or","title":"find_or","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; v -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; v</code></p> <p>Find an element from an OrderedMap. If the map doesn't contain the key, it returns the given default value.</p>"},{"location":"Minilib.Collection.OrderedMap/#get_capacity","title":"get_capacity","text":"<p>Type: <code>Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Std::I64</code></p> <p>Get capacity of an OrderedMap.</p>"},{"location":"Minilib.Collection.OrderedMap/#get_size","title":"get_size","text":"<p>Type: <code>Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Std::I64</code></p> <p>Get size (number of elements) in an OrderedMap.</p>"},{"location":"Minilib.Collection.OrderedMap/#insert","title":"insert","text":"<p>Type: <code>[k : Hash::HashKey] k -&gt; v -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Minilib.Collection.OrderedMap::OrderedMap k v</code></p> <p>Insert an element into an OrderedMap.</p>"},{"location":"Minilib.Collection.OrderedMap/#reserve","title":"reserve","text":"<p>Type: <code>[k : Hash::HashKey] Std::I64 -&gt; Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Minilib.Collection.OrderedMap::OrderedMap k v</code></p> <p>Reserve an OrderedMap so that it will not rehash until size exceeds the spacified value.</p>"},{"location":"Minilib.Collection.OrderedMap/#to_iter","title":"to_iter","text":"<p>Type: <code>Minilib.Collection.OrderedMap::OrderedMap k v -&gt; Minilib.Collection.OrderedMap::OrderedMap::OrderedMapIterator k v</code></p> <p>Convert an OrderedMap into an iterator. The order of the elements is the same as when they were inserted into the map.</p>"},{"location":"Minilib.Collection.OrderedMap/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Collection.OrderedMap/#namespace-minilibcollectionorderedmap","title":"namespace Minilib.Collection.OrderedMap","text":""},{"location":"Minilib.Collection.OrderedMap/#orderedmap","title":"OrderedMap","text":"<p>Defined as: <code>type OrderedMap k v = unbox struct { ...fields... }</code></p> <p>Similar to HashMap, but <code>to_iter()</code> returns entries in the same order as they were inserted.</p>"},{"location":"Minilib.Collection.OrderedMap/#field-map","title":"field <code>map</code>","text":"<p>Type: <code>HashMap::HashMap k (Std::I64, v)</code></p>"},{"location":"Minilib.Collection.OrderedMap/#field-serial","title":"field <code>serial</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Collection.OrderedMap/#namespace-minilibcollectionorderedmaporderedmap_1","title":"namespace Minilib.Collection.OrderedMap::OrderedMap","text":""},{"location":"Minilib.Collection.OrderedMap/#orderedmapiterator","title":"OrderedMapIterator","text":"<p>Defined as: <code>type OrderedMapIterator k v = Std::Iterator::MapIterator (Std::Iterator::ArrayIterator (k, (Std::I64, v))) (k, (Std::I64, v)) (k, v)</code></p>"},{"location":"Minilib.Collection.OrderedMap/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Collection.OrderedMap/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Collection.OrderedMap/#impl-k-hashhashkey-v-stdeq-minilibcollectionorderedmaporderedmap-k-v-stdeq","title":"impl <code>[k : Hash::HashKey, v : Std::Eq] Minilib.Collection.OrderedMap::OrderedMap k v : Std::Eq</code>","text":""},{"location":"Minilib.Collection.OrderedMap/#impl-k-hashhashkey-k-stdtostring-v-stdtostring-minilibcollectionorderedmaporderedmap-k-v-stdtostring","title":"impl <code>[k : Hash::HashKey, k : Std::ToString, v : Std::ToString] Minilib.Collection.OrderedMap::OrderedMap k v : Std::ToString</code>","text":""},{"location":"Minilib.Collection.RBTree/","title":"Minilib.Collection.RBTree","text":"<p>Defined in minilib-collection@0.5.1</p> <p>Red-Black Tree. (This is an internal module of <code>TreeMap</code> and <code>TreeSet</code>.)</p> <p>Ported from Japanese translation of the book below:</p> <p>\"Purely functional data structures\" by Chris Okasaki, Cambridge University Press, 1998, ISBN 0-521-66350-4</p> <p>And for removal algorithm, ported from web site below. http://wwwa.pikara.ne.jp/okojisan/rb-tree/index.html#Delete</p> <p>NOTE: <code>less_than()</code> function must meet following conditions. - Irreflexivity: for all <code>x</code>, <code>less_than(x,x)</code> must be false. - Asymmetry:     for all <code>x, y</code>, if <code>less_than(x,y)</code> is true, then <code>less_than(y,x)</code> must be false. - Transitivity:  for all <code>x, y, z</code>, if <code>less_than(x,y)</code> is true and <code>less_than(y,z)</code> is true,                  then <code>less_than(x,z)</code> must be true.</p>"},{"location":"Minilib.Collection.RBTree/#values","title":"Values","text":""},{"location":"Minilib.Collection.RBTree/#namespace-minilibcollectionrbtreerbnode","title":"namespace Minilib.Collection.RBTree::RBNode","text":""},{"location":"Minilib.Collection.RBTree/#_debug","title":"_Debug","text":"<p>Type: <code>Std::Bool</code></p> <p>Debug flag. If set to true, a lot of debug messages will be printed and various validations will be done.</p>"},{"location":"Minilib.Collection.RBTree/#_balance","title":"_balance","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#_debug_assert_level_diff","title":"_debug_assert_level_diff","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Std::String -&gt; Std::String -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::String -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::I64 -&gt; Std::Lazy b -&gt; b</code></p>"},{"location":"Minilib.Collection.RBTree/#_debug_eprintln_lazy","title":"_debug_eprintln_lazy","text":"<p>Type: <code>(() -&gt; Std::String) -&gt; ()</code></p> <p>Prints to stderr if the debug flag is set.</p>"},{"location":"Minilib.Collection.RBTree/#_fast_append","title":"_fast_append","text":"<p>Type: <code>Std::Iterator::DynIterator a -&gt; Std::Iterator::DynIterator a -&gt; Std::Iterator::DynIterator a</code></p> <p>Same as <code>Iterator::append</code> but a little fast.</p>"},{"location":"Minilib.Collection.RBTree/#_less_than","title":"_less_than","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; a -&gt; Std::Bool</code></p> <p>Default less_than function using <code>LessThan</code> trait.</p>"},{"location":"Minilib.Collection.RBTree/#_remove_fix_left","title":"_remove_fix_left","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p> <p>Called when <code>node.left.level == node.right.level - 1</code>. Returns <code>(active, fixed)</code> where <code>fixed</code> is the fixed node, and <code>active</code> is true iff <code>fixed.level = node.level - 1</code>.</p>"},{"location":"Minilib.Collection.RBTree/#_remove_fix_left_inner","title":"_remove_fix_left_inner","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p>"},{"location":"Minilib.Collection.RBTree/#_remove_fix_right","title":"_remove_fix_right","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p> <p>Called when <code>node.right.level == node.level.level - 1</code>. Returns <code>(active, fixed)</code> where <code>fixed</code> is the fixed node, and <code>active</code> is true iff <code>fixed.level = node.level - 1</code>.</p>"},{"location":"Minilib.Collection.RBTree/#_remove_fix_right_inner","title":"_remove_fix_right_inner","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p>"},{"location":"Minilib.Collection.RBTree/#_remove_max","title":"_remove_max","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a, a)</code></p> <p><code>node._remove_max</code> removes an maximum element. Returns <code>(active, removed, max)</code> where <code>removed</code> is the node after removal, <code>max</code> is the maximum element, and <code>active</code> is true iff <code>removed.level == node.level - 1</code>.</p>"},{"location":"Minilib.Collection.RBTree/#_remove_min","title":"_remove_min","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a, a)</code></p> <p><code>node._remove_min</code> removes an minimum element. Returns <code>(active, removed, min)</code> where <code>removed</code> is the node after removal, <code>min</code> is the minimum element, and <code>active</code> is true iff <code>removed.level == node.level - 1</code>.</p>"},{"location":"Minilib.Collection.RBTree/#_to_array_inner","title":"_to_array_inner","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Std::Array a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Array a</code></p>"},{"location":"Minilib.Collection.RBTree/#_try_remove_range","title":"_try_remove_range","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Option (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p> <p><code>node._try_remove_range(lt_begin, lt_end)</code> tries to remove single element <code>elem</code> where <code>!elem.lt_begin &amp;&amp; elem.lt_end</code> is true. Even if there are several elements that holds the condition, only one of them are removed. Returns <code>some((active, removed))</code> if removal is succeeded where <code>removed</code> is the node after removal, and <code>active</code> is true iff <code>removed.level == node.level - 1</code>. Returns <code>none()</code> if removal is failed.</p>"},{"location":"Minilib.Collection.RBTree/#_try_remove_range_inner","title":"_try_remove_range_inner","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Option (Std::Bool, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p>"},{"location":"Minilib.Collection.RBTree/#_upsert_inner","title":"_upsert_inner","text":"<p>Type: <code>a -&gt; (a -&gt; a) -&gt; (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#find","title":"find","text":"<p>Type: <code>a -&gt; (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Option a</code></p> <p><code>node.find(x, less_than)</code> finds an element <code>elem</code> that is equivalent to <code>x</code>, ie. <code>!less_than(elem, x) &amp;&amp; !less_than(x, elem)</code> is true.</p>"},{"location":"Minilib.Collection.RBTree/#find_range","title":"find_range","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Iterator::DynIterator a</code></p> <p><code>node.find_range(lt_begin, lt_end)</code> finds all elements <code>elem</code> such that <code>!elem.lt_begin &amp;&amp; elem.lt_end</code> is true. NOTE: <code>lt_begin</code> and <code>lt_end</code> must meet following condition: for all <code>x</code>, <code>x.lt_begin</code> is true then <code>x.lt_end</code> must be true.</p>"},{"location":"Minilib.Collection.RBTree/#find_range_descending","title":"find_range_descending","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Iterator::DynIterator a</code></p> <p><code>node.find_range(lt_begin, lt_end)</code> finds all elements <code>elem</code> such that <code>!elem.lt_begin &amp;&amp; elem.lt_end</code> is true, in descending order. NOTE: <code>lt_begin</code> and <code>lt_end</code> must meet following condition: for all <code>x</code>, <code>x.lt_begin</code> is true then <code>x.lt_end</code> must be true.</p>"},{"location":"Minilib.Collection.RBTree/#from_iter","title":"from_iter","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.RBTree::RBNode::RBNodeElem, it : Std::Iterator, Std::Iterator::Item it = a] it -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#from_iter_lt","title":"from_iter_lt","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem, it : Std::Iterator, Std::Iterator::Item it = a] (a -&gt; a -&gt; Std::Bool) -&gt; it -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#get_color","title":"get_color","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; (Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#get_first","title":"get_first","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Option a</code></p> <p>Gets the first element (that is, the smallest element) of the tree.</p>"},{"location":"Minilib.Collection.RBTree/#get_last","title":"get_last","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Option a</code></p> <p>Gets the last element (that is, the largest element) of the tree.</p>"},{"location":"Minilib.Collection.RBTree/#get_left","title":"get_left","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#get_right","title":"get_right","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#get_size","title":"get_size","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::I64</code></p> <p>Gets the number of elements.</p>"},{"location":"Minilib.Collection.RBTree/#get_triplet","title":"get_triplet","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a -&gt; (Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p> <p>If the node is black or red, <code>node.get_triplet</code> returns a triplet <code>(left, elem, right)</code>. If the node is empty, it will abort.</p>"},{"location":"Minilib.Collection.RBTree/#insert","title":"insert","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.insert(x)</code> inserts an element <code>x</code> using default <code>LessThan</code> ordering. If <code>node</code> already contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> is true, then <code>y</code> is replaced with <code>x</code>.</p>"},{"location":"Minilib.Collection.RBTree/#insert_lt","title":"insert_lt","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.insert_lt(x, less_than)</code> inserts an element <code>x</code> using <code>less_than</code> ordering. If <code>node</code> already contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!less_than(x,y) &amp;&amp; !less_than(y,x)</code> is true, then <code>y</code> is replaced with <code>x</code>.</p>"},{"location":"Minilib.Collection.RBTree/#level","title":"level","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::I64</code></p> <p>Returns the level of this node (ie. the number of black nodes from this node to any leaf). Panicks when the left and right nodes have different black count.</p>"},{"location":"Minilib.Collection.RBTree/#level_nonvalidate","title":"level_nonvalidate","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::I64</code></p> <p>Returns the level of this node (ie. the number of black nodes from this node to any leaf). This function does not validate, so an unbalanced node can be specified.</p>"},{"location":"Minilib.Collection.RBTree/#remove","title":"remove","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.remove(x)</code> removes any element <code>y</code> equivalent to <code>x</code>, ie. <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> is true.</p>"},{"location":"Minilib.Collection.RBTree/#remove_lt","title":"remove_lt","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.remove_lt(x, less_than)</code> removes any element <code>y</code> equivalent to <code>x</code>, ie. ie. <code>!less_than(x,y) &amp;&amp; !less_than(y,x)</code> is true.</p>"},{"location":"Minilib.Collection.RBTree/#remove_range","title":"remove_range","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.remove_range(lt_begin, lt_end)</code> removes all elements <code>elem</code> where <code>!elem.lt_begin &amp;&amp; elem.lt_end</code> is true. NOTE: <code>lt_begin</code> and <code>lt_end</code> must meet following condition: for all <code>x</code>, <code>x.lt_begin</code> is true then <code>x.lt_end</code> must be true.</p>"},{"location":"Minilib.Collection.RBTree/#set_color","title":"set_color","text":"<p>Type: <code>((Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#set_triplet","title":"set_triplet","text":"<p>Type: <code>(Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.RBTree/#to_array","title":"to_array","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Array a</code></p>"},{"location":"Minilib.Collection.RBTree/#to_iter","title":"to_iter","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Std::Iterator::DynIterator a</code></p>"},{"location":"Minilib.Collection.RBTree/#upsert","title":"upsert","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; (a -&gt; a) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.upsert(x, updater)</code> inserts or updates using default <code>LessThan</code> ordering. If <code>node</code> does not contain an element equivalent to <code>x</code>, <code>x</code> is inserted. If <code>node</code> already contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> is true, then <code>y</code> is updated with <code>updater(y)</code>.</p>"},{"location":"Minilib.Collection.RBTree/#upsert_lt","title":"upsert_lt","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] a -&gt; (a -&gt; a) -&gt; (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; Minilib.Collection.RBTree::RBNode::RBNode a</code></p> <p><code>node.upsert_lt(x, less_than)</code> inserts or updates using <code>less_than</code> ordering. If <code>node</code> does not contain an element equivalent to <code>x</code>, <code>x</code> is inserted. If <code>node</code> already contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!less_than(x,y) &amp;&amp; !less_than(y,x)</code> is true, then <code>y</code> is updated with <code>updater(y)</code>.</p>"},{"location":"Minilib.Collection.RBTree/#validate","title":"validate","text":"<p>Type: <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem] (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.RBTree::RBNode::RBNode a -&gt; (Std::I64, Std::Option a, Std::Option a)</code></p> <p>Validates that: - the left and right nodes have same black count - children of a red node is not red - max of left node &lt; elem - elem &lt; min of right node Returns <code>(level, min, max)</code>. Panicks if validation failed.</p>"},{"location":"Minilib.Collection.RBTree/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Collection.RBTree/#namespace-minilibcollectionrbtreerbnode_1","title":"namespace Minilib.Collection.RBTree::RBNode","text":""},{"location":"Minilib.Collection.RBTree/#rbnode","title":"RBNode","text":"<p>Defined as: <code>type RBNode a = box union { ...variants... }</code></p> <p>A type of red-black tree node.</p>"},{"location":"Minilib.Collection.RBTree/#variant-empty","title":"variant <code>empty</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Collection.RBTree/#variant-red","title":"variant <code>red</code>","text":"<p>Type: <code>(Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p>"},{"location":"Minilib.Collection.RBTree/#variant-black","title":"variant <code>black</code>","text":"<p>Type: <code>(Minilib.Collection.RBTree::RBNode::RBNode a, a, Minilib.Collection.RBTree::RBNode::RBNode a)</code></p>"},{"location":"Minilib.Collection.RBTree/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Collection.RBTree/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Collection.RBTree/#impl-a-minilibcollectionrbtreerbnoderbnodeelem-a-stdtostring-minilibcollectionrbtreerbnoderbnode-a-stdtostring","title":"impl <code>[a : Minilib.Collection.RBTree::RBNode::RBNodeElem, a : Std::ToString] Minilib.Collection.RBTree::RBNode::RBNode a : Std::ToString</code>","text":""},{"location":"Minilib.Collection.TreeMap/","title":"Minilib.Collection.TreeMap","text":"<p>Defined in minilib-collection@0.5.1</p> <p>TreeMap is a map that manages keys in sorted order.</p>"},{"location":"Minilib.Collection.TreeMap/#values","title":"Values","text":""},{"location":"Minilib.Collection.TreeMap/#namespace-minilibcollectiontreemaptreemap","title":"namespace Minilib.Collection.TreeMap::TreeMap","text":""},{"location":"Minilib.Collection.TreeMap/#_lift_lt","title":"_lift_lt","text":"<p>Type: <code>(k -&gt; k -&gt; Std::Bool) -&gt; (k, v) -&gt; (k, v) -&gt; Std::Bool</code></p> <p>Converts key_less_than to entry_less_than.</p>"},{"location":"Minilib.Collection.TreeMap/#contains_key","title":"contains_key","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Bool</code></p> <p>Checks whether a TreeMap contains a key.</p>"},{"location":"Minilib.Collection.TreeMap/#erase","title":"erase","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p>Erases an entry from a TreeMap. For example, <code>tm.erase(k)</code> removes an entry <code>(k,v)</code> from <code>tm</code>.</p> <p>NOTE: If <code>tm</code> contains an entry <code>(k1,v1)</code> where the key <code>k1</code> is equivalent to <code>k</code>, ie. <code>!less_than(k,k1) &amp;&amp; !less_than(k1,k)</code> is true, then <code>(k1,v1)</code> is removed.</p>"},{"location":"Minilib.Collection.TreeMap/#find","title":"find","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Option v</code></p> <p>Finds an element from a TreeMap.</p>"},{"location":"Minilib.Collection.TreeMap/#find_range","title":"find_range","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; k -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Iterator::DynIterator (k, v)</code></p> <p><code>tm.find_range(begin, end)</code> finds all entries <code>(k,v)</code> where <code>!less_than(k, begin) &amp;&amp; less_than(k, end)</code> is true. In default <code>LessThan</code> ordering, that condition is same as <code>begin &lt;= k &amp;&amp; k &lt; end</code>.</p>"},{"location":"Minilib.Collection.TreeMap/#find_raw_range","title":"find_raw_range","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] ((k, v) -&gt; Std::Bool) -&gt; ((k, v) -&gt; Std::Bool) -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Iterator::DynIterator (k, v)</code></p> <p><code>tm.find_raw_range(lt_begin, lt_end)</code> finds all entries <code>(k,v)</code> where <code>!lt_begin((k, v)) &amp;&amp; lt_end((k, v))</code> is true. NOTE: <code>lt_begin</code> and <code>lt_end</code> must meet following condition: for all <code>(k,v)</code>, <code>lt_begin((k,v))</code> is true then <code>lt_end((k,v))</code> must be true.</p>"},{"location":"Minilib.Collection.TreeMap/#from_iter","title":"from_iter","text":"<p>Type: <code>[k : Std::LessThan, k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue, it : Std::Iterator, Std::Iterator::Item it = (k, v)] it -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p>Converts an iterator of key-value pairs into a TreeMap using default <code>LessThan</code> ordering.</p>"},{"location":"Minilib.Collection.TreeMap/#from_iter_lt","title":"from_iter_lt","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue, it : Std::Iterator, Std::Iterator::Item it = (k, v)] (k -&gt; k -&gt; Std::Bool) -&gt; it -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p>Converts an iterator of key-value pairs into a TreeMap using specified ordering.</p>"},{"location":"Minilib.Collection.TreeMap/#get_size","title":"get_size","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::I64</code></p> <p>Gets the number of entries.</p>"},{"location":"Minilib.Collection.TreeMap/#insert","title":"insert","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; v -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p>Inserts an entry into a TreeMap. For example, <code>tm.insert(k, v)</code> inserts an entry <code>(k,v)</code> into <code>tm</code>.</p> <p>NOTE: If <code>tm</code> already contains an entry <code>(k1,v1)</code> where the key <code>k1</code> is equivalent to <code>k</code>, ie. <code>!less_than(k,k1) &amp;&amp; !less_than(k1,k)</code> is true, then <code>(k1,v1)</code> is replaced with <code>(k,v)</code>.</p>"},{"location":"Minilib.Collection.TreeMap/#is_empty","title":"is_empty","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Bool</code></p> <p>Checks whether a TreeMap is empty.</p>"},{"location":"Minilib.Collection.TreeMap/#keys","title":"keys","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Iterator::DynIterator k</code></p> <p>Returns an iterator of keys in ascending order.</p>"},{"location":"Minilib.Collection.TreeMap/#make","title":"make","text":"<p>Type: <code>[k : Std::LessThan, k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] () -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p><code>TreeMap::make()</code> creates an empty <code>TreeMap</code> using default <code>LessThan</code> ordering.</p>"},{"location":"Minilib.Collection.TreeMap/#make_lt","title":"make_lt","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] (k -&gt; k -&gt; Std::Bool) -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p><code>TreeMap::make_lt(less_than)</code> creates an empty <code>TreeMap</code> using specified ordering. NOTE: <code>less_than</code> function must meet specific conditions. For details, see documentation of <code>RBTree</code>.</p>"},{"location":"Minilib.Collection.TreeMap/#to_array","title":"to_array","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Array (k, v)</code></p> <p>Converts a TreeMap into an array of key-value pairs in ascending order of keys.</p>"},{"location":"Minilib.Collection.TreeMap/#to_iter","title":"to_iter","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Std::Iterator::DynIterator (k, v)</code></p> <p>Converts a TreeMap into an iterator of key-value pairs in ascending order of keys.</p>"},{"location":"Minilib.Collection.TreeMap/#upsert","title":"upsert","text":"<p>Type: <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] k -&gt; v -&gt; (v -&gt; v) -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v -&gt; Minilib.Collection.TreeMap::TreeMap::TreeMap k v</code></p> <p>Inserts or updates an entry in a TreeMap. For example, <code>tm.upsert(k, v, updater)</code> inserts an entry <code>(k,v)</code> into <code>tm</code>.</p> <p>NOTE: If <code>tm</code> already contains an entry <code>(k1,v1)</code> where the key <code>k1</code> is equivalent to <code>k</code>, ie. <code>!less_than(k,k1) &amp;&amp; !less_than(k1,k)</code> is true, then <code>(k1,v1)</code> is replaced with <code>(k, updater(v1))</code>.</p>"},{"location":"Minilib.Collection.TreeMap/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Collection.TreeMap/#namespace-minilibcollectiontreemaptreemap_1","title":"namespace Minilib.Collection.TreeMap::TreeMap","text":""},{"location":"Minilib.Collection.TreeMap/#treemap","title":"TreeMap","text":"<p>Defined as: <code>type TreeMap k v = unbox struct { ...fields... }</code></p> <p><code>TreeMap</code> is a structure that stores key-value pairs into a red-black tree.</p>"},{"location":"Minilib.Collection.TreeMap/#field-root","title":"field <code>root</code>","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode (k, v)</code></p>"},{"location":"Minilib.Collection.TreeMap/#field-key_less_than","title":"field <code>key_less_than</code>","text":"<p>Type: <code>k -&gt; k -&gt; Std::Bool</code></p>"},{"location":"Minilib.Collection.TreeMap/#field-entry_less_than","title":"field <code>entry_less_than</code>","text":"<p>Type: <code>(k, v) -&gt; (k, v) -&gt; Std::Bool</code></p>"},{"location":"Minilib.Collection.TreeMap/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Collection.TreeMap/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Collection.TreeMap/#impl-k-minilibcollectiontreemaptreemaptreemapkey-v-minilibcollectiontreemaptreemaptreemapvalue-minilibcollectiontreemaptreemaptreemap-k-v-stdtostring","title":"impl <code>[k : Minilib.Collection.TreeMap::TreeMap::TreeMapKey, v : Minilib.Collection.TreeMap::TreeMap::TreeMapValue] Minilib.Collection.TreeMap::TreeMap::TreeMap k v : Std::ToString</code>","text":""},{"location":"Minilib.Collection.TreeSet/","title":"Minilib.Collection.TreeSet","text":"<p>Defined in minilib-collection@0.5.1</p> <p>TreeSet is a set that manages elements in sorted order.</p>"},{"location":"Minilib.Collection.TreeSet/#values","title":"Values","text":""},{"location":"Minilib.Collection.TreeSet/#namespace-minilibcollectiontreesettreeset","title":"namespace Minilib.Collection.TreeSet::TreeSet","text":""},{"location":"Minilib.Collection.TreeSet/#contains","title":"contains","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Bool</code></p> <p>Checks whether a TreeSet contains an element.</p>"},{"location":"Minilib.Collection.TreeSet/#erase","title":"erase","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Erases an element from a TreeSet. For example, <code>ts.erase(x)</code> removes <code>x</code> from <code>ts</code>.</p> <p>NOTE: If <code>ts</code> contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!less_than(x,y) &amp;&amp; !less_than(y,x)</code> is true, then <code>y</code> is removed.</p>"},{"location":"Minilib.Collection.TreeSet/#find_range","title":"find_range","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] a -&gt; a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Iterator::DynIterator a</code></p> <p><code>ts.find_range(begin, end)</code> finds all elements <code>x</code> where <code>!less_than(x, begin) &amp;&amp; less_than(x, end)</code> is true. In default <code>LessThan</code> ordering, that condition is same as <code>begin &lt;= x &amp;&amp; x &lt; end</code>.</p>"},{"location":"Minilib.Collection.TreeSet/#find_raw_range","title":"find_raw_range","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] (a -&gt; Std::Bool) -&gt; (a -&gt; Std::Bool) -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Iterator::DynIterator a</code></p> <p><code>ts.find_raw_range(lt_begin, lt_end)</code> finds all elements <code>x</code> where <code>!lt_begin(x) &amp;&amp; lt_end(x)</code> is true. NOTE: <code>lt_begin</code> and <code>lt_end</code> must meet following condition: for all <code>x</code>, <code>x.lt_begin</code> is true then <code>x.lt_end</code> must be true.</p>"},{"location":"Minilib.Collection.TreeSet/#from_iter","title":"from_iter","text":"<p>Type: <code>[a : Std::LessThan, a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem, it : Std::Iterator, Std::Iterator::Item it = a] it -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Converts an iterator into a TreeSet using default <code>LessThan</code> ordering.</p>"},{"location":"Minilib.Collection.TreeSet/#from_iter_lt","title":"from_iter_lt","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem, it : Std::Iterator, Std::Iterator::Item it = a] (a -&gt; a -&gt; Std::Bool) -&gt; it -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Converts an iterator into a TreeSet using specified ordering.</p>"},{"location":"Minilib.Collection.TreeSet/#get_size","title":"get_size","text":"<p>Type: <code>Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::I64</code></p> <p>Gets the number of elements.</p>"},{"location":"Minilib.Collection.TreeSet/#insert","title":"insert","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Inserts an element into a TreeSet. For example, <code>ts.insert(x)</code> inserts <code>x</code> into <code>ts</code>.</p> <p>NOTE: If <code>ts</code> already contains an element <code>y</code> equivalent to <code>x</code>, ie. <code>!less_than(x,y) &amp;&amp; !less_than(y,x)</code> is true, then <code>y</code> is replaced with <code>x</code>.</p>"},{"location":"Minilib.Collection.TreeSet/#intersect","title":"intersect","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Calculates intersection of two TreeSets.</p>"},{"location":"Minilib.Collection.TreeSet/#is_empty","title":"is_empty","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Bool</code></p> <p>Checks whether a TreeSet is empty.</p>"},{"location":"Minilib.Collection.TreeSet/#make","title":"make","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem, a : Std::LessThan] () -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p><code>TreeSet::make()</code> creates an empty <code>TreeSet</code> using default <code>LessThan</code> ordering.</p>"},{"location":"Minilib.Collection.TreeSet/#make_lt","title":"make_lt","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] (a -&gt; a -&gt; Std::Bool) -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p><code>TreeSet::make_lt(less_than)</code> creates an empty <code>TreeSet</code> using specified ordering. NOTE: <code>less_than</code> function must meet specific conditions. For details, see documentation of <code>RBTree</code>.</p>"},{"location":"Minilib.Collection.TreeSet/#merge","title":"merge","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Minilib.Collection.TreeSet::TreeSet::TreeSet a</code></p> <p>Calculates union of two TreeSets.</p>"},{"location":"Minilib.Collection.TreeSet/#to_array","title":"to_array","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Array a</code></p> <p>Converts a TreeSet into an array in sorted order.</p>"},{"location":"Minilib.Collection.TreeSet/#to_iter","title":"to_iter","text":"<p>Type: <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a -&gt; Std::Iterator::DynIterator a</code></p> <p>Converts a TreeSet into an iterator in sorted order.</p>"},{"location":"Minilib.Collection.TreeSet/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Collection.TreeSet/#namespace-minilibcollectiontreesettreeset_1","title":"namespace Minilib.Collection.TreeSet::TreeSet","text":""},{"location":"Minilib.Collection.TreeSet/#treeset","title":"TreeSet","text":"<p>Defined as: <code>type TreeSet a = unbox struct { ...fields... }</code></p> <p>A type of set that manages elements in sorted order.</p>"},{"location":"Minilib.Collection.TreeSet/#field-root","title":"field <code>root</code>","text":"<p>Type: <code>Minilib.Collection.RBTree::RBNode::RBNode a</code></p>"},{"location":"Minilib.Collection.TreeSet/#field-less_than","title":"field <code>less_than</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p>"},{"location":"Minilib.Collection.TreeSet/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Collection.TreeSet/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Collection.TreeSet/#impl-a-minilibcollectiontreesettreesettreesetelem-minilibcollectiontreesettreesettreeset-a-stdtostring","title":"impl <code>[a : Minilib.Collection.TreeSet::TreeSet::TreeSetElem] Minilib.Collection.TreeSet::TreeSet::TreeSet a : Std::ToString</code>","text":"<p>Converts a TreeSet into a String.</p>"},{"location":"Minilib.Common.Assert/","title":"Minilib.Common.Assert","text":"<p>Defined in minilib-common@0.5.2</p> <p>Assert functions.</p>"},{"location":"Minilib.Common.Assert/#values","title":"Values","text":""},{"location":"Minilib.Common.Assert/#namespace-minilibcommonassert","title":"namespace Minilib.Common.Assert","text":""},{"location":"Minilib.Common.Assert/#assert_eq_lazy","title":"assert_eq_lazy","text":"<p>Type: <code>[a : Std::Eq] Std::Lazy Std::String -&gt; a -&gt; a -&gt; Std::Lazy b -&gt; b</code></p> <p><code>assert_eq_lazy(errmsg, lhs, rhs, lazy_func)</code> asserts that two values are equal. If the assertion failed, prints a message to the stderr and aborts the program. If the assertion succeeded, calls a lazy function. For example, instead of <code>eval *assert_eq(|_| \"error\", a, b); ...</code> in an IO monad, you can write <code>assert_eq_lazy(|_| \"error\", a, b) $ |_| ...</code>.</p>"},{"location":"Minilib.Common.Assert/#assert_lazy","title":"assert_lazy","text":"<p>Type: <code>Std::Lazy Std::String -&gt; Std::Bool -&gt; Std::Lazy a -&gt; a</code></p> <p><code>assert_lazy(errmsg, value, lazy_func)</code> asserts that a condition (boolean value) is true. If the assertion failed, prints a message to the stderr and aborts the program. If the assertion succeeded, calls a lazy function.</p> <p>For example, instead of <code>eval *assert(|_| \"error\", a == b); ...</code> in an IO monad, you can write <code>assert_lazy(|_| \"error\", a == b) $ |_| ...</code>.</p>"},{"location":"Minilib.Common.Assert/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Common.Assert/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Common.Assert/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Common.Common/","title":"Minilib.Common.Common","text":"<p>Defined in minilib-common@0.5.2</p> <p>Common functions such as <code>id</code> and <code>flip</code>.</p>"},{"location":"Minilib.Common.Common/#values","title":"Values","text":""},{"location":"Minilib.Common.Common/#namespace-minilibcommoncommon","title":"namespace Minilib.Common.Common","text":""},{"location":"Minilib.Common.Common/#apply","title":"apply","text":"<p>Type: <code>a -&gt; (a -&gt; b) -&gt; b</code></p> <p><code>apply(a, f)</code> is equal to <code>f(a)</code>. You can write it as <code>apply(a) $ f</code>, <code>a.apply $ f</code> or <code>f.apply(a)</code>.</p>"},{"location":"Minilib.Common.Common/#compose2","title":"compose2","text":"<p>Type: <code>(a -&gt; b -&gt; c) -&gt; (c -&gt; d) -&gt; a -&gt; b -&gt; d</code></p> <p><code>compose2</code> composes a two-argument function with a one-argument function.</p>"},{"location":"Minilib.Common.Common/#const","title":"const","text":"<p>Type: <code>a -&gt; b -&gt; a</code></p> <p><code>const</code> is a constant function. It returns its first argument ignoring its second argument. ie. <code>const(a,b)</code> returns <code>a</code>. Note that <code>const(id)(a,b)</code> returns <code>b</code>, since <code>const(id)(a,b) = const(id,a)(b) = id(b) = b</code>.</p>"},{"location":"Minilib.Common.Common/#curry","title":"curry","text":"<p>Type: <code>((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c</code></p> <p><code>curry</code> converts an uncurried function to a curried function.</p>"},{"location":"Minilib.Common.Common/#flip","title":"flip","text":"<p>Type: <code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code></p> <p><code>flip(f)</code> swaps the first argument and the second argument.</p>"},{"location":"Minilib.Common.Common/#id","title":"id","text":"<p>Type: <code>a -&gt; a</code></p> <p><code>id</code> is an identity function.</p>"},{"location":"Minilib.Common.Common/#pair","title":"pair","text":"<p>Type: <code>a -&gt; b -&gt; (a, b)</code></p> <p><code>pair(a,b)</code> returns <code>(a, b)</code>.</p>"},{"location":"Minilib.Common.Common/#swap","title":"swap","text":"<p>Type: <code>(a, b) -&gt; (b, a)</code></p> <p><code>swap</code> is a function that swaps the first component and the second component of <code>Tuple2</code>. ie. <code>(a,b).swap</code> returns <code>(b, a)</code>.</p>"},{"location":"Minilib.Common.Common/#uncurry","title":"uncurry","text":"<p>Type: <code>(a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</code></p> <p><code>uncurry</code> converts a curried function to an uncurried function.</p>"},{"location":"Minilib.Common.Common/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Common.Common/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Common.Common/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Common.RandomEx/","title":"Minilib.Common.RandomEx","text":"<p>Defined in minilib-random@0.5.2</p> <p>Extension of <code>Random</code> module. For example, generating a random integer in range, or a random array.</p>"},{"location":"Minilib.Common.RandomEx/#values","title":"Values","text":""},{"location":"Minilib.Common.RandomEx/#namespace-minilibcommonrandomex","title":"namespace Minilib.Common.RandomEx","text":""},{"location":"Minilib.Common.RandomEx/#generate_i64_range","title":"generate_I64_range","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Random::Random -&gt; (Random::Random, Std::I64)</code></p> <p><code>random.generate_I64_range(begin, end)</code> generates a random integer <code>r</code> such that <code>begin &lt;= r &amp;&amp; r &lt; end</code>. if <code>begin &gt;= end</code>, it panicks.</p>"},{"location":"Minilib.Common.RandomEx/#generate_u16","title":"generate_U16","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::U16)</code></p> <p><code>random.generate_U16</code> generates a random integer of U16.</p>"},{"location":"Minilib.Common.RandomEx/#generate_u32","title":"generate_U32","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::U32)</code></p> <p><code>random.generate_U32</code> generates a random integer of U32.</p>"},{"location":"Minilib.Common.RandomEx/#generate_u8","title":"generate_U8","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::U8)</code></p> <p><code>random.generate_U8</code> generates a random integer of U8.</p>"},{"location":"Minilib.Common.RandomEx/#generate_array","title":"generate_array","text":"<p>Type: <code>Std::I64 -&gt; (Random::Random -&gt; (Random::Random, a)) -&gt; Random::Random -&gt; (Random::Random, Std::Array a)</code></p> <p><code>random.generate_array(size, f)</code> generates a random array. Each element of the array is generated by <code>f</code>.</p>"},{"location":"Minilib.Common.RandomEx/#shuffle","title":"shuffle","text":"<p>Type: <code>Std::Array a -&gt; Random::Random -&gt; (Random::Random, Std::Array a)</code></p> <p>Shuffles an array.</p>"},{"location":"Minilib.Common.RandomEx/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Common.RandomEx/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Common.RandomEx/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Common.TimeEx/","title":"Minilib.Common.TimeEx","text":"<p>Defined in minilib-common@0.5.2</p> <p>Timing module, such as sleep for a while, and measuring execution time.</p>"},{"location":"Minilib.Common.TimeEx/#values","title":"Values","text":""},{"location":"Minilib.Common.TimeEx/#namespace-minilibcommontimeex","title":"namespace Minilib.Common.TimeEx","text":""},{"location":"Minilib.Common.TimeEx/#_repeat_io","title":"_repeat_io","text":"<p>Type: <code>Std::IO a -&gt; Std::I64 -&gt; Std::IO a</code></p>"},{"location":"Minilib.Common.TimeEx/#consumed_realtime_while_io","title":"consumed_realtime_while_io","text":"<p>Type: <code>Std::IO a -&gt; Std::IO (a, Std::F64)</code></p> <p>Get wall-clock time elapsed while executing an I/O action.</p>"},{"location":"Minilib.Common.TimeEx/#measure_time","title":"measure_time","text":"<p>Type: <code>Std::F64 -&gt; (() -&gt; a) -&gt; Std::IO (Std::F64, a)</code></p> <p>Measures wall-clock time per a function call. Specifically, It calls the function many times until the specified time limit (in second) passes and measures the total time. Returns the measured time per loop (in second) and the IO operation result. NOTE: The measured time per loop has a overhead about 0.1~1.0 usec.</p>"},{"location":"Minilib.Common.TimeEx/#measure_time_io","title":"measure_time_io","text":"<p>Type: <code>Std::F64 -&gt; Std::IO a -&gt; Std::IO (Std::F64, a)</code></p> <p>Measures wall-clock time per an IO operation. Specifically, It performs an IO operation many times until the specified time limit (in second) passes and measures the total time. Returns the measured time per loop (in second) and the IO operation result. NOTE: The measured time per loop has a overhead about 0.1~1.0 usec.</p>"},{"location":"Minilib.Common.TimeEx/#notimeit","title":"notimeit","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; (() -&gt; a) -&gt; Std::IO a</code></p> <p>Same interface as <code>timeit()</code> but does not measure time.</p>"},{"location":"Minilib.Common.TimeEx/#timeit","title":"timeit","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; (() -&gt; a) -&gt; Std::IO a</code></p> <p>Measures wall-clock time per a function call. Specifically, It calls the function many times and measures the total time. It then prints the function result and measured time per loop. NOTE: The measured time per loop has a overhead about 0.1~1.0 usec.</p>"},{"location":"Minilib.Common.TimeEx/#timeit_io","title":"timeit_io","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; Std::IO a -&gt; Std::IO a</code></p> <p>Measures wall-clock time per an IO operation. Specifically, It performs an IO operation many times and measures the total time. It then prints the IO operation result and measured time per loop. NOTE: The measured time per loop has a overhead about 0.1~1.0 usec.</p>"},{"location":"Minilib.Common.TimeEx/#usleep","title":"usleep","text":"<p>Type: <code>Std::U32 -&gt; Std::IO::IOFail ()</code></p> <p>Sleeps for specified micro-seconds. For details, see Linux manual page for usleep().</p>"},{"location":"Minilib.Common.TimeEx/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Common.TimeEx/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Common.TimeEx/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Comonad.Env/","title":"Minilib.Comonad.Env","text":"<p>Defined in minilib-comonad@0.5.1</p> <p>Env comonad. (a.k.a CoReader comonad)</p> <p>For details, see blog post: The Reader and Writer Monads and Comonads.</p>"},{"location":"Minilib.Comonad.Env/#values","title":"Values","text":""},{"location":"Minilib.Comonad.Env/#namespace-minilibcomonadenvenv","title":"namespace Minilib.Comonad.Env::Env","text":""},{"location":"Minilib.Comonad.Env/#env","title":"env","text":"<p>Type: <code>e -&gt; a -&gt; Minilib.Comonad.Env::Env e a</code></p> <p>Creates an env comonad from an enviroment and a value.</p>"},{"location":"Minilib.Comonad.Env/#env_t","title":"env_t","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] e -&gt; w a -&gt; Minilib.Comonad.Env::EnvT e w a</code></p> <p>Creates a generic env comonad from an enviroment and a value.</p>"},{"location":"Minilib.Comonad.Env/#get_env","title":"get_env","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Env::EnvT e w a -&gt; e</code></p> <p>Gets the envirionment from an env comonad.</p>"},{"location":"Minilib.Comonad.Env/#get_value","title":"get_value","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Env::EnvT e w a -&gt; a</code></p> <p>Gets the value from an env comonad.</p>"},{"location":"Minilib.Comonad.Env/#to_tuple","title":"to_tuple","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Env::EnvT e w a -&gt; (e, a)</code></p> <p>Converts a env comonad to a pair of an enviroment and a value.</p>"},{"location":"Minilib.Comonad.Env/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Comonad.Env/#namespace-minilibcomonadenv","title":"namespace Minilib.Comonad.Env","text":""},{"location":"Minilib.Comonad.Env/#env_1","title":"Env","text":"<p>Defined as: <code>type Env e a = Minilib.Comonad.Env::EnvT e Minilib.Comonad.IdentityC::IdentityC a</code></p>"},{"location":"Minilib.Comonad.Env/#envt","title":"EnvT","text":"<p>Defined as: <code>type [w : *-&gt;*] EnvT e w a = unbox struct { ...fields... }</code></p> <p>Env comonad wraps a pair of an environment and a value. <code>e</code> is a type of an environment. <code>w</code> is a type of an underlyind comonad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Comonad.Env/#field-env","title":"field <code>env</code>","text":"<p>Type: <code>e</code></p>"},{"location":"Minilib.Comonad.Env/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>w a</code></p>"},{"location":"Minilib.Comonad.Env/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Comonad.Env/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Comonad.Env/#impl-w-minilibtraitcomonadcomonad-minilibcomonadenvenvt-e-w-minilibtraitcomonadcomonad","title":"impl <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Env::EnvT e w : Minilib.Trait.Comonad::Comonad</code>","text":""},{"location":"Minilib.Comonad.Env/#impl-w-minilibtraitcomonadcomonad-minilibcomonadenvenvt-e-w-stdfunctor","title":"impl <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Env::EnvT e w : Std::Functor</code>","text":""},{"location":"Minilib.Comonad.IdentityC/","title":"Minilib.Comonad.IdentityC","text":"<p>Defined in minilib-comonad@0.5.1</p> <p>Identity comonad</p>"},{"location":"Minilib.Comonad.IdentityC/#values","title":"Values","text":""},{"location":"Minilib.Comonad.IdentityC/#namespace-minilibcomonadidentityc","title":"namespace Minilib.Comonad.IdentityC","text":""},{"location":"Minilib.Comonad.IdentityC/#get","title":"get","text":"<p>Type: <code>Minilib.Comonad.IdentityC::IdentityC a -&gt; a</code></p> <p>Gets a value from an identity comonad.</p>"},{"location":"Minilib.Comonad.IdentityC/#make","title":"make","text":"<p>Type: <code>a -&gt; Minilib.Comonad.IdentityC::IdentityC a</code></p> <p>Creates an identity comonad from a value.</p>"},{"location":"Minilib.Comonad.IdentityC/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Comonad.IdentityC/#namespace-minilibcomonadidentityc_1","title":"namespace Minilib.Comonad.IdentityC","text":""},{"location":"Minilib.Comonad.IdentityC/#identityc","title":"IdentityC","text":"<p>Defined as: <code>type IdentityC a = unbox struct { ...fields... }</code></p> <p>Identity comonad</p>"},{"location":"Minilib.Comonad.IdentityC/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Comonad.IdentityC/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Comonad.IdentityC/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Comonad.IdentityC/#impl-minilibcomonadidentitycidentityc-minilibtraitcomonadcomonad","title":"impl <code>Minilib.Comonad.IdentityC::IdentityC : Minilib.Trait.Comonad::Comonad</code>","text":""},{"location":"Minilib.Comonad.IdentityC/#impl-minilibcomonadidentitycidentityc-stdfunctor","title":"impl <code>Minilib.Comonad.IdentityC::IdentityC : Std::Functor</code>","text":""},{"location":"Minilib.Comonad.Traced/","title":"Minilib.Comonad.Traced","text":"<p>Defined in minilib-comonad@0.5.1</p> <p>Traced comonad. (a.k.a CoWriter comonad)</p> <p>For details, see blog post: The Reader and Writer Monads and Comonads.</p>"},{"location":"Minilib.Comonad.Traced/#values","title":"Values","text":""},{"location":"Minilib.Comonad.Traced/#namespace-minilibcomonadtracedtraced","title":"namespace Minilib.Comonad.Traced::Traced","text":""},{"location":"Minilib.Comonad.Traced/#run_traced","title":"run_traced","text":"<p>Type: <code>e -&gt; Minilib.Comonad.Traced::Traced e a -&gt; a</code></p> <p>Runs a traced commonad with the supplied environment.</p>"},{"location":"Minilib.Comonad.Traced/#run_traced_t","title":"run_traced_t","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Traced::TracedT e w a -&gt; w (e -&gt; a)</code></p> <p>Runs a generic traced commonad with the supplied environment.</p>"},{"location":"Minilib.Comonad.Traced/#traced","title":"traced","text":"<p>Type: <code>(e -&gt; a) -&gt; Minilib.Comonad.Traced::Traced e a</code></p> <p>Creates a traced comonad from a function.</p>"},{"location":"Minilib.Comonad.Traced/#traced_t","title":"traced_t","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] w (e -&gt; a) -&gt; Minilib.Comonad.Traced::TracedT e w a</code></p> <p>Creates a generic traced comonad from a function.</p>"},{"location":"Minilib.Comonad.Traced/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Comonad.Traced/#namespace-minilibcomonadtraced","title":"namespace Minilib.Comonad.Traced","text":""},{"location":"Minilib.Comonad.Traced/#traced_1","title":"Traced","text":"<p>Defined as: <code>type Traced e a = Minilib.Comonad.Traced::TracedT e Minilib.Comonad.IdentityC::IdentityC a</code></p>"},{"location":"Minilib.Comonad.Traced/#tracedt","title":"TracedT","text":"<p>Defined as: <code>type [w : *-&gt;*] TracedT e w a = unbox struct { ...fields... }</code></p> <p>Traced comonad. <code>e</code> is a type of an environment. <code>w</code> is a type of an underlyind comonad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Comonad.Traced/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>w (e -&gt; a)</code></p>"},{"location":"Minilib.Comonad.Traced/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Comonad.Traced/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Comonad.Traced/#impl-e-minilibtraitmonoidmonoid-w-minilibtraitcomonadcomonad-minilibcomonadtracedtracedt-e-w-minilibtraitcomonadcomonad","title":"impl <code>[e : Minilib.Trait.Monoid::Monoid, w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Traced::TracedT e w : Minilib.Trait.Comonad::Comonad</code>","text":""},{"location":"Minilib.Comonad.Traced/#impl-w-minilibtraitcomonadcomonad-minilibcomonadtracedtracedt-e-w-stdfunctor","title":"impl <code>[w : Minilib.Trait.Comonad::Comonad] Minilib.Comonad.Traced::TracedT e w : Std::Functor</code>","text":""},{"location":"Minilib.Crypto.AES.GCM/","title":"Minilib.Crypto.AES.GCM","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>Galois/Counter Mode (GCM) for AES</p> <p>Implemented from specification of NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC https://doi.org/10.6028/NIST.SP.800-38D</p>"},{"location":"Minilib.Crypto.AES.GCM/#values","title":"Values","text":""},{"location":"Minilib.Crypto.AES.GCM/#namespace-minilibcryptoaesgcmblock","title":"namespace Minilib.Crypto.AES.GCM::Block","text":""},{"location":"Minilib.Crypto.AES.GCM/#_gctr","title":"_GCTR","text":"<p>Type: <code>(Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block) -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Calculates GCTR() function.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_ghash","title":"_GHASH","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Std::Iterator::DynIterator Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Calculates GHASH() function.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_r","title":"_R","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block</code></p> <p>The reduction polynomial <code>R = 11100011 || 0^120</code>. This is the primitive polynomial of GF(2^128).</p>"},{"location":"Minilib.Crypto.AES.GCM/#_bit_xor","title":"_bit_xor","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Calculates bitwise XOR of two 128-bit blocks.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_bytes_to_blocks","title":"_bytes_to_blocks","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Iterator::DynIterator Minilib.Crypto.AES.GCM::Block</code></p> <p>Converts a byte array to an iterator of 128-bit blocks.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_inc_32","title":"_inc_32","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>6.2 Incrementing function</p>"},{"location":"Minilib.Crypto.AES.GCM/#_is_bit_set","title":"_is_bit_set","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Std::Bool</code></p> <p><code>x._is_bit_set(i)</code> returns true if the bit <code>i</code> is set. NOTE that the bit 0 is the leftmost bit (ie. MSB) of the block.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_mul","title":"_mul","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Multiplication operation of Blocks</p>"},{"location":"Minilib.Crypto.AES.GCM/#_mul_bitwise","title":"_mul_bitwise","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Multiplication operation of Blocks using bitwise-xor and reducing by the reduction polynomial <code>_R</code>.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_shift_right_1","title":"_shift_right_1","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Shifts a 128-bit block to right by 1 bit.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_u64_to_bitstring","title":"_u64_to_bitstring","text":"<p>Type: <code>Std::U64 -&gt; Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES.GCM/#_zero","title":"_zero","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block</code></p> <p>A zero block.</p>"},{"location":"Minilib.Crypto.AES.GCM/#get_block_be","title":"get_block_be","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p><code>buf.get_block_be(i)</code> reads a 128 bit block in big endian at position <code>i</code> in array <code>buf</code>.</p>"},{"location":"Minilib.Crypto.AES.GCM/#make","title":"make","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p><code>Block::make(hi, lo)</code> creates a 128 bit block.</p>"},{"location":"Minilib.Crypto.AES.GCM/#set_block_be","title":"set_block_be","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>buf.set_block_be(i, block)</code> writes a 128 bit block in big endian at position <code>i</code> in array <code>buf</code>.</p>"},{"location":"Minilib.Crypto.AES.GCM/#namespace-minilibcryptoaesgcmclmul","title":"namespace Minilib.Crypto.AES.GCM::CLMul","text":""},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u128_u128_reduce","title":"_clmul_u128_u128_reduce","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Performs multiplication operation on blocks. ie. clmul(u128, u128) and reduce the result by the reduction polynomial <code>R = 11100001 || 0^120</code>. NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u16_u16","title":"_clmul_u16_u16","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U32</code></p> <p>Performs carryless multiplication of U16 and U16. NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u32_u32","title":"_clmul_u32_u32","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U64</code></p> <p>Performs carryless multiplication of U32 and U32. NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u64_u64","title":"_clmul_u64_u64","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Performs carryless multiplication of U64 and U64. <code>z</code> is used as a buffer for setting the result. NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u8_u8","title":"_clmul_u8_u8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U16</code></p> <p>Performs carryless multiplication of U8 and U8.</p>"},{"location":"Minilib.Crypto.AES.GCM/#_clmul_u8_u8_table","title":"_clmul_u8_u8_table","text":"<p>Type: <code>Std::Array Std::U16</code></p>"},{"location":"Minilib.Crypto.AES.GCM/#namespace-minilibcryptoaesgcmgcm","title":"namespace Minilib.Crypto.AES.GCM::GCM","text":""},{"location":"Minilib.Crypto.AES.GCM/#_get_j0","title":"_get_j0","text":"<p>Type: <code>Minilib.Crypto.AES.GCM::Block -&gt; Std::Array Std::U8 -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>get the pre-counter block</p>"},{"location":"Minilib.Crypto.AES.GCM/#_get_tag","title":"_get_tag","text":"<p>Type: <code>(Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block) -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; Std::Array Std::U8</code></p> <p>get the authentication tag</p>"},{"location":"Minilib.Crypto.AES.GCM/#_to_cipher","title":"_to_cipher","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block</code></p> <p>Converts an AES structure to a cipher. NOTE: aes.decrypt_block will not be used in AES-GCM.</p>"},{"location":"Minilib.Crypto.AES.GCM/#gcm_ad","title":"gcm_ad","text":"<p>Type: <code>(Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block) -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; Std::Result Std::ErrMsg (Std::Array Std::U8)</code></p> <p>Performs authenticated decryption. Input: - cipher: 128-bit block cipher - iv: initialization vector, typically 96 bits - ciphertext: a byte sequence which will be decrypted - auth_data: a byte sequence which will not be encrypted - tag: authentication tag Output: ok(plaintext) or err(ErrMsg) - ok(plaintext): decrypted byte sequence - err(ErrMsg): inauthenticity</p>"},{"location":"Minilib.Crypto.AES.GCM/#gcm_ae","title":"gcm_ae","text":"<p>Type: <code>(Minilib.Crypto.AES.GCM::Block -&gt; Minilib.Crypto.AES.GCM::Block) -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; (Std::Array Std::U8, Std::Array Std::U8)</code></p> <p>Performs authenticated encryption. Input: - cipher: 128-bit block cipher - iv: initialization vector, typically 96 bits - plaintext: a byte sequence which will be encrypted - auth_data: a byte sequence which will not be encrypted - len_t: tag length in bits Output: (c, t) - c: ciphertext - t: authentication tag</p>"},{"location":"Minilib.Crypto.AES.GCM/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.AES.GCM/#namespace-minilibcryptoaesgcm","title":"namespace Minilib.Crypto.AES.GCM","text":""},{"location":"Minilib.Crypto.AES.GCM/#block","title":"Block","text":"<p>Defined as: <code>type Block = unbox struct { ...fields... }</code></p> <p>A block is a bit string of 128 bits. We use two U64 as a representation. When converted to a bit string, it is encoded in big-endian. If a byte sequence is encoded to a bit string, MSB of the first byte becomes the leftmost bit.</p>"},{"location":"Minilib.Crypto.AES.GCM/#field-hi","title":"field <code>hi</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.AES.GCM/#field-lo","title":"field <code>lo</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.AES.GCM/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.AES.GCM/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.AES.GCM/#impl-minilibcryptoaesgcmblock-minilibtexthextostringhex","title":"impl <code>Minilib.Crypto.AES.GCM::Block : Minilib.Text.Hex::ToStringHex</code>","text":""},{"location":"Minilib.Crypto.AES.GCM/#impl-minilibcryptoaesgcmblock-stdeq","title":"impl <code>Minilib.Crypto.AES.GCM::Block : Std::Eq</code>","text":""},{"location":"Minilib.Crypto.AES.GCM/#impl-minilibcryptoaesgcmblock-stdfrombytes","title":"impl <code>Minilib.Crypto.AES.GCM::Block : Std::FromBytes</code>","text":""},{"location":"Minilib.Crypto.AES.GCM/#impl-minilibcryptoaesgcmblock-stdtobytes","title":"impl <code>Minilib.Crypto.AES.GCM::Block : Std::ToBytes</code>","text":""},{"location":"Minilib.Crypto.AES.GCM/#impl-minilibcryptoaesgcmblock-stdtostring","title":"impl <code>Minilib.Crypto.AES.GCM::Block : Std::ToString</code>","text":""},{"location":"Minilib.Crypto.AES/","title":"Minilib.Crypto.AES","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>Advanced Encryption Standard (AES)</p> <p>Implemented from specification of FIPS 197: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf https://doi.org/10.6028/NIST.FIPS.197-upd1</p>"},{"location":"Minilib.Crypto.AES/#values","title":"Values","text":""},{"location":"Minilib.Crypto.AES/#namespace-minilibcryptoaesaes","title":"namespace Minilib.Crypto.AES::AES","text":""},{"location":"Minilib.Crypto.AES/#_add_round_key","title":"_add_round_key","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::I64 -&gt; Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.1.4 ADDROUNDKEY()</p>"},{"location":"Minilib.Crypto.AES/#_cipher","title":"_cipher","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U32 -&gt; Minilib.Crypto.AES::AES -&gt; Std::Array Std::U8</code></p> <p>5.1 CIPHER()</p>"},{"location":"Minilib.Crypto.AES/#_empty","title":"_empty","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Crypto.AES::AES</code></p>"},{"location":"Minilib.Crypto.AES/#_get_number_of_rounds","title":"_get_number_of_rounds","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Std::I64</code></p> <ol> <li>Algorithm Specifcations</li> </ol>"},{"location":"Minilib.Crypto.AES/#_get_output","title":"_get_output","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_inv_cipher","title":"_inv_cipher","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U32 -&gt; Minilib.Crypto.AES::AES -&gt; Std::Array Std::U8</code></p> <p>5.3 INVCIPHER()</p>"},{"location":"Minilib.Crypto.AES/#_inv_mix_column","title":"_inv_mix_column","text":"<p>Type: <code>Std::U32 -&gt; Std::I64 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#_inv_mix_columns","title":"_inv_mix_columns","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.3.3 INVMIXCOLUMNS()</p>"},{"location":"Minilib.Crypto.AES/#_inv_sbox_table","title":"_inv_sbox_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_inv_shift_rows","title":"_inv_shift_rows","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.3.1 INVSHIFTROWS()</p>"},{"location":"Minilib.Crypto.AES/#_inv_sub_bytes","title":"_inv_sub_bytes","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.3.2 INVSUBBYTES()</p>"},{"location":"Minilib.Crypto.AES/#_key_expansion","title":"_key_expansion","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.AES::AES -&gt; Std::Array Std::U32</code></p> <p>5.2 KEYEXPANSION()</p>"},{"location":"Minilib.Crypto.AES/#_mix_column","title":"_mix_column","text":"<p>Type: <code>Std::U32 -&gt; Std::I64 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#_mix_columns","title":"_mix_columns","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.1.3 MIXCOLUMNS()</p>"},{"location":"Minilib.Crypto.AES/#_rcon","title":"_rcon","text":"<p>Type: <code>Std::I64 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#_rcon_table","title":"_rcon_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_rot_word","title":"_rot_word","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#_rotr","title":"_rotr","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>rotate right</p>"},{"location":"Minilib.Crypto.AES/#_sbox","title":"_sbox","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>SBOX</p>"},{"location":"Minilib.Crypto.AES/#_sbox_table","title":"_sbox_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_set_input","title":"_set_input","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p>"},{"location":"Minilib.Crypto.AES/#_shift_rows","title":"_shift_rows","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.1.2 SHIFTROWS()</p>"},{"location":"Minilib.Crypto.AES/#_sub_bytes","title":"_sub_bytes","text":"<p>Type: <code>Minilib.Crypto.AES::AES -&gt; Minilib.Crypto.AES::AES</code></p> <p>5.1.1 SUBBYTES()</p>"},{"location":"Minilib.Crypto.AES/#_sub_u64","title":"_sub_u64","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::U64 -&gt; Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.AES/#_sub_word","title":"_sub_word","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#decrypt_block","title":"decrypt_block","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.AES::AES -&gt; Std::Array Std::U8</code></p> <p><code>aes.decrypt_block(ciphertext)</code> decrypts a block of ciphertext to a block of plaintext. <code>ciphertext</code> must be a byte array of 128 bits (= 16 bytes).</p>"},{"location":"Minilib.Crypto.AES/#encrypt_block","title":"encrypt_block","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.AES::AES -&gt; Std::Array Std::U8</code></p> <p><code>aes.encrypt_block(plaintext)</code> encrypts a block of plaintext to a block of ciphertext. <code>plaintext</code> must be a byte array of 128 bits (= 16 bytes).</p>"},{"location":"Minilib.Crypto.AES/#make","title":"make","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.AES::AES</code></p> <p><code>AES::make(key)</code> creates an AES cipher. <code>key</code> must be a byte array of 128 bits (= 16 bytes), 192 bits (= 24 bytes), or 256 bits (= 32 bytes).</p>"},{"location":"Minilib.Crypto.AES/#namespace-minilibcryptoaesgf8","title":"namespace Minilib.Crypto.AES::GF8","text":""},{"location":"Minilib.Crypto.AES/#_add_gf8","title":"_add_gf8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>4.1 Addition in GF(2^8)</p>"},{"location":"Minilib.Crypto.AES/#_inv_gf8","title":"_inv_gf8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>4.4 Multiplicative Inverses in GF(2^8)</p>"},{"location":"Minilib.Crypto.AES/#_mul_gf8","title":"_mul_gf8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>4.2 Multiplication in GF(2^8)</p>"},{"location":"Minilib.Crypto.AES/#_mul_gf8_slow","title":"_mul_gf8_slow","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_mul_gf8_table","title":"_mul_gf8_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#_pow_gf8","title":"_pow_gf8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p><code>a._pow_gf8(n)</code> calculates <code>a ^ n</code>.</p>"},{"location":"Minilib.Crypto.AES/#_xtimes","title":"_xtimes","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.AES/#namespace-minilibcryptoaes","title":"namespace Minilib.Crypto.AES","text":""},{"location":"Minilib.Crypto.AES/#aes","title":"AES","text":"<p>Defined as: <code>type AES = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.Crypto.AES/#field-key_length","title":"field <code>key_length</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Crypto.AES/#field-key","title":"field <code>key</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.AES/#field-w","title":"field <code>w</code>","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.AES/#field-c01","title":"field <code>c01</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.AES/#field-c23","title":"field <code>c23</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.AES/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.AES/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.HMAC.HmacMD5/","title":"Minilib.Crypto.HMAC.HmacMD5","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>An HMAC instance that uses MD5 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacMD5/#values","title":"Values","text":""},{"location":"Minilib.Crypto.HMAC.HmacMD5/#namespace-minilibcryptohmachmacmd5","title":"namespace Minilib.Crypto.HMAC.HmacMD5","text":""},{"location":"Minilib.Crypto.HMAC.HmacMD5/#hmac_md5","title":"hmac_md5","text":"<p>Type: <code>Minilib.Crypto.HMAC::HMAC</code></p> <p>An HMAC instance that uses MD5 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacMD5/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacMD5/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacMD5/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA1/","title":"Minilib.Crypto.HMAC.HmacSHA1","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>An HMAC instance that uses SHA1 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#values","title":"Values","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#namespace-minilibcryptohmachmacsha1","title":"namespace Minilib.Crypto.HMAC.HmacSHA1","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#hmac_sha1","title":"hmac_sha1","text":"<p>Type: <code>Minilib.Crypto.HMAC::HMAC</code></p> <p>An HMAC instance that uses SHA1 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA1/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA256/","title":"Minilib.Crypto.HMAC.HmacSHA256","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>An HMAC instance that uses SHA256 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#values","title":"Values","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#namespace-minilibcryptohmachmacsha256","title":"namespace Minilib.Crypto.HMAC.HmacSHA256","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#hmac_sha256","title":"hmac_sha256","text":"<p>Type: <code>Minilib.Crypto.HMAC::HMAC</code></p> <p>An HMAC instance that uses SHA256 as a hash function.</p>"},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.HMAC.HmacSHA256/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.HMAC/","title":"Minilib.Crypto.HMAC","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>The Keyed-Hash Message Authentication Code (HMAC)</p> <p>Implemented from specification of FIPS 198-1: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.198-1.pdf https://doi.org/10.6028/NIST.FIPS.198-1</p>"},{"location":"Minilib.Crypto.HMAC/#values","title":"Values","text":""},{"location":"Minilib.Crypto.HMAC/#namespace-minilibcryptohmachmac","title":"namespace Minilib.Crypto.HMAC::HMAC","text":""},{"location":"Minilib.Crypto.HMAC/#_hash","title":"_hash","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.HMAC::HMAC -&gt; Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.HMAC/#digest","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Minilib.Crypto.HMAC::HMAC -&gt; Std::Array Std::U8</code></p> <p><code>hmac.digest(key, text)</code> creates a message authentication code from <code>key</code> and <code>text</code>.</p>"},{"location":"Minilib.Crypto.HMAC/#make","title":"make","text":"<p>Type: <code>(Std::Array Std::U8 -&gt; Std::Array Std::U8) -&gt; Std::I64 -&gt; Std::I64 -&gt; Minilib.Crypto.HMAC::HMAC</code></p> <p><code>HMAC::make(h,b,l)</code> creates an HMAC instance. <code>h</code> is a secure hash function, such as MD5::digest or SHA1::digest. <code>b</code> is the input block size of <code>h</code>. <code>l</code> is the output block size of <code>h</code>. <code>l</code> must be less than or equal to <code>b</code>.</p>"},{"location":"Minilib.Crypto.HMAC/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.HMAC/#namespace-minilibcryptohmac","title":"namespace Minilib.Crypto.HMAC","text":""},{"location":"Minilib.Crypto.HMAC/#hmac","title":"HMAC","text":"<p>Defined as: <code>type HMAC = unbox struct { ...fields... }</code></p> <p>A type that generates a message authentication code.</p>"},{"location":"Minilib.Crypto.HMAC/#field-h","title":"field <code>h</code>","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.HMAC/#field-input_block_size","title":"field <code>input_block_size</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Crypto.HMAC/#field-output_block_size","title":"field <code>output_block_size</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Crypto.HMAC/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.HMAC/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.MD5/","title":"Minilib.Crypto.MD5","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>MD5 secure hash function.</p> <p>Implemented from specification of RFC 1321: https://www.rfc-editor.org/rfc/rfc1321.txt</p>"},{"location":"Minilib.Crypto.MD5/#values","title":"Values","text":""},{"location":"Minilib.Crypto.MD5/#namespace-minilibcryptomd5","title":"namespace Minilib.Crypto.MD5","text":""},{"location":"Minilib.Crypto.MD5/#_bit_not","title":"_bit_not","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p> <p>bitwise complement</p>"},{"location":"Minilib.Crypto.MD5/#_f","title":"_f","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>3.4 Step 4. Process Message in 16-Word Blocks</p>"},{"location":"Minilib.Crypto.MD5/#_g","title":"_g","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.MD5/#_h","title":"_h","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.MD5/#_i","title":"_i","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.MD5/#_init_hash","title":"_init_hash","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>3.3 Step 3. Initialize MD Buffer</p>"},{"location":"Minilib.Crypto.MD5/#_rotl","title":"_rotl","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>rotate left</p>"},{"location":"Minilib.Crypto.MD5/#_t","title":"_t","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.MD5/#_update_hash","title":"_update_hash","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>3.4 Step 4. Process Message in 16-Word Blocks</p>"},{"location":"Minilib.Crypto.MD5/#_update_inner","title":"_update_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::U64 -&gt; Minilib.Crypto.MD5::MD5 -&gt; Minilib.Crypto.MD5::MD5</code></p> <p><code>md5._update_inner(input, msglen_inc)</code> updates the message buffer with input. And it increments the message length by <code>msglen_inc</code>. When the message buffer is full (64 bytes), it updates hash with the message and clears the messsage buffer.</p>"},{"location":"Minilib.Crypto.MD5/#digest","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>MD5::digest(bytes)</code> computes MD5 secure hash function of <code>bytes</code>.</p>"},{"location":"Minilib.Crypto.MD5/#empty","title":"empty","text":"<p>Type: <code>Minilib.Crypto.MD5::MD5</code></p> <p>An empty MD5 hasher.</p>"},{"location":"Minilib.Crypto.MD5/#finalize","title":"finalize","text":"<p>Type: <code>Minilib.Crypto.MD5::MD5 -&gt; Std::Array Std::U8</code></p> <p><code>md5.finalize</code> retrieves a final MD5 hash value.</p>"},{"location":"Minilib.Crypto.MD5/#update","title":"update","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.MD5::MD5 -&gt; Minilib.Crypto.MD5::MD5</code></p> <p><code>md5.update(bytes)</code> processes <code>bytes</code>, and updates its internal state.</p>"},{"location":"Minilib.Crypto.MD5/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.MD5/#namespace-minilibcryptomd5_1","title":"namespace Minilib.Crypto.MD5","text":""},{"location":"Minilib.Crypto.MD5/#md5","title":"MD5","text":"<p>Defined as: <code>type MD5 = unbox struct { ...fields... }</code></p> <p>MD5 hasher. Usually it is sufficient to simply call <code>MD5:digest(bytes)</code> without using this structure.</p>"},{"location":"Minilib.Crypto.MD5/#field-hash","title":"field <code>hash</code>","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.MD5/#field-msglen","title":"field <code>msglen</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.MD5/#field-msgbuf","title":"field <code>msgbuf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.MD5/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.MD5/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.SHA1/","title":"Minilib.Crypto.SHA1","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>SHA-1 secure hash function.</p> <p>Implemented from specification of FIPS PUB 180-4: https://csrc.nist.gov/files/pubs/fips/180-4/final/docs/fips180-4.pdf</p> <p>NOTE: FIPS 180-4 (2012) is superseded by FIPS 180-4 (2015), with the only change being made in the Applicability Clause. There are no changes to the technical specifications. FIPS 180-4 (2015): http://dx.doi.org/10.6028/NIST.FIPS.180-4</p>"},{"location":"Minilib.Crypto.SHA1/#values","title":"Values","text":""},{"location":"Minilib.Crypto.SHA1/#namespace-minilibcryptosha1","title":"namespace Minilib.Crypto.SHA1","text":""},{"location":"Minilib.Crypto.SHA1/#_bit_not","title":"_bit_not","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p> <p>2.2.2 Symbols and Operations bitwise complement</p>"},{"location":"Minilib.Crypto.SHA1/#_f","title":"_f","text":"<p>Type: <code>Std::I64 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>4.1.1 SHA-1 Functions</p>"},{"location":"Minilib.Crypto.SHA1/#_init_hash","title":"_init_hash","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>5.3 Setting the Initial Hash Value (H(0)) 5.3.1 SHA-1</p>"},{"location":"Minilib.Crypto.SHA1/#_k","title":"_k","text":"<p>Type: <code>Std::I64 -&gt; Std::U32</code></p> <p>4.2.1 SHA-1 Constants</p>"},{"location":"Minilib.Crypto.SHA1/#_rotl","title":"_rotl","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>rotate left</p>"},{"location":"Minilib.Crypto.SHA1/#_rotr","title":"_rotr","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>rotate right</p>"},{"location":"Minilib.Crypto.SHA1/#_shr","title":"_shr","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>shift right</p>"},{"location":"Minilib.Crypto.SHA1/#_update_hash","title":"_update_hash","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>6.1.2 SHA-1 Hash Computation</p>"},{"location":"Minilib.Crypto.SHA1/#_update_inner","title":"_update_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::U64 -&gt; Minilib.Crypto.SHA1::SHA1 -&gt; Minilib.Crypto.SHA1::SHA1</code></p> <p><code>sha1._update_inner(input, msglen_inc)</code> updates the message buffer with input. And it increments the message length by <code>msglen_inc</code>. When the message buffer is full (64 bytes), it updates hash with the message and clears the messsage buffer.</p>"},{"location":"Minilib.Crypto.SHA1/#digest","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>SHA1::digest(bytes)</code> computes SHA-1 secure hash function of <code>bytes</code>.</p>"},{"location":"Minilib.Crypto.SHA1/#empty","title":"empty","text":"<p>Type: <code>Minilib.Crypto.SHA1::SHA1</code></p> <p>An empty SHA-1 hasher.</p>"},{"location":"Minilib.Crypto.SHA1/#finalize","title":"finalize","text":"<p>Type: <code>Minilib.Crypto.SHA1::SHA1 -&gt; Std::Array Std::U8</code></p> <p><code>sha1.finalize</code> retrieves a final SHA-1 hash value.</p>"},{"location":"Minilib.Crypto.SHA1/#update","title":"update","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.SHA1::SHA1 -&gt; Minilib.Crypto.SHA1::SHA1</code></p> <p><code>sha1.update(bytes)</code> processes <code>bytes</code>, and updates its internal state.</p>"},{"location":"Minilib.Crypto.SHA1/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.SHA1/#namespace-minilibcryptosha1_1","title":"namespace Minilib.Crypto.SHA1","text":""},{"location":"Minilib.Crypto.SHA1/#sha1","title":"SHA1","text":"<p>Defined as: <code>type SHA1 = unbox struct { ...fields... }</code></p> <p>SHA-1 hasher. Usually it is sufficient to simply call <code>SHA1:digest(bytes)</code> without using this structure.</p>"},{"location":"Minilib.Crypto.SHA1/#field-hash","title":"field <code>hash</code>","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA1/#field-msglen","title":"field <code>msglen</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA1/#field-msgbuf","title":"field <code>msgbuf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.SHA1/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.SHA1/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.SHA256/","title":"Minilib.Crypto.SHA256","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>SHA-256 secure hash function.</p> <p>Implemented from specification of FIPS PUB 180-4: https://csrc.nist.gov/files/pubs/fips/180-4/final/docs/fips180-4.pdf</p> <p>NOTE: FIPS 180-4 (2012) is superseded by FIPS 180-4 (2015), with the only change being made in the Applicability Clause. There are no changes to the technical specifications. FIPS 180-4 (2015): http://dx.doi.org/10.6028/NIST.FIPS.180-4</p>"},{"location":"Minilib.Crypto.SHA256/#values","title":"Values","text":""},{"location":"Minilib.Crypto.SHA256/#namespace-minilibcryptosha256","title":"namespace Minilib.Crypto.SHA256","text":""},{"location":"Minilib.Crypto.SHA256/#_bit_not","title":"_bit_not","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p> <p>2.2.2 Symbols and Operations bitwise complement</p>"},{"location":"Minilib.Crypto.SHA256/#_ch","title":"_ch","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>4.1.2 SHA-224 and SHA-256 Functions</p>"},{"location":"Minilib.Crypto.SHA256/#_init_hash","title":"_init_hash","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>5.3 Setting the Initial Hash Value (H(0)) 5.3.3 SHA-256</p>"},{"location":"Minilib.Crypto.SHA256/#_k","title":"_k","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_large_sigma_0","title":"_large_sigma_0","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_large_sigma_1","title":"_large_sigma_1","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_maj","title":"_maj","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_rotl","title":"_rotl","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>rotate left</p>"},{"location":"Minilib.Crypto.SHA256/#_rotr","title":"_rotr","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>rotate right</p>"},{"location":"Minilib.Crypto.SHA256/#_shr","title":"_shr","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>shift right</p>"},{"location":"Minilib.Crypto.SHA256/#_small_sigma_0","title":"_small_sigma_0","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_small_sigma_1","title":"_small_sigma_1","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#_update_hash","title":"_update_hash","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>6.2.2 SHA-256 Hash Computation</p>"},{"location":"Minilib.Crypto.SHA256/#_update_inner","title":"_update_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::U64 -&gt; Minilib.Crypto.SHA256::SHA256 -&gt; Minilib.Crypto.SHA256::SHA256</code></p> <p><code>sha256._update_inner(input, msglen_inc)</code> updates the message buffer with input. And it increments the message length by <code>msglen_inc</code>. When the message buffer is full (64 bytes), it updates hash with the message and clears the messsage buffer.</p>"},{"location":"Minilib.Crypto.SHA256/#digest","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>SHA256::digest(bytes)</code> computes SHA-256 secure hash function of <code>bytes</code>.</p>"},{"location":"Minilib.Crypto.SHA256/#empty","title":"empty","text":"<p>Type: <code>Minilib.Crypto.SHA256::SHA256</code></p> <p>An empty SHA-256 hasher.</p>"},{"location":"Minilib.Crypto.SHA256/#finalize","title":"finalize","text":"<p>Type: <code>Minilib.Crypto.SHA256::SHA256 -&gt; Std::Array Std::U8</code></p> <p><code>sha256.finalize</code> retrieves a final SHA-256 hash value.</p>"},{"location":"Minilib.Crypto.SHA256/#update","title":"update","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.SHA256::SHA256 -&gt; Minilib.Crypto.SHA256::SHA256</code></p> <p><code>sha256.update(bytes)</code> processes <code>bytes</code>, and updates its internal state.</p>"},{"location":"Minilib.Crypto.SHA256/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.SHA256/#namespace-minilibcryptosha256_1","title":"namespace Minilib.Crypto.SHA256","text":""},{"location":"Minilib.Crypto.SHA256/#sha256","title":"SHA256","text":"<p>Defined as: <code>type SHA256 = unbox struct { ...fields... }</code></p> <p>SHA-256 hasher. Usually it is sufficient to simply call <code>SHA256:digest(bytes)</code> without using this structure.</p>"},{"location":"Minilib.Crypto.SHA256/#field-hash","title":"field <code>hash</code>","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Crypto.SHA256/#field-msglen","title":"field <code>msglen</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA256/#field-msgbuf","title":"field <code>msgbuf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.SHA256/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.SHA256/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.SHA512/","title":"Minilib.Crypto.SHA512","text":"<p>Defined in minilib-crypto@0.5.1</p> <p>SHA-512 secure hash function.</p> <p>Implemented from specification of FIPS PUB 180-4: https://csrc.nist.gov/files/pubs/fips/180-4/final/docs/fips180-4.pdf</p> <p>NOTE: FIPS 180-4 (2012) is superseded by FIPS 180-4 (2015), with the only change being made in the Applicability Clause. There are no changes to the technical specifications. FIPS 180-4 (2015): http://dx.doi.org/10.6028/NIST.FIPS.180-4</p>"},{"location":"Minilib.Crypto.SHA512/#values","title":"Values","text":""},{"location":"Minilib.Crypto.SHA512/#namespace-minilibcryptosha512","title":"namespace Minilib.Crypto.SHA512","text":""},{"location":"Minilib.Crypto.SHA512/#_bit_not","title":"_bit_not","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p> <p>2.2.2 Symbols and Operations bitwise complement</p>"},{"location":"Minilib.Crypto.SHA512/#_ch","title":"_ch","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>4.1.3 SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Functions</p>"},{"location":"Minilib.Crypto.SHA512/#_init_hash_sha384","title":"_init_hash_sha384","text":"<p>Type: <code>Std::Array Std::U64</code></p> <p>5.3 Setting the Initial Hash Value (H(0)) 5.3.4 SHA-384</p>"},{"location":"Minilib.Crypto.SHA512/#_init_hash_sha512","title":"_init_hash_sha512","text":"<p>Type: <code>Std::Array Std::U64</code></p> <p>5.3.5 SHA-512</p>"},{"location":"Minilib.Crypto.SHA512/#_k","title":"_k","text":"<p>Type: <code>Std::Array Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_large_sigma_0","title":"_large_sigma_0","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_large_sigma_1","title":"_large_sigma_1","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_maj","title":"_maj","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_rotl","title":"_rotl","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>rotate left</p>"},{"location":"Minilib.Crypto.SHA512/#_rotr","title":"_rotr","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>rotate right</p>"},{"location":"Minilib.Crypto.SHA512/#_shr","title":"_shr","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>shift right</p>"},{"location":"Minilib.Crypto.SHA512/#_small_sigma_0","title":"_small_sigma_0","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_small_sigma_1","title":"_small_sigma_1","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#_update_hash","title":"_update_hash","text":"<p>Type: <code>Std::Array Std::U64 -&gt; Std::Array Std::U64 -&gt; Std::Array Std::U64</code></p> <p>6.2.2 SHA-512 Hash Computation</p>"},{"location":"Minilib.Crypto.SHA512/#_update_inner","title":"_update_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::U64 -&gt; Minilib.Crypto.SHA512::SHA512 -&gt; Minilib.Crypto.SHA512::SHA512</code></p> <p><code>sha512._update_inner(input, msglen_inc)</code> updates the message buffer with input. And it increments the message length by <code>msglen_inc</code>. When the message buffer is full (128 bytes), it updates hash with the message and clears the messsage buffer.</p>"},{"location":"Minilib.Crypto.SHA512/#digest","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>SHA512::digest(bytes)</code> computes SHA-512 secure hash function of <code>bytes</code>.</p>"},{"location":"Minilib.Crypto.SHA512/#empty","title":"empty","text":"<p>Type: <code>Minilib.Crypto.SHA512::SHA512</code></p> <p>An empty SHA-512 hasher.</p>"},{"location":"Minilib.Crypto.SHA512/#finalize","title":"finalize","text":"<p>Type: <code>Minilib.Crypto.SHA512::SHA512 -&gt; Std::Array Std::U8</code></p> <p><code>sha512.finalize</code> retrieves a final SHA-512 hash value.</p>"},{"location":"Minilib.Crypto.SHA512/#update","title":"update","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Crypto.SHA512::SHA512 -&gt; Minilib.Crypto.SHA512::SHA512</code></p> <p><code>sha512.update(bytes)</code> processes <code>bytes</code>, and updates its internal state.</p>"},{"location":"Minilib.Crypto.SHA512/#namespace-minilibcryptosha512sha384","title":"namespace Minilib.Crypto.SHA512::SHA384","text":""},{"location":"Minilib.Crypto.SHA512/#digest_1","title":"digest","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p><code>SHA384::digest(bytes)</code> computes SHA-384 secure hash function of <code>bytes</code>.</p>"},{"location":"Minilib.Crypto.SHA512/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.SHA512/#namespace-minilibcryptosha512_1","title":"namespace Minilib.Crypto.SHA512","text":""},{"location":"Minilib.Crypto.SHA512/#sha512","title":"SHA512","text":"<p>Defined as: <code>type SHA512 = unbox struct { ...fields... }</code></p> <p>SHA-512 hasher. Usually it is sufficient to simply call <code>SHA512:digest(bytes)</code> without using this structure.</p>"},{"location":"Minilib.Crypto.SHA512/#field-hash","title":"field <code>hash</code>","text":"<p>Type: <code>Std::Array Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#field-msglen","title":"field <code>msglen</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Crypto.SHA512/#field-msgbuf","title":"field <code>msgbuf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Crypto.SHA512/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.SHA512/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.SecureRandom/","title":"Minilib.Crypto.SecureRandom","text":"<p>Defined in minilib-random@0.5.2</p> <p>Secure random number generator.</p> <p>Currently only Linux is supported, because it uses <code>/dev/urandom</code> as a secure random source.</p>"},{"location":"Minilib.Crypto.SecureRandom/#values","title":"Values","text":""},{"location":"Minilib.Crypto.SecureRandom/#namespace-minilibcryptosecurerandom","title":"namespace Minilib.Crypto.SecureRandom","text":""},{"location":"Minilib.Crypto.SecureRandom/#generate_u64","title":"generate_U64","text":"<p>Type: <code>Minilib.Crypto.SecureRandom::SecureRandom -&gt; Std::IO::IOFail (Minilib.Crypto.SecureRandom::SecureRandom, Std::U64)</code></p> <p>Generates a random integer of U64.</p>"},{"location":"Minilib.Crypto.SecureRandom/#generate_bytes","title":"generate_bytes","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Crypto.SecureRandom::SecureRandom -&gt; Std::IO::IOFail (Minilib.Crypto.SecureRandom::SecureRandom, Std::Array Std::U8)</code></p> <p>Generates a random byte array with specified size.</p>"},{"location":"Minilib.Crypto.SecureRandom/#make","title":"make","text":"<p>Type: <code>Std::IO::IOFail Minilib.Crypto.SecureRandom::SecureRandom</code></p> <p>Creates a SecureRandom instance.</p>"},{"location":"Minilib.Crypto.SecureRandom/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Crypto.SecureRandom/#namespace-minilibcryptosecurerandom_1","title":"namespace Minilib.Crypto.SecureRandom","text":""},{"location":"Minilib.Crypto.SecureRandom/#securerandom","title":"SecureRandom","text":"<p>Defined as: <code>type SecureRandom = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.Crypto.SecureRandom/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::IO::IOHandle</code></p>"},{"location":"Minilib.Crypto.SecureRandom/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Crypto.SecureRandom/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Crypto.SecureRandom/#impl-minilibcryptosecurerandomsecurerandom-minilibtraitrngrng","title":"impl <code>Minilib.Crypto.SecureRandom::SecureRandom : Minilib.Trait.Rng::Rng</code>","text":""},{"location":"Minilib.Encoding.Base64/","title":"Minilib.Encoding.Base64","text":"<p>Defined in minilib-binary@0.5.1</p> <p>BASE64 encoding and decoding</p>"},{"location":"Minilib.Encoding.Base64/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Base64/#namespace-minilibencodingbase64","title":"namespace Minilib.Encoding.Base64","text":""},{"location":"Minilib.Encoding.Base64/#_b64_to_u8_table","title":"_b64_to_u8_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>[0..63] -&gt; [0..255]</p>"},{"location":"Minilib.Encoding.Base64/#_filter_array","title":"_filter_array","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Same as <code>to_iter &gt;&gt; filter(f) &gt;&gt; to_array</code>, but faster.</p>"},{"location":"Minilib.Encoding.Base64/#_u8_to_b64_table","title":"_u8_to_b64_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>[0..255] -&gt; [0..63], or 0xFF if not a BASE64 char</p>"},{"location":"Minilib.Encoding.Base64/#base64_decode","title":"base64_decode","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::U8</code></p> <p>Decodes a string which contains BASE64 characters to a byte array. Characters other than BASE64 are ignored.</p>"},{"location":"Minilib.Encoding.Base64/#base64_encode","title":"base64_encode","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String</code></p> <p>Encodes a byte array to a BASE64 string.</p>"},{"location":"Minilib.Encoding.Base64/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Base64/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Base64/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Binary/","title":"Minilib.Encoding.Binary","text":"<p>Defined in minilib-binary@0.5.1</p> <p>Binary utility, such as: - Byte order - Byte buffer</p>"},{"location":"Minilib.Encoding.Binary/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinary","title":"namespace Minilib.Encoding.Binary","text":""},{"location":"Minilib.Encoding.Binary/#get_u16_be","title":"get_u16_be","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U16</code></p> <p>Decodes U16 from <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u16_le","title":"get_u16_le","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U16</code></p> <p>Decodes U16 from <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u32_be","title":"get_u32_be","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U32</code></p> <p>Decodes U32 from <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u32_le","title":"get_u32_le","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U32</code></p> <p>Decodes U32 from <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u64_be","title":"get_u64_be","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U64</code></p> <p>Decodes U64 from <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u64_le","title":"get_u64_le","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U64</code></p> <p>Decodes U64 from <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u8_be","title":"get_u8_be","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U8</code></p> <p>Decodes U8 from <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#get_u8_le","title":"get_u8_le","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U8 -&gt; Std::U8</code></p> <p>Decodes U8 from <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u16_be","title":"set_u16_be","text":"<p>Type: <code>Std::I64 -&gt; Std::U16 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U16 into <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u16_le","title":"set_u16_le","text":"<p>Type: <code>Std::I64 -&gt; Std::U16 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U16 into <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u32_be","title":"set_u32_be","text":"<p>Type: <code>Std::I64 -&gt; Std::U32 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U32 into <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u32_le","title":"set_u32_le","text":"<p>Type: <code>Std::I64 -&gt; Std::U32 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U32 into <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u64_be","title":"set_u64_be","text":"<p>Type: <code>Std::I64 -&gt; Std::U64 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U64 into <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u64_le","title":"set_u64_le","text":"<p>Type: <code>Std::I64 -&gt; Std::U64 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U64 into <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u8_be","title":"set_u8_be","text":"<p>Type: <code>Std::I64 -&gt; Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U8 into <code>array</code> at position <code>i</code> with big endian.</p>"},{"location":"Minilib.Encoding.Binary/#set_u8_le","title":"set_u8_le","text":"<p>Type: <code>Std::I64 -&gt; Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encodes U8 into <code>array</code> at position <code>i</code> with little endian.</p>"},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinarybytebuffer","title":"namespace Minilib.Encoding.Binary::ByteBuffer","text":""},{"location":"Minilib.Encoding.Binary/#_marshal","title":"_marshal","text":"<p>Type: <code>(Std::I64 -&gt; a -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer) -&gt; Std::I64 -&gt; a -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>(Internal function for <code>Marshal::marshal</code>)</p>"},{"location":"Minilib.Encoding.Binary/#_unmarshal","title":"_unmarshal","text":"<p>Type: <code>(Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; a) -&gt; Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Result Std::ErrMsg (a, Minilib.Encoding.Binary::ByteBuffer)</code></p> <p>(Internal function for <code>Unmarshal::unmarshal</code>)</p>"},{"location":"Minilib.Encoding.Binary/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteOrder -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p><code>ByteBuffer::empty(capacity, byte_order)</code> creates new byte buffer such that: - The internal byte array is an empty array with capacity <code>capacity</code> - The byte order is <code>byte_order</code></p>"},{"location":"Minilib.Encoding.Binary/#ensure_size","title":"ensure_size","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p><code>buf.ensure_size(req_size)</code> ensures that the size of the byte buffer is at least <code>req_size</code>. If not, appends zeros at the end of the byte buffer.</p>"},{"location":"Minilib.Encoding.Binary/#fill","title":"fill","text":"<p>Type: <code>Std::I64 -&gt; Std::U8 -&gt; Minilib.Encoding.Binary::ByteOrder -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p><code>ByteBuffer::fill(size, value, byte_order)</code> creates new byte buffer such that: - The internal byte array is initialized by size <code>size</code> and filled with <code>value</code> - The byte order is <code>byte_order</code></p>"},{"location":"Minilib.Encoding.Binary/#from_u32_array","title":"from_u32_array","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Minilib.Encoding.Binary::ByteOrder -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p>"},{"location":"Minilib.Encoding.Binary/#get_bytes","title":"get_bytes","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Array Std::U8</code></p> <p>Gets the internal byte array.</p>"},{"location":"Minilib.Encoding.Binary/#get_position","title":"get_position","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::I64</code></p> <p>Gets the read/write position.</p>"},{"location":"Minilib.Encoding.Binary/#get_size","title":"get_size","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::I64</code></p> <p>Gets the size of internal byte array.</p>"},{"location":"Minilib.Encoding.Binary/#get_u16","title":"get_u16","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Std::U16</code></p> <p>Decodes U16 from the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#get_u32","title":"get_u32","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Std::U32</code></p> <p>Decodes U32 from the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#get_u64","title":"get_u64","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Std::U64</code></p> <p>Decodes U64 from the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#get_u8","title":"get_u8","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Std::U8</code></p> <p>Decodes U8 from the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#make","title":"make","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Encoding.Binary::ByteOrder -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p><code>ByteBuffer::make(array, byte_order)</code> creates new byte buffer such that: - The internal byte array is <code>array</code> - The byte order is <code>byte_order</code></p>"},{"location":"Minilib.Encoding.Binary/#set_u16","title":"set_u16","text":"<p>Type: <code>Std::I64 -&gt; Std::U16 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes U16 into the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#set_u32","title":"set_u32","text":"<p>Type: <code>Std::I64 -&gt; Std::U32 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes U32 into the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#set_u64","title":"set_u64","text":"<p>Type: <code>Std::I64 -&gt; Std::U64 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes U64 into the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#set_u8","title":"set_u8","text":"<p>Type: <code>Std::I64 -&gt; Std::U8 -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes U8 into the byte buffer at position <code>i</code>.</p>"},{"location":"Minilib.Encoding.Binary/#to_u32_array","title":"to_u32_array","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Array Std::U32</code></p>"},{"location":"Minilib.Encoding.Binary/#to_u8_array","title":"to_u8_array","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Array Std::U8</code></p>"},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinarymarshal","title":"namespace Minilib.Encoding.Binary::Marshal","text":""},{"location":"Minilib.Encoding.Binary/#marshal","title":"marshal","text":"<p>Type: <code>[a : Minilib.Encoding.Binary::Marshal] a -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes a value to the byte buffer.</p>"},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinaryunmarshal","title":"namespace Minilib.Encoding.Binary::Unmarshal","text":""},{"location":"Minilib.Encoding.Binary/#unmarshal","title":"unmarshal","text":"<p>Type: <code>[a : Minilib.Encoding.Binary::Unmarshal] Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Result Std::ErrMsg (a, Minilib.Encoding.Binary::ByteBuffer)</code></p> <p>Decodes a value from the byte buffer.</p>"},{"location":"Minilib.Encoding.Binary/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinary_1","title":"namespace Minilib.Encoding.Binary","text":""},{"location":"Minilib.Encoding.Binary/#bytebuffer","title":"ByteBuffer","text":"<p>Defined as: <code>type ByteBuffer = unbox struct { ...fields... }</code></p> <p>A type of byte buffer that supports encoding values to/decoding values from memory.</p>"},{"location":"Minilib.Encoding.Binary/#field-array","title":"field <code>array</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>internal byte array</p>"},{"location":"Minilib.Encoding.Binary/#field-byte_order","title":"field <code>byte_order</code>","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteOrder</code></p> <p>byte order</p>"},{"location":"Minilib.Encoding.Binary/#field-position","title":"field <code>position</code>","text":"<p>Type: <code>Std::I64</code></p> <p>read/write position</p>"},{"location":"Minilib.Encoding.Binary/#byteorder","title":"ByteOrder","text":"<p>Defined as: <code>type ByteOrder = unbox union { ...variants... }</code></p> <p>A union type of byte order (endianness). For example, <code>0x12345678_U32</code> is encoded as <code>[0x78_U8, 0x56_U8, 0x34_U8, 0x12_U8]</code> in little endian, <code>[0x12_U8, 0x34_U8, 0x56_U8, 0x78_U8]</code> in big endian.</p>"},{"location":"Minilib.Encoding.Binary/#variant-little_endian","title":"variant <code>little_endian</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Encoding.Binary/#variant-big_endian","title":"variant <code>big_endian</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Encoding.Binary/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Binary/#namespace-minilibencodingbinary_2","title":"namespace Minilib.Encoding.Binary","text":""},{"location":"Minilib.Encoding.Binary/#trait-a-marshal","title":"trait <code>a : Marshal</code>","text":"<p>Trait for a type that supports marshalling (encoding) a value to a byte buffer. For details, see https://en.wikipedia.org/wiki/Marshalling_(computer_science).</p>"},{"location":"Minilib.Encoding.Binary/#method-marshal","title":"method <code>marshal</code>","text":"<p>Type: <code>a -&gt; Minilib.Encoding.Binary::ByteBuffer -&gt; Minilib.Encoding.Binary::ByteBuffer</code></p> <p>Encodes a value to the byte buffer.</p>"},{"location":"Minilib.Encoding.Binary/#trait-a-unmarshal","title":"trait <code>a : Unmarshal</code>","text":"<p>Trait for a type that supports unmarshalling (decoding) a value from a byte buffer. For details, see https://en.wikipedia.org/wiki/Marshalling_(computer_science).</p>"},{"location":"Minilib.Encoding.Binary/#method-unmarshal","title":"method <code>unmarshal</code>","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteBuffer -&gt; Std::Result Std::String (a, Minilib.Encoding.Binary::ByteBuffer)</code></p> <p>Decodes a value from the byte buffer.</p>"},{"location":"Minilib.Encoding.Binary/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu16-minilibencodingbinarymarshal","title":"impl <code>Std::U16 : Minilib.Encoding.Binary::Marshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu16-minilibencodingbinaryunmarshal","title":"impl <code>Std::U16 : Minilib.Encoding.Binary::Unmarshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu32-minilibencodingbinarymarshal","title":"impl <code>Std::U32 : Minilib.Encoding.Binary::Marshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu32-minilibencodingbinaryunmarshal","title":"impl <code>Std::U32 : Minilib.Encoding.Binary::Unmarshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu64-minilibencodingbinarymarshal","title":"impl <code>Std::U64 : Minilib.Encoding.Binary::Marshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu64-minilibencodingbinaryunmarshal","title":"impl <code>Std::U64 : Minilib.Encoding.Binary::Unmarshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu8-minilibencodingbinarymarshal","title":"impl <code>Std::U8 : Minilib.Encoding.Binary::Marshal</code>","text":""},{"location":"Minilib.Encoding.Binary/#impl-stdu8-minilibencodingbinaryunmarshal","title":"impl <code>Std::U8 : Minilib.Encoding.Binary::Unmarshal</code>","text":""},{"location":"Minilib.Encoding.Json.JsonDecoder/","title":"Minilib.Encoding.Json.JsonDecoder","text":"<p>Defined in minilib-json@0.5.1</p> <p>Decodes a JSON value from a string.</p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Json.JsonDecoder/#namespace-minilibencodingjsonjsondecoder","title":"namespace Minilib.Encoding.Json.JsonDecoder","text":""},{"location":"Minilib.Encoding.Json.JsonDecoder/#_doublequote","title":"_DOUBLEQUOTE","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_begin_array","title":"_begin_array","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_begin_object","title":"_begin_object","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_end_array","title":"_end_array","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_end_object","title":"_end_object","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_json_text","title":"_json_text","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Json::Json</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_match_quoted_char_u16","title":"_match_quoted_char_u16","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::U16</code></p> <p>Parse a quoted character. (\"\\n\", \"\\uD83D\" etc.) NOTE: Escape sequences of the form \"\\uXXXX\" can only represent the range U+0000 to U+FFFF. Characters in the range U+10000 to U+10FFFF become surrogate pairs and are split like \"\\uD83D\\uDE38\". Therefore, we first interpret these strings as UTF16. Later convert it to UTF32 and join the surrogate pair, then convert it to UTF8.</p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_match_quoted_str","title":"_match_quoted_str","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_match_str_inner","title":"_match_str_inner","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_match_unquoted_char","title":"_match_unquoted_char","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_match_unquoted_str","title":"_match_unquoted_str","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_name_separator","title":"_name_separator","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_array","title":"_parse_array","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser (Std::Array Minilib.Encoding.Json::Json)</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_bool","title":"_parse_bool","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::Bool</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_null","title":"_parse_null","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_number","title":"_parse_number","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::F64</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_object","title":"_parse_object","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser (Minilib.Collection.OrderedMap::OrderedMap Std::String Minilib.Encoding.Json::Json)</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_string","title":"_parse_string","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_parse_value","title":"_parse_value","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Json::Json</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_unescape_table","title":"_unescape_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_value_separator","title":"_value_separator","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_wrap_whitespaces","title":"_wrap_whitespaces","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#_ws","title":"_ws","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#decode","title":"decode","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Minilib.Encoding.Json::Json</code></p> <p>Parses JSON text and returns a JSON value.</p>"},{"location":"Minilib.Encoding.Json.JsonDecoder/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Json.JsonDecoder/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Json.JsonDecoder/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/","title":"Minilib.Encoding.Json.JsonEncoder","text":"<p>Defined in minilib-json@0.5.1</p> <p>Encodes a JSON value to a string.</p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#namespace-minilibencodingjsonjsonencoder","title":"namespace Minilib.Encoding.Json.JsonEncoder","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#_encode","title":"_encode","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Std::Array Std::String -&gt; Minilib.Encoding.Json::Json -&gt; Std::Array Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_encode_array","title":"_encode_array","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Std::Array Std::String -&gt; Std::Array Minilib.Encoding.Json::Json -&gt; Std::Array Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_encode_number","title":"_encode_number","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Std::F64 -&gt; Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_encode_object","title":"_encode_object","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Std::Array Std::String -&gt; Minilib.Collection.OrderedMap::OrderedMap Std::String Minilib.Encoding.Json::Json -&gt; Std::Array Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_encode_string","title":"_encode_string","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_escape_table","title":"_escape_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#_hex_table","title":"_hex_table","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#encode","title":"encode","text":"<p>Type: <code>Minilib.Encoding.Json::Json -&gt; Std::String</code></p> <p>Encodes JSON and converts it to a string.</p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#encode_pretty","title":"encode_pretty","text":"<p>Type: <code>Minilib.Encoding.Json::Json -&gt; Std::String</code></p> <p>Encodes JSON and converts it to a string. (pretty-printing)</p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#encode_with_param","title":"encode_with_param","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Minilib.Encoding.Json::Json -&gt; Std::String</code></p> <p>Encodes JSON and converts it to a string using the specified parameter.</p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#namespace-minilibencodingjsonjsonencoderencodeparam","title":"namespace Minilib.Encoding.Json.JsonEncoder::EncodeParam","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#default","title":"default","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#increment_indent","title":"increment_indent","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam -&gt; Minilib.Encoding.Json.JsonEncoder::EncodeParam</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#pretty_print","title":"pretty_print","text":"<p>Type: <code>Minilib.Encoding.Json.JsonEncoder::EncodeParam</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#namespace-minilibencodingjsonjsonencoder_1","title":"namespace Minilib.Encoding.Json.JsonEncoder","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#encodeparam","title":"EncodeParam","text":"<p>Defined as: <code>type EncodeParam = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#field-space","title":"field <code>space</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#field-newline","title":"field <code>newline</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#field-indent","title":"field <code>indent</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#field-indent_incr","title":"field <code>indent_incr</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#field-number_prec","title":"field <code>number_prec</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Minilib.Encoding.Json.JsonEncoder/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Json.JsonEncoder/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Json/","title":"Minilib.Encoding.Json","text":"<p>Defined in minilib-json@0.5.1</p> <p>Definition of the structure of a JSON value.</p>"},{"location":"Minilib.Encoding.Json/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Json/#namespace-minilibencodingjson","title":"namespace Minilib.Encoding.Json","text":""},{"location":"Minilib.Encoding.Json/#to_object","title":"to_object","text":"<p>Type: <code>Std::Array (Std::String, Minilib.Encoding.Json::Json) -&gt; Minilib.Encoding.Json::Json</code></p> <p>Converts an array of keys and values to a JSON object.</p>"},{"location":"Minilib.Encoding.Json/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Json/#namespace-minilibencodingjson_1","title":"namespace Minilib.Encoding.Json","text":""},{"location":"Minilib.Encoding.Json/#json","title":"Json","text":"<p>Defined as: <code>type Json = box union { ...variants... }</code></p> <p>A structure representing a JSON value.</p>"},{"location":"Minilib.Encoding.Json/#variant-null","title":"variant <code>null</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Encoding.Json/#variant-bool","title":"variant <code>bool</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.Encoding.Json/#variant-number","title":"variant <code>number</code>","text":"<p>Type: <code>Std::F64</code></p>"},{"location":"Minilib.Encoding.Json/#variant-string","title":"variant <code>string</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Json/#variant-object","title":"variant <code>object</code>","text":"<p>Type: <code>Minilib.Collection.OrderedMap::OrderedMap Std::String Minilib.Encoding.Json::Json</code></p>"},{"location":"Minilib.Encoding.Json/#variant-array","title":"variant <code>array</code>","text":"<p>Type: <code>Std::Array Minilib.Encoding.Json::Json</code></p>"},{"location":"Minilib.Encoding.Json/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Json/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Json/#impl-minilibencodingjsonjson-stdeq","title":"impl <code>Minilib.Encoding.Json::Json : Std::Eq</code>","text":"<p>Checks whether two JSON values are equal.</p>"},{"location":"Minilib.Encoding.Json/#impl-minilibencodingjsonjson-stdtostring","title":"impl <code>Minilib.Encoding.Json::Json : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml.XmlHelpers/","title":"Minilib.Encoding.Xml.XmlHelpers","text":"<p>Defined in minilib-xml@0.5.1</p> <p>XML helpers, such as escaping/unescaping special characters.</p>"},{"location":"Minilib.Encoding.Xml.XmlHelpers/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Xml.XmlHelpers/#namespace-minilibencodingxmlxmlhelpers","title":"namespace Minilib.Encoding.Xml.XmlHelpers","text":""},{"location":"Minilib.Encoding.Xml.XmlHelpers/#_match_char_reference","title":"_match_char_reference","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::I64 -&gt; Std::Option (Std::U32, Std::I64)</code></p>"},{"location":"Minilib.Encoding.Xml.XmlHelpers/#escape_special","title":"escape_special","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Escapes XML special characters. eg. <code>&amp;</code> -&gt; <code>&amp;amp;</code>, <code>&lt;</code> -&gt; <code>&amp;lt;</code>, <code>&gt;</code> -&gt; <code>&amp;gt;</code>, <code>\\\"</code> -&gt; <code>&amp;quot;</code>, <code>'</code> -&gt; <code>&amp;#039;</code></p>"},{"location":"Minilib.Encoding.Xml.XmlHelpers/#unescape_special","title":"unescape_special","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Unescapes XML special characters. eg. <code>&amp;amp;</code> -&gt; <code>&amp;</code>, <code>&amp;lt;</code> -&gt; <code>&lt;</code>, <code>&amp;gt;</code> -&gt; <code>&gt;</code>, <code>&amp;quot;</code> -&gt; <code>\\\"</code>, <code>&amp;#039;</code> -&gt; <code>'</code>. NOTE: Other character references is also converted.</p>"},{"location":"Minilib.Encoding.Xml.XmlHelpers/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Xml.XmlHelpers/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Xml.XmlHelpers/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Xml.XmlParser/","title":"Minilib.Encoding.Xml.XmlParser","text":"<p>Defined in minilib-xml@0.5.1</p> <p>Simple XML 1.1 Parser.</p> <p>Implemented from specification of XML 1.1: - Extensible Markup Language (XML) 1.1 (Second Edition)</p> <p>Known Problems: - Currently only UTF-8 encoding is supported. - Currently Document Type Definition (DTD) is not supported.</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Xml.XmlParser/#namespace-minilibencodingxmlxmlparser","title":"namespace Minilib.Encoding.Xml.XmlParser","text":""},{"location":"Minilib.Encoding.Xml.XmlParser/#_doublequote","title":"_DoubleQuote","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_singlequote","title":"_SingleQuote","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_negative_lookahead","title":"_negative_lookahead","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser ()</code></p> <p>Checks whether it does not match <code>str</code> at current position. Raises <code>_NotMatch</code> if it matches.</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_att_value","title":"_parse_att_value","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[10]    AttValue       ::=      '\"' ([^&lt;&amp;\"] | Reference) '\"'                               |  \"'\" ([^&lt;&amp;'] | Reference) \"'\"</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_attribute","title":"_parse_attribute","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlAttribute</code></p> <p>[41]    Attribute      ::=      Name Eq AttValue</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_cdsect","title":"_parse_cdsect","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p> <p>[18]    CDSect     ::=      CDStart CData CDEnd [19]    CDStart    ::=      '&lt;![CDATA[' [20]    CData      ::=      (Char - (Char ']]&gt;' Char*)) [21]    CDEnd      ::=      ']]&gt;'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_char_data","title":"_parse_char_data","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Character Data [14]    CharData       ::=      [^&lt;&amp;] - ([^&lt;&amp;] ']]&gt;' [^&lt;&amp;]*)</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_char_ref","title":"_parse_char_ref","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>Character Reference [66]    CharRef    ::=      '&amp;#' [0-9]+ ';'                              | '&amp;#x' [0-9a-fA-F]+ ';'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_comment","title":"_parse_comment","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p> <p>[15]    Comment    ::=      ''</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_content","title":"_parse_content","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlElement</code></p> <p>Content of Elements [43]    content    ::=      CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_document","title":"_parse_document","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlDocument</code></p> <p>[1]     document       ::=      ( prolog element Misc ) - ( Char RestrictedChar Char* )</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_element","title":"_parse_element","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlElement</code></p> <p>[39]    element    ::=      EmptyElemTag                              | STag content ETag</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_empty_elem_tag_or_stag","title":"_parse_empty_elem_tag_or_stag","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser (Std::Bool, Minilib.Encoding.Xml::XmlElement)</code></p> <p>[44]    EmptyElemTag       ::=      '&lt;' Name (S Attribute) S? '/&gt;' [40]    STag       ::=      '&lt;' Name (S Attribute) S? '&gt;'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_enc_name","title":"_parse_enc_name","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[81]    EncName    ::=      [A-Za-z] ([A-Za-z0-9._] | '-')*</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_encoding_decl","title":"_parse_encoding_decl","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[80]    EncodingDecl       ::=      S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_entity_ref","title":"_parse_entity_ref","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>[68]    EntityRef      ::=      '&amp;' Name ';'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_eq","title":"_parse_eq","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>[25]    Eq     ::=      S? '=' S?</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_etag","title":"_parse_etag","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlElement</code></p> <p>[42]    ETag       ::=      '&lt;/' Name S? '&gt;'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_misc","title":"_parse_misc","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p> <p>[27]    Misc       ::=      Comment | PI | S</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_name","title":"_parse_name","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[5]     Name       ::=      NameStartChar (NameChar)*</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_name_char","title":"_parse_name_char","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Char</code></p> <p>[4a]    NameChar       ::=      NameStartChar | \"-\" | \".\" | [0-9] |                                   #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_name_start_char","title":"_parse_name_start_char","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Char</code></p> <p>[4]     NameStartChar      ::=      \":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] |              [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] |              [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |              [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_pi","title":"_parse_pi","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p> <p>[16]    PI     ::=      '&lt;?' PITarget (S (Char - (Char '?&gt;' Char*)))? '?&gt;' [17]    PITarget       ::=      Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_prolog","title":"_parse_prolog","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlDocument</code></p> <p>[22]    prolog     ::=      XMLDecl Misc (doctypedecl Misc)?</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_reference","title":"_parse_reference","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>Entity Reference [67]    Reference      ::=      EntityRef | CharRef</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_reference_as_text_node","title":"_parse_reference_as_text_node","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_s","title":"_parse_s","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>White Space [3]     S      ::=      (#x20 | #x9 | #xD | #xA)+</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_s_as_text_node","title":"_parse_s_as_text_node","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlNode</code></p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_sd_decl","title":"_parse_sd_decl","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[32]    SDDecl     ::=      S 'standalone' Eq ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_version_info","title":"_parse_version_info","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>[24]    VersionInfo    ::=      S 'version' Eq (\"'\" VersionNum \"'\" | '\"' VersionNum '\"')</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_parse_xml_declaration","title":"_parse_xml_declaration","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Encoding.Xml::XmlDeclaration</code></p> <p>[23]    XMLDecl    ::=      '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?&gt;'</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#_whitespace","title":"_whitespace","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Char</code></p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#parse_document_from_string","title":"parse_document_from_string","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Minilib.Encoding.Xml::XmlDocument</code></p> <p>Reads an XML document from a string.</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#parse_element_from_string","title":"parse_element_from_string","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Minilib.Encoding.Xml::XmlElement</code></p> <p>Reads an XML element from a string.</p>"},{"location":"Minilib.Encoding.Xml.XmlParser/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Xml.XmlParser/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Xml.XmlParser/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Xml/","title":"Minilib.Encoding.Xml","text":"<p>Defined in minilib-xml@0.5.1</p> <p>Simple XML Model.</p> <p>This module is intended to support Extensible Markup Language (XML) 1.1 (Second Edition), but it is not fully supported at this time.</p> <p>This module is not intended to support DOM API.</p> <p>This module does not support XML namespace (xmlns).</p>"},{"location":"Minilib.Encoding.Xml/#values","title":"Values","text":""},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxml","title":"namespace Minilib.Encoding.Xml","text":""},{"location":"Minilib.Encoding.Xml/#escape_special","title":"escape_special","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Escapes XML special characters. eg. <code>&amp;</code> -&gt; <code>&amp;amp;</code>, <code>&lt;</code> -&gt; <code>&amp;lt;</code>, <code>&gt;</code> -&gt; <code>&amp;gt;</code>, <code>\\\"</code> -&gt; <code>&amp;quot;</code>, <code>'</code> -&gt; <code>&amp;#039;</code></p>"},{"location":"Minilib.Encoding.Xml/#unescape_special","title":"unescape_special","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Unescapes XML special characters. eg. <code>&amp;amp;</code> -&gt; <code>&amp;</code>, <code>&amp;lt;</code> -&gt; <code>&lt;</code>, <code>&amp;gt;</code> -&gt; <code>&gt;</code>, <code>&amp;quot;</code> -&gt; <code>\\\"</code>, <code>&amp;#039;</code> -&gt; <code>'</code>. NOTE: Other character references is also converted.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmlattribute","title":"namespace Minilib.Encoding.Xml::XmlAttribute","text":""},{"location":"Minilib.Encoding.Xml/#_sort_by_name","title":"_sort_by_name","text":"<p>Type: <code>Std::Array Minilib.Encoding.Xml::XmlAttribute -&gt; Std::Array Minilib.Encoding.Xml::XmlAttribute</code></p> <p><code>attributes._sort_by_name</code> sorts an array of attributes by the name.</p>"},{"location":"Minilib.Encoding.Xml/#make","title":"make","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Encoding.Xml::XmlAttribute</code></p> <p><code>XmlAttribute::make(name, value)</code> creates an attribute with the specified name and value.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmlcdatasection","title":"namespace Minilib.Encoding.Xml::XmlCDATASection","text":""},{"location":"Minilib.Encoding.Xml/#make_1","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlCDATASection</code></p> <p><code>XmlCDATASection::make(content)</code> creates a CDATA section with the specified content. If <code>content</code> contains the end marker of CDATA section(<code>\"]]&gt;\"</code>), this function panics.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmlcomment","title":"namespace Minilib.Encoding.Xml::XmlComment","text":""},{"location":"Minilib.Encoding.Xml/#make_2","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlComment</code></p> <p><code>XmlComment::make(content)</code> creates a comment node with the specified content. If <code>content</code> contains a double-hyphen(<code>\"--\"</code>), this function panics.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmldeclaration","title":"namespace Minilib.Encoding.Xml::XmlDeclaration","text":""},{"location":"Minilib.Encoding.Xml/#default","title":"default","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlDeclaration</code></p> <p>A default XML declaration with version=\"1.1\", encoding=\"utf-8\".</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmldocument","title":"namespace Minilib.Encoding.Xml::XmlDocument","text":""},{"location":"Minilib.Encoding.Xml/#add_to_epilog","title":"add_to_epilog","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlNode -&gt; Minilib.Encoding.Xml::XmlDocument -&gt; Minilib.Encoding.Xml::XmlDocument</code></p> <p>Adds a child node to the epilog of the document.</p>"},{"location":"Minilib.Encoding.Xml/#add_to_prolog","title":"add_to_prolog","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlNode -&gt; Minilib.Encoding.Xml::XmlDocument -&gt; Minilib.Encoding.Xml::XmlDocument</code></p> <p>Adds a child node to the prolog of the document.</p>"},{"location":"Minilib.Encoding.Xml/#empty","title":"empty","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlDocument</code></p> <p>An empty XML document.</p>"},{"location":"Minilib.Encoding.Xml/#make_3","title":"make","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlDocument</code></p> <p>Creates a XML document with the specified document element.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmlelement","title":"namespace Minilib.Encoding.Xml::XmlElement","text":""},{"location":"Minilib.Encoding.Xml/#add","title":"add","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>parent.add(child)</code> adds a child element to <code>parent</code>.</p>"},{"location":"Minilib.Encoding.Xml/#addf","title":"addF","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>parent.addF $ child</code> adds a child element to <code>parent</code>. This is a flipped version of <code>add</code>.</p>"},{"location":"Minilib.Encoding.Xml/#add_node","title":"add_node","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlNode -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>add_node</code> is synonym for <code>append_child</code>.</p>"},{"location":"Minilib.Encoding.Xml/#append_child","title":"append_child","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlNode -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>parent.append_child(child_node)</code> adds a child node to <code>parent</code>.</p>"},{"location":"Minilib.Encoding.Xml/#attr","title":"attr","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>attr</code> is synonym for <code>set_attribute</code>.</p>"},{"location":"Minilib.Encoding.Xml/#concat_text_nodes","title":"concat_text_nodes","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.concat_text_nodes</code> concats adjuscent text nodes.</p>"},{"location":"Minilib.Encoding.Xml/#element","title":"element","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p>Synonym for <code>XmlElement::make</code>.</p>"},{"location":"Minilib.Encoding.Xml/#get_attribute","title":"get_attribute","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Std::Option Std::String</code></p> <p><code>element.get_attribute(name)</code> gets the value of a specified attribute on the element.</p>"},{"location":"Minilib.Encoding.Xml/#make_4","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>XmlElement::make(tag_name)</code> creates an empty element with the specified tag name.</p>"},{"location":"Minilib.Encoding.Xml/#remove_attribute","title":"remove_attribute","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.remove_attribute(name)</code> removes the attribute with the specified name from the element. If the specified attribute does not exist, this function does nothing.</p>"},{"location":"Minilib.Encoding.Xml/#set_attribute","title":"set_attribute","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.set_attribute(name,value)</code> sets the value of an attribute on the element. If an attribute of same name exists, it will be replaced. NOTE: validity of attribute names are not checked.</p>"},{"location":"Minilib.Encoding.Xml/#text","title":"text","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.text(content)</code> adds a text node to <code>element</code>.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmlprocessinginstruction","title":"namespace Minilib.Encoding.Xml::XmlProcessingInstruction","text":""},{"location":"Minilib.Encoding.Xml/#make_5","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlProcessingInstruction</code></p> <p><code>XmlProcessingInstruction::make(content)</code> creates a processing instruction with the specified content.</p>"},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxmlxmltext","title":"namespace Minilib.Encoding.Xml::XmlText","text":""},{"location":"Minilib.Encoding.Xml/#make_6","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlText</code></p> <p><code>XmlText::make(content)</code> creates a text node with the specified content.</p>"},{"location":"Minilib.Encoding.Xml/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Encoding.Xml/#namespace-minilibencodingxml_1","title":"namespace Minilib.Encoding.Xml","text":""},{"location":"Minilib.Encoding.Xml/#xmlattribute","title":"XmlAttribute","text":"<p>Defined as: <code>type XmlAttribute = unbox struct { ...fields... }</code></p> <p>A type that represents name and value of an attribute.</p>"},{"location":"Minilib.Encoding.Xml/#field-name","title":"field <code>name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#xmlcdatasection","title":"XmlCDATASection","text":"<p>Defined as: <code>type XmlCDATASection = unbox struct { ...fields... }</code></p> <p>A type that represents a CDATA section.</p>"},{"location":"Minilib.Encoding.Xml/#field-content","title":"field <code>content</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#xmlcomment","title":"XmlComment","text":"<p>Defined as: <code>type XmlComment = unbox struct { ...fields... }</code></p> <p>A type that represents a comment node.</p>"},{"location":"Minilib.Encoding.Xml/#field-content_1","title":"field <code>content</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#xmldeclaration","title":"XmlDeclaration","text":"<p>Defined as: <code>type XmlDeclaration = unbox struct { ...fields... }</code></p> <p>A type that represents an XML declaration.</p>"},{"location":"Minilib.Encoding.Xml/#field-version","title":"field <code>version</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#field-encoding","title":"field <code>encoding</code>","text":"<p>Type: <code>Std::Option Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#field-standalone","title":"field <code>standalone</code>","text":"<p>Type: <code>Std::Option Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#xmldocument","title":"XmlDocument","text":"<p>Defined as: <code>type XmlDocument = box struct { ...fields... }</code></p> <p>A type that represents an XML document.</p>"},{"location":"Minilib.Encoding.Xml/#field-xml_decl","title":"field <code>xml_decl</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlDeclaration</code></p>"},{"location":"Minilib.Encoding.Xml/#field-prolog","title":"field <code>prolog</code>","text":"<p>Type: <code>Std::Array Minilib.Encoding.Xml::XmlNode</code></p>"},{"location":"Minilib.Encoding.Xml/#field-document_element","title":"field <code>document_element</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement</code></p>"},{"location":"Minilib.Encoding.Xml/#field-epilog","title":"field <code>epilog</code>","text":"<p>Type: <code>Std::Array Minilib.Encoding.Xml::XmlNode</code></p>"},{"location":"Minilib.Encoding.Xml/#xmlelement","title":"XmlElement","text":"<p>Defined as: <code>type XmlElement = unbox struct { ...fields... }</code></p> <p>A type that represents an XML element.</p>"},{"location":"Minilib.Encoding.Xml/#field-tag_name","title":"field <code>tag_name</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#field-attributes","title":"field <code>attributes</code>","text":"<p>Type: <code>Std::Array Minilib.Encoding.Xml::XmlAttribute</code></p>"},{"location":"Minilib.Encoding.Xml/#field-children","title":"field <code>children</code>","text":"<p>Type: <code>Std::Array Minilib.Encoding.Xml::XmlNode</code></p>"},{"location":"Minilib.Encoding.Xml/#xmlnode","title":"XmlNode","text":"<p>Defined as: <code>type XmlNode = box union { ...variants... }</code></p> <p>A type that represents an XML node. cf. DOM: 4.4. Interface Node</p>"},{"location":"Minilib.Encoding.Xml/#variant-element_node","title":"variant <code>element_node</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-attribute_node","title":"variant <code>attribute_node</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlAttribute</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-text_node","title":"variant <code>text_node</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlText</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-cdata_section","title":"variant <code>cdata_section</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlCDATASection</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-processing_instruction","title":"variant <code>processing_instruction</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlProcessingInstruction</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-comment_node","title":"variant <code>comment_node</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlComment</code></p>"},{"location":"Minilib.Encoding.Xml/#variant-document_node","title":"variant <code>document_node</code>","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlDocument</code></p>"},{"location":"Minilib.Encoding.Xml/#xmlprocessinginstruction","title":"XmlProcessingInstruction","text":"<p>Defined as: <code>type XmlProcessingInstruction = unbox struct { ...fields... }</code></p> <p>A type that represents a processing instruction.</p>"},{"location":"Minilib.Encoding.Xml/#field-content_2","title":"field <code>content</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#xmltext","title":"XmlText","text":"<p>Defined as: <code>type XmlText = unbox struct { ...fields... }</code></p> <p>A type that represents a text node.</p>"},{"location":"Minilib.Encoding.Xml/#field-content_3","title":"field <code>content</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Encoding.Xml/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Encoding.Xml/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlattribute-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlAttribute : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlattribute-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlAttribute : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlcdatasection-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlCDATASection : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlcdatasection-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlCDATASection : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlcomment-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlComment : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlcomment-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlComment : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmldeclaration-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlDeclaration : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmldeclaration-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlDeclaration : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmldocument-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlDocument : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmldocument-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlDocument : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlelement-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlElement : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlelement-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlElement : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlnode-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlNode : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlnode-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlNode : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlprocessinginstruction-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlProcessingInstruction : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmlprocessinginstruction-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlProcessingInstruction : Std::ToString</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmltext-stdadd","title":"impl <code>Minilib.Encoding.Xml::XmlText : Std::Add</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmltext-stdeq","title":"impl <code>Minilib.Encoding.Xml::XmlText : Std::Eq</code>","text":""},{"location":"Minilib.Encoding.Xml/#impl-minilibencodingxmlxmltext-stdtostring","title":"impl <code>Minilib.Encoding.Xml::XmlText : Std::ToString</code>","text":""},{"location":"Minilib.Functor.Pair/","title":"Minilib.Functor.Pair","text":"<p>Defined in minilib-monad@0.5.1</p>"},{"location":"Minilib.Functor.Pair/#values","title":"Values","text":""},{"location":"Minilib.Functor.Pair/#namespace-minilibfunctorpairpairl","title":"namespace Minilib.Functor.Pair::PairL","text":""},{"location":"Minilib.Functor.Pair/#get","title":"get","text":"<p>Type: <code>Minilib.Functor.Pair::PairL r l -&gt; (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#make","title":"make","text":"<p>Type: <code>(l, r) -&gt; Minilib.Functor.Pair::PairL r l</code></p>"},{"location":"Minilib.Functor.Pair/#namespace-minilibfunctorpairpairlt","title":"namespace Minilib.Functor.Pair::PairLT","text":""},{"location":"Minilib.Functor.Pair/#get_1","title":"get","text":"<p>Type: <code>Minilib.Functor.Pair::PairLT r f l -&gt; f (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#make_1","title":"make","text":"<p>Type: <code>f (l, r) -&gt; Minilib.Functor.Pair::PairLT r f l</code></p>"},{"location":"Minilib.Functor.Pair/#namespace-minilibfunctorpairpairr","title":"namespace Minilib.Functor.Pair::PairR","text":""},{"location":"Minilib.Functor.Pair/#get_2","title":"get","text":"<p>Type: <code>Minilib.Functor.Pair::PairR l r -&gt; (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#make_2","title":"make","text":"<p>Type: <code>(l, r) -&gt; Minilib.Functor.Pair::PairR l r</code></p>"},{"location":"Minilib.Functor.Pair/#namespace-minilibfunctorpairpairrt","title":"namespace Minilib.Functor.Pair::PairRT","text":""},{"location":"Minilib.Functor.Pair/#get_3","title":"get","text":"<p>Type: <code>Minilib.Functor.Pair::PairRT l f r -&gt; f (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#make_3","title":"make","text":"<p>Type: <code>f (l, r) -&gt; Minilib.Functor.Pair::PairRT l f r</code></p>"},{"location":"Minilib.Functor.Pair/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Functor.Pair/#namespace-minilibfunctorpair","title":"namespace Minilib.Functor.Pair","text":""},{"location":"Minilib.Functor.Pair/#pairl","title":"PairL","text":"<p>Defined as: <code>type PairL r l = unbox struct { ...fields... }</code></p> <p>A functor on the left component. This is a swapped version of <code>Tuple2</code>.</p>"},{"location":"Minilib.Functor.Pair/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>(l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#pairlt","title":"PairLT","text":"<p>Defined as: <code>type [f : *-&gt;*] PairLT r f l = unbox struct { ...fields... }</code></p> <p>A functor on the left component with an underlying functor.</p>"},{"location":"Minilib.Functor.Pair/#field-data_1","title":"field <code>data</code>","text":"<p>Type: <code>f (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#pairr","title":"PairR","text":"<p>Defined as: <code>type PairR l r = unbox struct { ...fields... }</code></p> <p>A functor on the right component. This is same as <code>Tuple2</code>.</p>"},{"location":"Minilib.Functor.Pair/#field-data_2","title":"field <code>data</code>","text":"<p>Type: <code>(l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#pairrt","title":"PairRT","text":"<p>Defined as: <code>type [f : *-&gt;*] PairRT l f r = unbox struct { ...fields... }</code></p> <p>A functor on the right component with an underlying functor.</p>"},{"location":"Minilib.Functor.Pair/#field-data_3","title":"field <code>data</code>","text":"<p>Type: <code>f (l, r)</code></p>"},{"location":"Minilib.Functor.Pair/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Functor.Pair/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Functor.Pair/#impl-minilibfunctorpairpairl-r-stdfunctor","title":"impl <code>Minilib.Functor.Pair::PairL r : Std::Functor</code>","text":""},{"location":"Minilib.Functor.Pair/#impl-f-stdfunctor-minilibfunctorpairpairlt-r-f-stdfunctor","title":"impl <code>[f : Std::Functor] Minilib.Functor.Pair::PairLT r f : Std::Functor</code>","text":""},{"location":"Minilib.Functor.Pair/#impl-minilibfunctorpairpairr-l-stdfunctor","title":"impl <code>Minilib.Functor.Pair::PairR l : Std::Functor</code>","text":""},{"location":"Minilib.Functor.Pair/#impl-f-stdfunctor-minilibfunctorpairpairrt-l-f-stdfunctor","title":"impl <code>[f : Std::Functor] Minilib.Functor.Pair::PairRT l f : Std::Functor</code>","text":""},{"location":"Minilib.IO.Errno/","title":"Minilib.IO.Errno","text":"<p>Defined in minilib-io@0.5.1</p> <p>Functions for <code>errno</code> which is set by system calls and some library functions.</p>"},{"location":"Minilib.IO.Errno/#values","title":"Values","text":""},{"location":"Minilib.IO.Errno/#namespace-minilibioerrno","title":"namespace Minilib.IO.Errno","text":""},{"location":"Minilib.IO.Errno/#get_last_error","title":"get_last_error","text":"<p>Type: <code>Std::IO Std::String</code></p> <p>Gets the error message corresponding to the last error number.</p>"},{"location":"Minilib.IO.Errno/#strerror","title":"strerror","text":"<p>Type: <code>Std::I32 -&gt; Std::IO Std::String</code></p> <p>Converts the error number returned by <code>get_errno</code> to a string. This function may have race conditions, but is more portable.</p>"},{"location":"Minilib.IO.Errno/#strerror_r","title":"strerror_r","text":"<p>Type: <code>Std::I32 -&gt; Std::IO Std::String</code></p> <p>Converts the error number returned by <code>get_errno</code> to a string. This function has no race conditions, but is less portable.  (This function is GNU C library specific)</p>"},{"location":"Minilib.IO.Errno/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.IO.Errno/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.IO.Errno/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.IO.FileSystem/","title":"Minilib.IO.FileSystem","text":"<p>Defined in minilib-io@0.5.1</p> <p>File system module. For example, finding files, checks if file or directory exists, getting file size and last modified time.</p>"},{"location":"Minilib.IO.FileSystem/#values","title":"Values","text":""},{"location":"Minilib.IO.FileSystem/#namespace-minilibiofilesystem","title":"namespace Minilib.IO.FileSystem","text":""},{"location":"Minilib.IO.FileSystem/#_opendir","title":"_opendir","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.IO.FileSystem::DirHandle</code></p>"},{"location":"Minilib.IO.FileSystem/#_readdir","title":"_readdir","text":"<p>Type: <code>Minilib.IO.FileSystem::DirHandle -&gt; Std::IO::IOFail Std::String</code></p>"},{"location":"Minilib.IO.FileSystem/#creat","title":"creat","text":"<p>Type: <code>Std::String -&gt; Std::U32 -&gt; Std::IO::IOFail Std::I32</code></p> <p>Creates a new file or rewrites an existing one. For details, see Linux manual page for creat().</p>"},{"location":"Minilib.IO.FileSystem/#directory_exists","title":"directory_exists","text":"<p>Type: <code>Std::String -&gt; Std::IO Std::Bool</code></p> <p>Returns true if the specified directory exists.</p>"},{"location":"Minilib.IO.FileSystem/#fdopen","title":"fdopen","text":"<p>Type: <code>Std::I32 -&gt; Std::String -&gt; Std::IO::IOFail Std::IO::IOHandle</code></p> <p>Associates a stream with a file descriptor. For details, see Linux manual page for fdopen().</p>"},{"location":"Minilib.IO.FileSystem/#fflush","title":"fflush","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail ()</code></p> <p>Flushes a file stream. For details, see Linux manual page for fflush().</p>"},{"location":"Minilib.IO.FileSystem/#file_exists","title":"file_exists","text":"<p>Type: <code>Std::String -&gt; Std::IO Std::Bool</code></p> <p>Returns true if the specified file exists.</p>"},{"location":"Minilib.IO.FileSystem/#find_files","title":"find_files","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail (Std::Array Std::String)</code></p> <p><code>find_files(dir_path)</code> finds all files under specified directory and its subdirectories.</p>"},{"location":"Minilib.IO.FileSystem/#list_dir","title":"list_dir","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail (Std::Array Std::String)</code></p> <p>Lists a directory. Returns filenames in the specified directory. The filenames will be sorted in lexicographical order.</p>"},{"location":"Minilib.IO.FileSystem/#make_dirs","title":"make_dirs","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U32 -&gt; Std::IO::IOFail ()</code></p> <p><code>make_dirs(dir_path, mode)</code> creates specified directory as well as its parent directories recursively. If the directory already exists, it does nothing. If <code>mode</code> is <code>none()</code>, octal 0777 is used as a mode. This mode is modified by the process's umask in the usual way.</p>"},{"location":"Minilib.IO.FileSystem/#mkdir","title":"mkdir","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U32 -&gt; Std::IO::IOFail ()</code></p> <p><code>mkdir(path, mode)</code> creates a directory. If <code>mode</code> is <code>none()</code>, octal 0777 is used as a mode. This mode is modified by the process's umask in the usual way.</p>"},{"location":"Minilib.IO.FileSystem/#open_pipe","title":"open_pipe","text":"<p>Type: <code>Std::IO::IOFail (Std::IO::IOHandle, Std::IO::IOHandle)</code></p> <p>Creates a pipe stream. It returns <code>(read_fh, write_fh)</code> where <code>read_fd</code> is the stream of read-end of the pipe, and <code>write_fd</code> is the stream of write-end of the pipe. For details, see Linux manual page for pipe().</p>"},{"location":"Minilib.IO.FileSystem/#pipe","title":"pipe","text":"<p>Type: <code>Std::IO::IOFail (Std::I32, Std::I32)</code></p> <p>Creates a pipe. It returns <code>(read_fd, write_fd)</code> where <code>read_fd</code> is the file descriptor of read-end of the pipe, and <code>write_fd</code> is the file descriptor of write-end of the pipe. For details, see Linux manual page for pipe().</p>"},{"location":"Minilib.IO.FileSystem/#realpath","title":"realpath","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Std::String</code></p> <p>Returns the canonicalized absolute pathname. For detials, see Linux manual page for realpath().</p>"},{"location":"Minilib.IO.FileSystem/#rmdir","title":"rmdir","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail ()</code></p> <p><code>rmdir(path)</code> deletes a directory, which must be empty.</p>"},{"location":"Minilib.IO.FileSystem/#set_unbuffered_mode","title":"set_unbuffered_mode","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO ()</code></p> <p>Sets IOHandle to unbuffered mode. For detials, see Linux manual page for setbuf(). NOTE: When a fix program is invoked by <code>run_with_stream()</code>,       then the stdout and stderr becomes not a TTY but a file stream.       So the stdout becomes block-buffered. The stderr also seems to be block-buffered.</p>"},{"location":"Minilib.IO.FileSystem/#unlink","title":"unlink","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail ()</code></p> <p>Deletes a name from the filesystem and possibly the file it refers to. For details, see Linux manual page for unlink().</p>"},{"location":"Minilib.IO.FileSystem/#namespace-minilibiofilesystemfilestat","title":"namespace Minilib.IO.FileSystem::FileStat","text":""},{"location":"Minilib.IO.FileSystem/#is_dir","title":"is_dir","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::Bool</code></p> <p>Returns true if it is a directory.</p>"},{"location":"Minilib.IO.FileSystem/#is_file","title":"is_file","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::Bool</code></p> <p>Returns true if it is a regular file.</p>"},{"location":"Minilib.IO.FileSystem/#st_atim","title":"st_atim","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Time::Time</code></p>"},{"location":"Minilib.IO.FileSystem/#st_atime","title":"st_atime","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_blksize","title":"st_blksize","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::I64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_blocks","title":"st_blocks","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_ctim","title":"st_ctim","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Time::Time</code></p>"},{"location":"Minilib.IO.FileSystem/#st_ctime","title":"st_ctime","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_dev","title":"st_dev","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_gid","title":"st_gid","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U32</code></p>"},{"location":"Minilib.IO.FileSystem/#st_ino","title":"st_ino","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_mode","title":"st_mode","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U32</code></p>"},{"location":"Minilib.IO.FileSystem/#st_mtim","title":"st_mtim","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Time::Time</code></p>"},{"location":"Minilib.IO.FileSystem/#st_mtime","title":"st_mtime","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_nlink","title":"st_nlink","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_rdev","title":"st_rdev","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_size","title":"st_size","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::I64</code></p>"},{"location":"Minilib.IO.FileSystem/#st_uid","title":"st_uid","text":"<p>Type: <code>Minilib.IO.FileSystem::FileStat -&gt; Std::U32</code></p>"},{"location":"Minilib.IO.FileSystem/#stat","title":"stat","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.IO.FileSystem::FileStat</code></p> <p><code>stat(file_path)</code> retrieves information about the file pointed to by <code>file_path</code>.</p>"},{"location":"Minilib.IO.FileSystem/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.IO.FileSystem/#namespace-minilibiofilesystem_1","title":"namespace Minilib.IO.FileSystem","text":""},{"location":"Minilib.IO.FileSystem/#dirhandle","title":"DirHandle","text":"<p>Defined as: <code>type DirHandle = unbox struct { ...fields... }</code></p> <p>[nofixdoc] Type of a directory handle</p>"},{"location":"Minilib.IO.FileSystem/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::Ptr</code></p>"},{"location":"Minilib.IO.FileSystem/#filestat","title":"FileStat","text":"<p>Defined as: <code>type FileStat = unbox struct { ...fields... }</code></p> <p>Type of file status</p>"},{"location":"Minilib.IO.FileSystem/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::Array Std::U64</code></p>"},{"location":"Minilib.IO.FileSystem/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.IO.FileSystem/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.IO.Path/","title":"Minilib.IO.Path","text":"<p>Defined in minilib-io@0.5.1</p> <p>File Path handling, such as joining paths and retrieving directory name.</p>"},{"location":"Minilib.IO.Path/#values","title":"Values","text":""},{"location":"Minilib.IO.Path/#namespace-minilibiopath","title":"namespace Minilib.IO.Path","text":""},{"location":"Minilib.IO.Path/#basename","title":"basename","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p><code>basename(path)</code> returns the last non-slash component. The trailing slashes are removed.</p>"},{"location":"Minilib.IO.Path/#dirname","title":"dirname","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p><code>dirname(path)</code> returns the path with its last non-slash component and trailing slashes removed. if <code>path</code> contains no <code>/</code>s, returns <code>\".\"</code>.</p>"},{"location":"Minilib.IO.Path/#is_path_sep","title":"is_path_sep","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p> <p>Checks if the byte is a path separator. Currently only '/' is supported.</p>"},{"location":"Minilib.IO.Path/#join_paths","title":"join_paths","text":"<p>Type: <code>Std::Array Std::String -&gt; Std::String</code></p> <p><code>join_paths(path_segments)</code> joins segments into a path.</p>"},{"location":"Minilib.IO.Path/#relativize","title":"relativize","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p><code>base.relativize(target)</code> constructs a relative path from <code>base</code> to <code>target</code>. <code>base</code> and <code>target</code> should have the same type (i.e. relative path or absolute path). If only one of <code>base</code> and <code>target</code> is an absolute path, \"different type of path\" error is returned. If <code>base</code> == <code>target</code>, then an empty string is returned.</p>"},{"location":"Minilib.IO.Path/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.IO.Path/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.IO.Path/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.IO.Platform/","title":"Minilib.IO.Platform","text":"<p>Defined in minilib-io@0.5.1</p> <p>Get kernel information such as system name, machine archtecture.</p>"},{"location":"Minilib.IO.Platform/#values","title":"Values","text":""},{"location":"Minilib.IO.Platform/#namespace-minilibioplatform","title":"namespace Minilib.IO.Platform","text":""},{"location":"Minilib.IO.Platform/#byte_order","title":"byte_order","text":"<p>Type: <code>Minilib.Encoding.Binary::ByteOrder</code></p> <p>The byte order of platform.</p>"},{"location":"Minilib.IO.Platform/#get_uname","title":"get_uname","text":"<p>Type: <code>Std::IO::IOFail Minilib.IO.Platform::UName</code></p> <p>Gets the name and information of current kernel. It calls POSIX C function <code>uname()</code>.</p>"},{"location":"Minilib.IO.Platform/#uname","title":"uname","text":"<p>Type: <code>Minilib.IO.Platform::UName</code></p> <p>NOTE: <code>uname</code> is deprecated. Please use <code>get_uname</code>.</p> <p>The name and information of current kernel. Calls POSIX C function <code>uname()</code>, and split the result by null characters. NOTE: The system information does not change during program execution, so this variable is constant.</p>"},{"location":"Minilib.IO.Platform/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.IO.Platform/#namespace-minilibioplatform_1","title":"namespace Minilib.IO.Platform","text":""},{"location":"Minilib.IO.Platform/#uname_1","title":"UName","text":"<p>Defined as: <code>type UName = unbox struct { ...fields... }</code></p> <p>A type of name and information of current kernel.</p>"},{"location":"Minilib.IO.Platform/#field-sysname","title":"field <code>sysname</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.IO.Platform/#field-nodename","title":"field <code>nodename</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.IO.Platform/#field-release","title":"field <code>release</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.IO.Platform/#field-version","title":"field <code>version</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.IO.Platform/#field-machine","title":"field <code>machine</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.IO.Platform/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.IO.Platform/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.IO.Signal/","title":"Minilib.IO.Signal","text":"<p>Defined in minilib-io@0.5.1</p> <p>Unix signal handling</p>"},{"location":"Minilib.IO.Signal/#values","title":"Values","text":""},{"location":"Minilib.IO.Signal/#namespace-minilibiosignal","title":"namespace Minilib.IO.Signal","text":""},{"location":"Minilib.IO.Signal/#kill_process","title":"kill_process","text":"<p>Type: <code>Std::I64 -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.IO.Signal/#set_signal_handler","title":"set_signal_handler","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p> <p><code>set_signal_handler(signal_name, sighandle_name)</code> sets the handler for the signal. <code>signal_name</code> should be one of <code>signal_names</code>. <code>sighandle_name</code> should be one of <code>sighandler_names</code>.</p>"},{"location":"Minilib.IO.Signal/#sighandler_names","title":"sighandler_names","text":"<p>Type: <code>Std::Array Std::String</code></p> <p>An array of supported signal handler names.</p>"},{"location":"Minilib.IO.Signal/#signal_names","title":"signal_names","text":"<p>Type: <code>Std::Array Std::String</code></p> <p>An array of supported signal names.</p>"},{"location":"Minilib.IO.Signal/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.IO.Signal/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.IO.Signal/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.BigFloat/","title":"Minilib.Math.BigFloat","text":"<p>Defined in minilib-math@0.5.1</p> <p>Arbitrary-precision floating point number.</p> <p>A BigFloat is composed from a mantissa and the exponent of base 2.</p> <p>Each BigFloat has a precision. It is same as the precision of the mantissa, and determined by the length of the underlying array (= BigNat).</p> <p>The precision of a BigNat can be changed with <code>set_prec()</code>.</p> <p>For unary operator such as <code>-a</code>, the precision of the result is the same as the precision of the operand.</p> <p>For binary operator such as <code>a + b</code>, <code>a - b</code>, <code>a * b</code>, <code>a / b</code>, the precision of the result is the maximum precision of the two operands.</p>"},{"location":"Minilib.Math.BigFloat/#values","title":"Values","text":""},{"location":"Minilib.Math.BigFloat/#namespace-minilibmathbigfloat","title":"namespace Minilib.Math.BigFloat","text":""},{"location":"Minilib.Math.BigFloat/#_approx_log2","title":"_approx_log2","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::I64</code></p> <p>Calculates approximation of <code>log2(a.abs)</code>.</p>"},{"location":"Minilib.Math.BigFloat/#_from_string_precision","title":"_from_string_precision","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::I64 -&gt; Std::Result Std::ErrMsg Minilib.Math.BigFloat::BigFloat</code></p>"},{"location":"Minilib.Math.BigFloat/#_get_num_frac_digits","title":"_get_num_frac_digits","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::I64</code></p> <p>get the preferred number of fractional digits (not same as a.get_prec10).</p>"},{"location":"Minilib.Math.BigFloat/#_maximize_precision","title":"_maximize_precision","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Move the topmost 1 to MSB</p>"},{"location":"Minilib.Math.BigFloat/#_one","title":"_one","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat</code></p>"},{"location":"Minilib.Math.BigFloat/#_sqrt_inner","title":"_sqrt_inner","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Returns the square root of <code>a</code> using Newton-Raphson method.</p>"},{"location":"Minilib.Math.BigFloat/#_ten","title":"_ten","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat</code></p>"},{"location":"Minilib.Math.BigFloat/#_to_string_exp_precision","title":"_to_string_exp_precision","text":"<p>Type: <code>Std::Option Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Std::String</code></p>"},{"location":"Minilib.Math.BigFloat/#_to_string_rep","title":"_to_string_rep","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::String</code></p> <p>Convert a BigFloat to a string of internal representation.</p>"},{"location":"Minilib.Math.BigFloat/#_zero","title":"_zero","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat</code></p>"},{"location":"Minilib.Math.BigFloat/#abs","title":"abs","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Returns the absolute value of <code>a</code>.</p>"},{"location":"Minilib.Math.BigFloat/#epsilon","title":"epsilon","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Gets a BigInt that represents the smallest change in the mantissa of this BigInt.</p>"},{"location":"Minilib.Math.BigFloat/#from_f64","title":"from_F64","text":"<p>Type: <code>Std::F64 -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Converts F64 to BigFloat.</p>"},{"location":"Minilib.Math.BigFloat/#from_string_precision","title":"from_string_precision","text":"<p>Type: <code>Std::String -&gt; Std::I64 -&gt; Std::Result Std::ErrMsg Minilib.Math.BigFloat::BigFloat</code></p> <p>Converts a string to BigFloat with the precision specified in base 10.</p>"},{"location":"Minilib.Math.BigFloat/#get_prec","title":"get_prec","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::I64</code></p> <p>Gets the precision of a BigFloat in base 2. It is multiple of 32.</p>"},{"location":"Minilib.Math.BigFloat/#get_prec10","title":"get_prec10","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::I64</code></p> <p>Gets the precision of a BigFloat in base 10. It calls <code>get_prec()</code> and converts the precision from base 2.</p>"},{"location":"Minilib.Math.BigFloat/#is_negative","title":"is_negative","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::Bool</code></p> <p>Returns true iff the BigFloat is negative.</p>"},{"location":"Minilib.Math.BigFloat/#is_positive","title":"is_positive","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::Bool</code></p> <p>Returns true iff the BigFloat is positive.</p>"},{"location":"Minilib.Math.BigFloat/#is_zero","title":"is_zero","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::Bool</code></p> <p>Returns true iff the BigFloat is zero.</p>"},{"location":"Minilib.Math.BigFloat/#make","title":"make","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Creates a BigFloat from a BigInt and the exponent of base 2.</p>"},{"location":"Minilib.Math.BigFloat/#mul_pow2","title":"mul_pow2","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Calculates <code>a * 2^e</code>.</p>"},{"location":"Minilib.Math.BigFloat/#pow_by_u64","title":"pow_by_U64","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Calculates <code>a^n</code>.</p>"},{"location":"Minilib.Math.BigFloat/#set_prec","title":"set_prec","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Set the precision of a BigFloat in base2. The precision is round-up to multiple of 32, except if <code>prec == 0</code> then the precision is set to 32.</p>"},{"location":"Minilib.Math.BigFloat/#set_prec10","title":"set_prec10","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Sets the precision of a BigFloat in base 10. It calls <code>set_prec()</code> after converting the precision to base 2.</p>"},{"location":"Minilib.Math.BigFloat/#sqrt","title":"sqrt","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Minilib.Math.BigFloat::BigFloat</code></p> <p>Returns the square root of <code>a</code>.</p>"},{"location":"Minilib.Math.BigFloat/#to_f64","title":"to_F64","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::F64</code></p> <p>Converts BigFloat to F64. If BigFloat is out of range of F64, unexpected result is returned.</p>"},{"location":"Minilib.Math.BigFloat/#to_string_exp","title":"to_string_exp","text":"<p>Type: <code>Minilib.Math.BigFloat::BigFloat -&gt; Std::String</code></p> <p>Convert a BigFloat to a string of exponential form.</p>"},{"location":"Minilib.Math.BigFloat/#to_string_exp_precision","title":"to_string_exp_precision","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Std::String</code></p> <p>Convert a BigFloat to a string of exponential form with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Minilib.Math.BigFloat/#to_string_precision","title":"to_string_precision","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigFloat::BigFloat -&gt; Std::String</code></p> <p>Convert a BigFloat to a string with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Minilib.Math.BigFloat/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.BigFloat/#namespace-minilibmathbigfloat_1","title":"namespace Minilib.Math.BigFloat","text":""},{"location":"Minilib.Math.BigFloat/#bigfloat","title":"BigFloat","text":"<p>Defined as: <code>type BigFloat = unbox struct { ...fields... }</code></p> <p>Arbitrary-precision floating point number. It is interpreted as <code>mantissa * 2 ^ exponent</code>.</p>"},{"location":"Minilib.Math.BigFloat/#field-int","title":"field <code>int</code>","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt</code></p>"},{"location":"Minilib.Math.BigFloat/#field-exp","title":"field <code>exp</code>","text":"<p>Type: <code>Std::I64</code></p> <p>NOTE: @int.@nat might have trailing zeros.</p>"},{"location":"Minilib.Math.BigFloat/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.BigFloat/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-minilibmathtypesone","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdadd","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Add</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stddiv","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Div</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdeq","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Eq</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdfromstring","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::FromString</code>","text":"<p>Converts a string to BigFloat with the precision estimated from the string.</p>"},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdlessthan","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::LessThan</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdlessthanoreq","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::LessThanOrEq</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdmul","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Mul</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdneg","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Neg</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdsub","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Sub</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdtostring","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::ToString</code>","text":""},{"location":"Minilib.Math.BigFloat/#impl-minilibmathbigfloatbigfloat-stdzero","title":"impl <code>Minilib.Math.BigFloat::BigFloat : Std::Zero</code>","text":""},{"location":"Minilib.Math.BigInt/","title":"Minilib.Math.BigInt","text":"<p>Defined in minilib-math@0.5.1</p> <p>Arbitrary-precision integer.</p>"},{"location":"Minilib.Math.BigInt/#values","title":"Values","text":""},{"location":"Minilib.Math.BigInt/#namespace-minilibmathbigint","title":"namespace Minilib.Math.BigInt","text":""},{"location":"Minilib.Math.BigInt/#_bitand_i64","title":"_bitand_I64","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigInt::BigInt -&gt; Std::I64</code></p> <p><code>a._bitand_I64(i64)</code> returns bitwise-AND of <code>a</code> and <code>i64</code>. <code>i64</code> must be a positive number and less than BigNat::_base.</p>"},{"location":"Minilib.Math.BigInt/#abs","title":"abs","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Minilib.Math.BigInt::BigInt</code></p> <p><code>a.abs</code> returns the absolute value of <code>a</code>.</p>"},{"location":"Minilib.Math.BigInt/#bit_length","title":"bit_length","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::U64</code></p> <p>Returns the bit length of <code>a.@nat</code>, ie. one plus the bit position of most significant <code>1</code>. Returns 0 if <code>a</code> is zero.</p>"},{"location":"Minilib.Math.BigInt/#cmp","title":"cmp","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Minilib.Math.BigInt::BigInt -&gt; Std::I64</code></p> <p><code>BigInt::cmp(a,b)</code> returns 1 if <code>a &gt; b</code>, -1 if <code>a &lt; b</code>, 0 if <code>a == b</code>.</p>"},{"location":"Minilib.Math.BigInt/#divmod_by_two","title":"divmod_by_two","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; (Minilib.Math.BigInt::BigInt, Minilib.Math.BigInt::BigInt)</code></p> <p><code>BigInt::divmod_by_two(a)</code> returns <code>(a/2, a%2)</code>.</p>"},{"location":"Minilib.Math.BigInt/#from_i64","title":"from_I64","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.BigInt::BigInt</code></p> <p><code>BigInt::from_I64(i64)</code> creates new BigInt object from <code>i64</code>.</p>"},{"location":"Minilib.Math.BigInt/#from_u64","title":"from_U64","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Math.BigInt::BigInt</code></p> <p><code>BigInt::from_U64(u64)</code> creates new BigInt object from <code>u64</code>.</p>"},{"location":"Minilib.Math.BigInt/#generate_bigint","title":"generate_bigint","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Std::I64 -&gt; m Minilib.Math.BigInt::BigInt</code></p> <p><code>generate_bigint(bit_length)</code> generates a random BigInt of the specified bit length.</p>"},{"location":"Minilib.Math.BigInt/#generate_bigint_range","title":"generate_bigint_range","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Minilib.Math.BigInt::BigInt -&gt; Minilib.Math.BigInt::BigInt -&gt; m Minilib.Math.BigInt::BigInt</code></p> <p><code>generate_bigint_range(begin, end)</code> generates a random BigInt <code>r</code> such that <code>begin &lt;= r &amp;&amp; r &lt; end</code>.</p>"},{"location":"Minilib.Math.BigInt/#is_even","title":"is_even","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::Bool</code></p> <p><code>a.is_even</code> returns true iff <code>a</code> is an even number.</p>"},{"location":"Minilib.Math.BigInt/#is_negative","title":"is_negative","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::Bool</code></p> <p><code>a.is_negative</code> returns true iff <code>a</code> is a negative number.</p>"},{"location":"Minilib.Math.BigInt/#is_odd","title":"is_odd","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::Bool</code></p> <p><code>a.is_odd</code> returns true iff <code>a</code> is an odd number.</p>"},{"location":"Minilib.Math.BigInt/#is_positive","title":"is_positive","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::Bool</code></p> <p><code>a.is_positive</code> returns true iff <code>a</code> is a positive number.</p>"},{"location":"Minilib.Math.BigInt/#is_zero","title":"is_zero","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::Bool</code></p> <p><code>a.is_zero</code> returns true iff <code>a</code> is zero.</p>"},{"location":"Minilib.Math.BigInt/#make","title":"make","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U32 -&gt; Minilib.Math.BigInt::BigInt</code></p> <p><code>BigInt::make(sign, nat)</code> creates new BigInt object.</p>"},{"location":"Minilib.Math.BigInt/#repeat_by_bigint","title":"repeat_by_BigInt","text":"<p>Type: <code>(a -&gt; a -&gt; a) -&gt; a -&gt; a -&gt; Minilib.Math.BigInt::BigInt -&gt; a</code></p> <p><code>repeat_by_BigInt(op, x, a, n)</code> calculates <code>x.op(a).op(a)...</code> for <code>n</code> times. <code>op</code> is an associative binary operation.</p>"},{"location":"Minilib.Math.BigInt/#shift_left","title":"shift_left","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Math.BigInt::BigInt -&gt; Minilib.Math.BigInt::BigInt</code></p> <p>Shifts <code>@nat</code> to left. NOTE <code>@sign</code> does not affect at all.</p>"},{"location":"Minilib.Math.BigInt/#shift_right","title":"shift_right","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Math.BigInt::BigInt -&gt; Minilib.Math.BigInt::BigInt</code></p> <p>Shifts <code>@nat</code> to right. NOTE <code>@sign</code> does not affect at all.</p>"},{"location":"Minilib.Math.BigInt/#to_i64","title":"to_I64","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt -&gt; Std::I64</code></p> <p>Converts BigInt to I64. If overflow, it produces unexpected result.</p>"},{"location":"Minilib.Math.BigInt/#two","title":"two","text":"<p>Type: <code>Minilib.Math.BigInt::BigInt</code></p> <p>BigInt constant representing 2.</p>"},{"location":"Minilib.Math.BigInt/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.BigInt/#namespace-minilibmathbigint_1","title":"namespace Minilib.Math.BigInt","text":""},{"location":"Minilib.Math.BigInt/#bigint","title":"BigInt","text":"<p>Defined as: <code>type BigInt = unbox struct { ...fields... }</code></p> <p>Arbitrary-precision integer.</p>"},{"location":"Minilib.Math.BigInt/#field-sign","title":"field <code>sign</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Math.BigInt/#field-nat","title":"field <code>nat</code>","text":"<p>Type: <code>Std::Array Std::U32</code></p>"},{"location":"Minilib.Math.BigInt/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.BigInt/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-minilibmathtypesdivmod","title":"impl <code>Minilib.Math.BigInt::BigInt : Minilib.Math.Types::DivMod</code>","text":"<p><code>divmod(a,b)</code> returns <code>(a/b, a%b)</code>. NOTE: -8 / 3 == -2 and -8 % 3 == -2, as with the Fix language.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-minilibmathtypesone","title":"impl <code>Minilib.Math.BigInt::BigInt : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdadd","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Add</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stddiv","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Div</code>","text":"<p>NOTE: -8 / 3 == -2, as with the Fix language.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdeq","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Eq</code>","text":"<p>Checks two BigInts are equal.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdfrombytes","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::FromBytes</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdfromstring","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::FromString</code>","text":"<p>Converts BigInt from a decimal string.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdlessthan","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::LessThan</code>","text":"<p>Compares two BigInts.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdlessthanoreq","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::LessThanOrEq</code>","text":"<p>Compares two BigInts.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdmul","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Mul</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdneg","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Neg</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdrem","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Rem</code>","text":"<p>NOTE: -8 % 3 == -2, as with the Fix language.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdsub","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Sub</code>","text":""},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdtobytes","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::ToBytes</code>","text":"<p>NOTE: Unneeded zeros might be placed at the beginning</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdtostring","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::ToString</code>","text":"<p>Converts BigInt to a decimal string.</p>"},{"location":"Minilib.Math.BigInt/#impl-minilibmathbigintbigint-stdzero","title":"impl <code>Minilib.Math.BigInt::BigInt : Std::Zero</code>","text":""},{"location":"Minilib.Math.BigNat/","title":"Minilib.Math.BigNat","text":"<p>Defined in minilib-math@0.5.1</p> <p>Arbitrary-precision natural number. This is internal module of BigInt.</p>"},{"location":"Minilib.Math.BigNat/#values","title":"Values","text":""},{"location":"Minilib.Math.BigNat/#namespace-minilibmathbignat","title":"namespace Minilib.Math.BigNat","text":""},{"location":"Minilib.Math.BigNat/#_add","title":"_add","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>a0 + a1</code>.</p>"},{"location":"Minilib.Math.BigNat/#_add_u32_with_offset1","title":"_add_u32_with_offset1","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U32 -&gt; Std::I64 -&gt; Std::Array Std::U32</code></p> <p><code>_add_u32_with_offset1(a0, a1, offset1)</code> calculates <code>a0 + a1 * pow(_base, offset1)</code>.</p>"},{"location":"Minilib.Math.BigNat/#_add_u64_with_exp","title":"_add_u64_with_exp","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64 -&gt; Std::U64 -&gt; Std::Array Std::U32</code></p> <p><code>_add_u64_with_exp(a, bm, be)</code> calculates <code>a + bm * pow(2, be)</code>.</p>"},{"location":"Minilib.Math.BigNat/#_add_with_offset1","title":"_add_with_offset1","text":"<p>Type: <code>Std::Array Std::U32 -&gt; (Std::Array Std::U32, Std::I64) -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>a0 + a1 * pow(_base, offset1)</code>.</p>"},{"location":"Minilib.Math.BigNat/#_append_last_zeros","title":"_append_last_zeros","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Appends trailing zeros until the size of the array is at least the specified size.</p>"},{"location":"Minilib.Math.BigNat/#_approx_with_exp","title":"_approx_with_exp","text":"<p>Type: <code>Std::I64 -&gt; Std::Array Std::U32 -&gt; (Std::U64, Std::I64)</code></p> <p>Approximate BigNat <code>a</code> as <code>m * 2^e</code>. <code>m</code> is the mantissa and its type is U64. <code>e</code> is the expopnent and its type is I64. If the bitlength of <code>a</code> is smaller or equal to <code>m_bitlen</code>, returns <code>(a._to_u64, 0)</code>. It should be hold that <code>m * e^2 &lt;= a &lt; (m+1) * e^2</code>.</p>"},{"location":"Minilib.Math.BigNat/#_base","title":"_base","text":"<p>Type: <code>Std::U64</code></p> <p>The base of BigNat. It must be power of 2.</p>"},{"location":"Minilib.Math.BigNat/#_bit_length","title":"_bit_length","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64</code></p> <p>Returns the bit length of <code>a</code>, ie. one plus the bit position of most significant <code>1</code>. Returns 0 if <code>a</code> is zero.</p>"},{"location":"Minilib.Math.BigNat/#_cmp","title":"_cmp","text":"<p>Type: <code>(Std::Array Std::U32, Std::I64) -&gt; (Std::Array Std::U32, Std::I64) -&gt; Std::I64</code></p> <p>Calculates <code>sign(a0 * _base ^ offset0 - a1 * _base ^ offset1)</code>.</p>"},{"location":"Minilib.Math.BigNat/#_convert_borrow_to_sign","title":"_convert_borrow_to_sign","text":"<p>Type: <code>(Std::Array Std::U32, Std::U64) -&gt; (Std::Array Std::U32, Std::I64)</code></p> <p>Converts a result of a borrowed subtraction to a signed subtraction.</p>"},{"location":"Minilib.Math.BigNat/#_divmod","title":"_divmod","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; (Std::Array Std::U32, Std::Array Std::U32)</code></p> <p>Calculates <code>(a0 / a1, a0 % a1)</code>. Aborts if any error occured.</p>"},{"location":"Minilib.Math.BigNat/#_divmod_base","title":"_divmod_base","text":"<p>Type: <code>Std::U64 -&gt; (Std::U64, Std::U64)</code></p> <p>divmod by _base.</p>"},{"location":"Minilib.Math.BigNat/#_divmod_by_power_of_two","title":"_divmod_by_power_of_two","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64 -&gt; (Std::Array Std::U32, Std::Array Std::U32)</code></p> <p>Calculates <code>(a0 / 2 ^ exp, a0 % 2 ^ exp)</code>. Aborts if any error occured.</p>"},{"location":"Minilib.Math.BigNat/#_divmod_by_two","title":"_divmod_by_two","text":"<p>Type: <code>Std::Array Std::U32 -&gt; (Std::Array Std::U32, Std::Array Std::U32)</code></p> <p>Calculates <code>(a0 / 2, a0 % 2)</code>. Aborts if any error occured.</p>"},{"location":"Minilib.Math.BigNat/#_divmod_log2_base","title":"_divmod_log2_base","text":"<p>Type: <code>Std::U64 -&gt; (Std::U64, Std::U64)</code></p> <p>divmod by _log2_base.</p>"},{"location":"Minilib.Math.BigNat/#_divmod_u32","title":"_divmod_u32","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U32 -&gt; (Std::Array Std::U32, Std::U32)</code></p> <p>Calculates <code>(a0 / d1, a0 % d1)</code>.</p>"},{"location":"Minilib.Math.BigNat/#_dummy","title":"_dummy","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Math.BigNat/#_from_string_inner","title":"_from_string_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::I64 -&gt; Std::Array Std::U32 -&gt; Std::Result Std::ErrMsg (Std::Array Std::U32)</code></p> <p>FromString of BigNat.</p>"},{"location":"Minilib.Math.BigNat/#_from_u64","title":"_from_u64","text":"<p>Type: <code>Std::U64 -&gt; Std::Array Std::U32</code></p> <p>Converts U64 to BigNat.</p>"},{"location":"Minilib.Math.BigNat/#_generate_bignat","title":"_generate_bignat","text":"<p>Type: <code>Std::I64 -&gt; Random::Random -&gt; (Random::Random, Std::Array Std::U32)</code></p>"},{"location":"Minilib.Math.BigNat/#_generate_bignat_range","title":"_generate_bignat_range","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Random::Random -&gt; (Random::Random, Std::Array Std::U32)</code></p>"},{"location":"Minilib.Math.BigNat/#_is_zero","title":"_is_zero","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Bool</code></p> <p>Returns true if BigNat is zero.</p>"},{"location":"Minilib.Math.BigNat/#_log2_base","title":"_log2_base","text":"<p>Type: <code>Std::U64</code></p> <p>log2 of base. It must be power of 2 and <code>0 &lt;= _log2_base &lt;= 32</code>.</p>"},{"location":"Minilib.Math.BigNat/#_log2_log2_base","title":"_log2_log2_base","text":"<p>Type: <code>Std::U64</code></p> <p>log2(log2(base)). It must be <code>0 &lt;= _log2_log2_base &lt;= 5</code>.</p>"},{"location":"Minilib.Math.BigNat/#_mul","title":"_mul","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>a0 * a1</code>.</p>"},{"location":"Minilib.Math.BigNat/#_mul_u32","title":"_mul_u32","text":"<p>Type: <code>Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>d0 * a1</code>.</p>"},{"location":"Minilib.Math.BigNat/#_neg","title":"_neg","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Treats <code>a</code> as a negative number in two's complement representation and reverses its sign.</p>"},{"location":"Minilib.Math.BigNat/#_one","title":"_one","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>1 in BigNat.</p>"},{"location":"Minilib.Math.BigNat/#_pow_by_u64","title":"_pow_by_U64","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64 -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>a^n</code>.</p>"},{"location":"Minilib.Math.BigNat/#_remove_last_zeros","title":"_remove_last_zeros","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Removes trailing zeros.</p>"},{"location":"Minilib.Math.BigNat/#_shift_left","title":"_shift_left","text":"<p>Type: <code>Std::U64 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p>"},{"location":"Minilib.Math.BigNat/#_shift_right","title":"_shift_right","text":"<p>Type: <code>Std::U64 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p>"},{"location":"Minilib.Math.BigNat/#_signed_sub_with_offset","title":"_signed_sub_with_offset","text":"<p>Type: <code>(Std::Array Std::U32, Std::I64) -&gt; (Std::Array Std::U32, Std::I64) -&gt; ((Std::Array Std::U32, Std::I64), Std::I64)</code></p> <p>Calculates <code>a0 * pow(_base, offset0) - a1 * pow(_base, offset1)</code>. returns the result and the sign.</p>"},{"location":"Minilib.Math.BigNat/#_sub","title":"_sub","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Calculates <code>a0 - a1</code>. Aborts if the result is negative.</p>"},{"location":"Minilib.Math.BigNat/#_sub_u32_with_offset","title":"_sub_u32_with_offset","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U32 -&gt; Std::I64 -&gt; (Std::Array Std::U32, Std::U64)</code></p> <p><code>_sub_u32_with_offset(a, b, b_offset)</code> calculates <code>a - b * pow(_base, b_offset)</code>. returns the result and the borrow.</p>"},{"location":"Minilib.Math.BigNat/#_sub_u64_with_exp","title":"_sub_u64_with_exp","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64 -&gt; Std::U64 -&gt; (Std::Array Std::U32, Std::U64)</code></p> <p><code>_sub_u64_with_exp(a, bm, be)</code> calculates <code>a - bm * pow(2, be)</code>. Returns the result and the borrow.</p>"},{"location":"Minilib.Math.BigNat/#_sub_with_exp_mul","title":"_sub_with_exp_mul","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::U64 -&gt; Std::U64 -&gt; (Std::Array Std::U32, Std::U64)</code></p> <p><code>_sub_with_exp_mul(a, b, qm, qe)</code> calculates <code>a - b * qm * pow(2, qe)</code>. Returns the result and the borrow.</p>"},{"location":"Minilib.Math.BigNat/#_sub_with_offset_mul","title":"_sub_with_offset_mul","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U32 -&gt; Std::U32 -&gt; Std::I64 -&gt; (Std::Array Std::U32, Std::U64)</code></p> <p><code>_sub_with_offset_mul(a, b, q, b_offset)</code> calculates <code>a - b * q * pow(_base, b_offset)</code>. Returns the result and the borrow.</p>"},{"location":"Minilib.Math.BigNat/#_to_string","title":"_to_string","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::String</code></p> <p>ToString of BigNat.</p>"},{"location":"Minilib.Math.BigNat/#_to_string_hex","title":"_to_string_hex","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::String</code></p>"},{"location":"Minilib.Math.BigNat/#_to_string_inner","title":"_to_string_inner","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Iterator::DynIterator Std::U8 -&gt; Std::Iterator::DynIterator Std::U8</code></p>"},{"location":"Minilib.Math.BigNat/#_to_u64","title":"_to_u64","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::U64</code></p> <p>Converts BigNat to U64. If overflow, it produces unexpected result.</p>"},{"location":"Minilib.Math.BigNat/#_two","title":"_two","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>2 in BigNat.</p>"},{"location":"Minilib.Math.BigNat/#_zero","title":"_zero","text":"<p>Type: <code>Std::Array Std::U32</code></p> <p>0 in BigNat.</p>"},{"location":"Minilib.Math.BigNat/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.BigNat/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.BigNat/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Complex/","title":"Minilib.Math.Complex","text":"<p>Defined in minilib-math@0.5.1</p> <p>Complex number, for example <code>1 + 2i</code>.</p>"},{"location":"Minilib.Math.Complex/#values","title":"Values","text":""},{"location":"Minilib.Math.Complex/#namespace-minilibmathcomplex","title":"namespace Minilib.Math.Complex","text":""},{"location":"Minilib.Math.Complex/#abs","title":"abs","text":"<p>Type: <code>Minilib.Math.Complex::Complex Std::F64 -&gt; Std::F64</code></p> <p>Returns the absolute value of a complex number.</p>"},{"location":"Minilib.Math.Complex/#abs2","title":"abs2","text":"<p>Type: <code>[a : Std::Add, a : Std::Mul] Minilib.Math.Complex::Complex a -&gt; a</code></p> <p>Returns the square of the absolute value of a complex number.</p>"},{"location":"Minilib.Math.Complex/#arg","title":"arg","text":"<p>Type: <code>Minilib.Math.Complex::Complex Std::F64 -&gt; Std::F64</code></p> <p>Returns the argument of a complex number, ie.</p>"},{"location":"Minilib.Math.Complex/#complex","title":"complex","text":"<p>Type: <code>a -&gt; a -&gt; Minilib.Math.Complex::Complex a</code></p> <p><code>complex</code> is synonym for <code>make</code>.</p>"},{"location":"Minilib.Math.Complex/#conj","title":"conj","text":"<p>Type: <code>[a : Std::Neg] Minilib.Math.Complex::Complex a -&gt; Minilib.Math.Complex::Complex a</code></p> <p>Returns the conjugate complex number.</p>"},{"location":"Minilib.Math.Complex/#make","title":"make","text":"<p>Type: <code>a -&gt; a -&gt; Minilib.Math.Complex::Complex a</code></p> <p>Creates a complex number.</p>"},{"location":"Minilib.Math.Complex/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Complex/#namespace-minilibmathcomplex_1","title":"namespace Minilib.Math.Complex","text":""},{"location":"Minilib.Math.Complex/#complex_1","title":"Complex","text":"<p>Defined as: <code>type Complex a = unbox struct { ...fields... }</code></p> <p>A type that represents a complex number. <code>a</code> is typically F64 or F32.</p>"},{"location":"Minilib.Math.Complex/#field-re","title":"field <code>re</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Complex/#field-im","title":"field <code>im</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Complex/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Complex/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Complex/#impl-a-stdadd-minilibmathcomplexcomplex-a-stdadd","title":"impl <code>[a : Std::Add] Minilib.Math.Complex::Complex a : Std::Add</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-minilibmathtypesfield-minilibmathcomplexcomplex-a-stddiv","title":"impl <code>[a : Minilib.Math.Types::Field] Minilib.Math.Complex::Complex a : Std::Div</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-stdeq-minilibmathcomplexcomplex-a-stdeq","title":"impl <code>[a : Std::Eq] Minilib.Math.Complex::Complex a : Std::Eq</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-minilibmathtypesring-minilibmathcomplexcomplex-a-stdmul","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Complex::Complex a : Std::Mul</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-stdneg-minilibmathcomplexcomplex-a-stdneg","title":"impl <code>[a : Std::Neg] Minilib.Math.Complex::Complex a : Std::Neg</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-stdsub-minilibmathcomplexcomplex-a-stdsub","title":"impl <code>[a : Std::Sub] Minilib.Math.Complex::Complex a : Std::Sub</code>","text":""},{"location":"Minilib.Math.Complex/#impl-a-stdtostring-minilibmathcomplexcomplex-a-stdtostring","title":"impl <code>[a : Std::ToString] Minilib.Math.Complex::Complex a : Std::ToString</code>","text":"<p>Converts a complex number to a string.</p>"},{"location":"Minilib.Math.Complex/#impl-a-stdzero-minilibmathcomplexcomplex-a-stdzero","title":"impl <code>[a : Std::Zero] Minilib.Math.Complex::Complex a : Std::Zero</code>","text":""},{"location":"Minilib.Math.Euclid/","title":"Minilib.Math.Euclid","text":"<p>Defined in minilib-math@0.5.1</p> <p>Euclid algorithms, such as <code>gcd</code> (greatest common divisor).</p> <p><code>Euclid</code> represents a Euclidean domain, which is a Ring with following division-with-remainder.</p> <pre><code>forall a b, a = (a / b) * b + (a % b)\n</code></pre> <p>For details, see Wikipedia: Euclidean domain.</p>"},{"location":"Minilib.Math.Euclid/#values","title":"Values","text":""},{"location":"Minilib.Math.Euclid/#namespace-minilibmatheuclid","title":"namespace Minilib.Math.Euclid","text":""},{"location":"Minilib.Math.Euclid/#_extended_euclid_inner","title":"_extended_euclid_inner","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; (a, a, a)</code></p> <p>An internal function for <code>extended_euclid</code>.</p>"},{"location":"Minilib.Math.Euclid/#extended_euclid","title":"extended_euclid","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; (a, a, a)</code></p> <p><code>extended_euclid(a,b)</code> performs Extended Euclidean algorithm. It solves <code>a * x + b * y = d</code> where <code>d = gcd(a, b)</code>, and returns <code>(x, y, d)</code>.</p>"},{"location":"Minilib.Math.Euclid/#gcd","title":"gcd","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; a</code></p> <p><code>gcd(a,b)</code> calculates the greatest common divisor of <code>a</code> and <code>b</code>.</p>"},{"location":"Minilib.Math.Euclid/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Euclid/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Euclid/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Modular/","title":"Minilib.Math.Modular","text":"<p>Defined in minilib-math@0.5.1</p> <p>This is an arithmetic with a modulus (modulo), for example <code>2 * 5 = 10 = 3 (mod 7)</code>.</p> <p>For details, see Wikipedia: Modular Arithmetic.</p>"},{"location":"Minilib.Math.Modular/#values","title":"Values","text":""},{"location":"Minilib.Math.Modular/#namespace-minilibmathmodular","title":"namespace Minilib.Math.Modular","text":""},{"location":"Minilib.Math.Modular/#_get_modulus","title":"_get_modulus","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a -&gt; Minilib.Math.Modular::Modular a -&gt; a</code></p> <p>Returns modulus of either <code>x</code> or <code>y</code>.</p>"},{"location":"Minilib.Math.Modular/#make","title":"make","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; Minilib.Math.Modular::Modular a</code></p> <p><code>Modular::make(v, m)</code> creates <code>v modulo m</code>. It is an equivalence class of a quotient ring <code>Z/mZ</code>.</p>"},{"location":"Minilib.Math.Modular/#modulo","title":"modulo","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; Minilib.Math.Modular::Modular a</code></p> <p>Synonym for <code>Modular::make</code>.</p>"},{"location":"Minilib.Math.Modular/#nonneg","title":"nonneg","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid, a : Std::LessThan] Minilib.Math.Modular::Modular a -&gt; Minilib.Math.Modular::Modular a</code></p> <p><code>x.nonneg</code> changes <code>@value</code> with a equivalent non-negative value. For example, <code>modulo(-1, 3)</code> will be changed to <code>modulo(2,3)</code> because <code>-1 == 2 mod 3</code>.</p>"},{"location":"Minilib.Math.Modular/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Modular/#namespace-minilibmathmodular_1","title":"namespace Minilib.Math.Modular","text":""},{"location":"Minilib.Math.Modular/#modular","title":"Modular","text":"<p>Defined as: <code>type Modular a = unbox struct { ...fields... }</code></p> <p>A type that performs Modular Arithmetic.</p>"},{"location":"Minilib.Math.Modular/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Modular/#field-modulus","title":"field <code>modulus</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Modular/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Modular/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-minilibmathtypesone","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdadd","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Add</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stddiv","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Div</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdeq","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Eq</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdmul","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Mul</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdneg","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Neg</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdsub","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Sub</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-stdtostring-minilibmathmodularmodular-a-stdtostring","title":"impl <code>[a : Std::ToString] Minilib.Math.Modular::Modular a : Std::ToString</code>","text":""},{"location":"Minilib.Math.Modular/#impl-a-minilibmathtypeseuclid-minilibmathmodularmodular-a-stdzero","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Modular::Modular a : Std::Zero</code>","text":""},{"location":"Minilib.Math.Polynomial/","title":"Minilib.Math.Polynomial","text":"<p>Defined in minilib-math@0.5.1</p> <p>Polynomial of one variable, for example <code>x^2 + 2x + 1</code>. The coefficients can be any ring.</p>"},{"location":"Minilib.Math.Polynomial/#values","title":"Values","text":""},{"location":"Minilib.Math.Polynomial/#namespace-minilibmathpolynomial","title":"namespace Minilib.Math.Polynomial","text":""},{"location":"Minilib.Math.Polynomial/#_to_string_full","title":"_to_string_full","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring, a : Std::ToString] Minilib.Math.Polynomial::Polynomial a -&gt; Std::String</code></p> <p>Converts a polynomial to a string without simplification.</p>"},{"location":"Minilib.Math.Polynomial/#_to_string_simple","title":"_to_string_simple","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring, a : Std::ToString] Minilib.Math.Polynomial::Polynomial a -&gt; Std::String</code></p> <p>Converts a polynomial to a string with simplification.</p>"},{"location":"Minilib.Math.Polynomial/#at_degree","title":"at_degree","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring] Std::I64 -&gt; a -&gt; Minilib.Math.Polynomial::Polynomial a</code></p> <p><code>a.at_degree(n)</code> creates a polynomial <code>a * x ^ n</code>.</p>"},{"location":"Minilib.Math.Polynomial/#generate","title":"generate","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::DynIterator (Minilib.Math.Polynomial::Polynomial (Minilib.Math.Modular::Modular Std::I64))</code></p> <p><code>generate(p,m)</code> generates polynomials of degree <code>m</code> or lower in GF(p).</p>"},{"location":"Minilib.Math.Polynomial/#generate_primitive_polynomials","title":"generate_primitive_polynomials","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::DynIterator (Minilib.Math.Polynomial::Polynomial (Minilib.Math.Modular::Modular Std::I64))</code></p> <p><code>generate_primitive_polynomials(p, m)</code> generates primitive polynomials of degree <code>m</code> in GF(p).</p>"},{"location":"Minilib.Math.Polynomial/#get","title":"get","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring] Std::I64 -&gt; Minilib.Math.Polynomial::Polynomial a -&gt; a</code></p> <p><code>f.get(i)</code> returns the coefficient of degree <code>i</code>.</p>"},{"location":"Minilib.Math.Polynomial/#get_degree","title":"get_degree","text":"<p>Type: <code>Minilib.Math.Polynomial::Polynomial a -&gt; Std::I64</code></p> <p><code>f.get_degree</code> returns the degree of a polynomial <code>f</code>.</p>"},{"location":"Minilib.Math.Polynomial/#is_primitive","title":"is_primitive","text":"<p>Type: <code>Minilib.Math.Polynomial::Polynomial (Minilib.Math.Modular::Modular Std::I64) -&gt; Std::Bool</code></p> <p>Checks whether it is a primitive polynomial.</p>"},{"location":"Minilib.Math.Polynomial/#make","title":"make","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring] Std::Array a -&gt; Minilib.Math.Polynomial::Polynomial a</code></p> <p><code>Polynomial::make(coeff)</code> creates a polynomial from coefficients. For example, <code>Polynomial::make([1,2,3])</code> makes a polynomial <code>3x^2 + 2x + 1</code>. For polynomials with degree greater than zero, the coefficient array is truncated so that the coefficient of highest degree is not zero.</p>"},{"location":"Minilib.Math.Polynomial/#polynomial","title":"polynomial","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring] Std::Array a -&gt; Minilib.Math.Polynomial::Polynomial a</code></p> <p>Synonym for <code>Polynomial::make</code>.</p>"},{"location":"Minilib.Math.Polynomial/#set","title":"set","text":"<p>Type: <code>[a : Minilib.Math.Types::Ring] Std::I64 -&gt; a -&gt; Minilib.Math.Polynomial::Polynomial a -&gt; Minilib.Math.Polynomial::Polynomial a</code></p> <p><code>f.set(i, a)</code> sets the coefficient of degree <code>i</code>.</p>"},{"location":"Minilib.Math.Polynomial/#subst","title":"subst","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Math.Polynomial::Polynomial (Minilib.Math.Modular::Modular Std::I64) -&gt; Std::I64</code></p> <p><code>f.subst(x)</code> substitutes the indeterminate of a polynomial with <code>x</code>.</p>"},{"location":"Minilib.Math.Polynomial/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Polynomial/#namespace-minilibmathpolynomial_1","title":"namespace Minilib.Math.Polynomial","text":""},{"location":"Minilib.Math.Polynomial/#polynomial_1","title":"Polynomial","text":"<p>Defined as: <code>type Polynomial a = unbox struct { ...fields... }</code></p> <p>A structure that represents a polynomial over a ring. The coefficient array is ascending order of degree. For example, <code>[1,2,3]</code> means a polynomial <code>3x^2 + 2x + 1</code>.</p>"},{"location":"Minilib.Math.Polynomial/#field-coeff","title":"field <code>coeff</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Minilib.Math.Polynomial/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Polynomial/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesfield-minilibmathpolynomialpolynomial-a-minilibmathtypesdivmod","title":"impl <code>[a : Minilib.Math.Types::Field] Minilib.Math.Polynomial::Polynomial a : Minilib.Math.Types::DivMod</code>","text":"<p><code>divmod(num, den)</code> calculates a quotient <code>quo = num / den</code> and a reminder <code>rem = num % den</code>. Returns <code>(quo, rem)</code>. The type of coefficients must be a field. If the division of the field does not fulfill the requirement (ie. <code>forall a b, a == a / b * b</code>), this function may return an incorrect result.</p>"},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-minilibmathtypesone","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdadd","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Add</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesfield-minilibmathpolynomialpolynomial-a-stddiv","title":"impl <code>[a : Minilib.Math.Types::Field] Minilib.Math.Polynomial::Polynomial a : Std::Div</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdeq","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Eq</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdmul","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Mul</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdneg","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Neg</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesfield-minilibmathpolynomialpolynomial-a-stdrem","title":"impl <code>[a : Minilib.Math.Types::Field] Minilib.Math.Polynomial::Polynomial a : Std::Rem</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdsub","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Sub</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-a-stdtostring-minilibmathpolynomialpolynomial-a-stdtostring","title":"impl <code>[a : Minilib.Math.Types::Ring, a : Std::ToString] Minilib.Math.Polynomial::Polynomial a : Std::ToString</code>","text":""},{"location":"Minilib.Math.Polynomial/#impl-a-minilibmathtypesring-minilibmathpolynomialpolynomial-a-stdzero","title":"impl <code>[a : Minilib.Math.Types::Ring] Minilib.Math.Polynomial::Polynomial a : Std::Zero</code>","text":""},{"location":"Minilib.Math.Rational/","title":"Minilib.Math.Rational","text":"<p>Defined in minilib-math@0.5.1</p> <p>Rational number arithmetic, for example <code>1/2 + 1/3 = 5/6</code>.</p>"},{"location":"Minilib.Math.Rational/#values","title":"Values","text":""},{"location":"Minilib.Math.Rational/#namespace-minilibmathrationalrational","title":"namespace Minilib.Math.Rational::Rational","text":""},{"location":"Minilib.Math.Rational/#make","title":"make","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; Minilib.Math.Rational::Rational a</code></p> <p><code>make(num, den)</code> creates a rational number <code>(num/den)</code>. Aborts if <code>den</code> is zero.</p>"},{"location":"Minilib.Math.Rational/#rational","title":"rational","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] a -&gt; a -&gt; Minilib.Math.Rational::Rational a</code></p> <p>Synonym for <code>make</code>.</p>"},{"location":"Minilib.Math.Rational/#reduce","title":"reduce","text":"<p>Type: <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a -&gt; Minilib.Math.Rational::Rational a</code></p> <p>Reduces a rational number.</p>"},{"location":"Minilib.Math.Rational/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Rational/#namespace-minilibmathrational","title":"namespace Minilib.Math.Rational","text":""},{"location":"Minilib.Math.Rational/#rational_1","title":"Rational","text":"<p>Defined as: <code>type Rational a = unbox struct { ...fields... }</code></p> <p>Rational number</p>"},{"location":"Minilib.Math.Rational/#field-num","title":"field <code>num</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Rational/#field-den","title":"field <code>den</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Rational/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Rational/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-a-minilibmathtypesone-minilibmathrationalrational-a-minilibmathtypesone","title":"impl <code>[a : Minilib.Math.Types::Euclid, a : Minilib.Math.Types::One] Minilib.Math.Rational::Rational a : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stdadd","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Add</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stddiv","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Div</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stdeq","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Eq</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stdmul","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Mul</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stdneg","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Neg</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-minilibmathrationalrational-a-stdsub","title":"impl <code>[a : Minilib.Math.Types::Euclid] Minilib.Math.Rational::Rational a : Std::Sub</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-a-stdtostring-minilibmathrationalrational-a-stdtostring","title":"impl <code>[a : Minilib.Math.Types::Euclid, a : Std::ToString] Minilib.Math.Rational::Rational a : Std::ToString</code>","text":""},{"location":"Minilib.Math.Rational/#impl-a-minilibmathtypeseuclid-a-minilibmathtypesone-minilibmathrationalrational-a-stdzero","title":"impl <code>[a : Minilib.Math.Types::Euclid, a : Minilib.Math.Types::One] Minilib.Math.Rational::Rational a : Std::Zero</code>","text":""},{"location":"Minilib.Math.Ring/","title":"Minilib.Math.Ring","text":"<p>Defined in minilib-math@0.5.1</p> <p>Functions for a ring, for example multiplication or exponent with an integer.</p> <p>A ring is a mathematical structure which has addition(<code>add</code>), subtraction(<code>sub</code>), additive inverse(<code>neg</code>), additive unit(<code>zero</code>), multiplication(<code>mul</code>), multiplicative unit(<code>one</code>).</p> <p>For details, see Wikipedia: Ring.</p>"},{"location":"Minilib.Math.Ring/#values","title":"Values","text":""},{"location":"Minilib.Math.Ring/#namespace-minilibmathring","title":"namespace Minilib.Math.Ring","text":""},{"location":"Minilib.Math.Ring/#pow_by_u64","title":"pow_by_U64","text":"<p>Type: <code>[a : Std::Mul, a : Minilib.Math.Types::One] Std::U64 -&gt; a -&gt; a</code></p> <p><code>a.pow_by_U64(n)</code> calculates <code>a ^ n</code>.</p>"},{"location":"Minilib.Math.Ring/#repeat_by_u64","title":"repeat_by_U64","text":"<p>Type: <code>(a -&gt; a -&gt; a) -&gt; a -&gt; a -&gt; Std::U64 -&gt; a</code></p> <p><code>repeat_by_U64(op, x, a, n)</code> calculates <code>x.op(a).op(a)...</code> for <code>n</code> times. <code>op</code> is an associative binary operation. This function returns the same result as <code>Iterator::range(0, n).fold(x, |_, x| x.op(a))</code>, but faster.</p>"},{"location":"Minilib.Math.Ring/#times_by_u64","title":"times_by_U64","text":"<p>Type: <code>[a : Std::Add, a : Std::Zero] Std::U64 -&gt; a -&gt; a</code></p> <p><code>a.times_by_U64(n)</code> calculates <code>a * n</code>.</p>"},{"location":"Minilib.Math.Ring/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Ring/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Ring/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Types/","title":"Minilib.Math.Types","text":"<p>Defined in minilib-math@0.5.1</p> <p>Type definitions for mathematical concepts, for example AdditiveGroup, Ring, Field.</p>"},{"location":"Minilib.Math.Types/#values","title":"Values","text":""},{"location":"Minilib.Math.Types/#namespace-minilibmathtypesdivmod","title":"namespace Minilib.Math.Types::DivMod","text":""},{"location":"Minilib.Math.Types/#divmod","title":"divmod","text":"<p>Type: <code>[a : Minilib.Math.Types::DivMod] a -&gt; a -&gt; (a, a)</code></p> <p><code>divmod(a, b)</code> returns <code>(a/b, a%b)</code>.</p>"},{"location":"Minilib.Math.Types/#namespace-minilibmathtypesone","title":"namespace Minilib.Math.Types::One","text":""},{"location":"Minilib.Math.Types/#one","title":"one","text":"<p>Type: <code>[a : Minilib.Math.Types::One] a</code></p>"},{"location":"Minilib.Math.Types/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Math.Types/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Math.Types/#namespace-minilibmathtypes","title":"namespace Minilib.Math.Types","text":""},{"location":"Minilib.Math.Types/#trait-a-divmod","title":"trait <code>a : DivMod</code>","text":"<p>A trait for division-with-remainder.</p>"},{"location":"Minilib.Math.Types/#method-divmod","title":"method <code>divmod</code>","text":"<p>Type: <code>a -&gt; a -&gt; (a, a)</code></p> <p><code>divmod(a, b)</code> returns <code>(a/b, a%b)</code>.</p>"},{"location":"Minilib.Math.Types/#trait-a-one","title":"trait <code>a : One</code>","text":"<p>A trait that represents a multiplicative unit.</p>"},{"location":"Minilib.Math.Types/#method-one","title":"method <code>one</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Math.Types/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Math.Types/#impl-stdf32-minilibmathtypesone","title":"impl <code>Std::F32 : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Types/#impl-stdf64-minilibmathtypesone","title":"impl <code>Std::F64 : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Types/#impl-stdi64-minilibmathtypesdivmod","title":"impl <code>Std::I64 : Minilib.Math.Types::DivMod</code>","text":""},{"location":"Minilib.Math.Types/#impl-stdi64-minilibmathtypesone","title":"impl <code>Std::I64 : Minilib.Math.Types::One</code>","text":""},{"location":"Minilib.Math.Types/#impl-stdu64-minilibmathtypesdivmod","title":"impl <code>Std::U64 : Minilib.Math.Types::DivMod</code>","text":""},{"location":"Minilib.Media.Image/","title":"Minilib.Media.Image","text":"<p>Defined in minilib-media@0.5.1</p> <p>Basic image definitions.</p>"},{"location":"Minilib.Media.Image/#values","title":"Values","text":""},{"location":"Minilib.Media.Image/#namespace-minilibmediaimage","title":"namespace Minilib.Media.Image","text":""},{"location":"Minilib.Media.Image/#calc_channels_by_format","title":"calc_channels_by_format","text":"<p>Type: <code>Std::String -&gt; Std::I64</code></p>"},{"location":"Minilib.Media.Image/#calc_index","title":"calc_index","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Minilib.Media.Image::Image -&gt; Std::I64</code></p>"},{"location":"Minilib.Media.Image/#get","title":"get","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Media.Image::Image -&gt; Std::U8</code></p>"},{"location":"Minilib.Media.Image/#get_rgb","title":"get_rgb","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Media.Image::Image -&gt; (Std::U8, Std::U8, Std::U8)</code></p>"},{"location":"Minilib.Media.Image/#make","title":"make","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::String -&gt; Minilib.Media.Image::Image</code></p>"},{"location":"Minilib.Media.Image/#set","title":"set","text":"<p>Type: <code>Std::I64 -&gt; Std::U8 -&gt; Minilib.Media.Image::Image -&gt; Minilib.Media.Image::Image</code></p>"},{"location":"Minilib.Media.Image/#set_rgb","title":"set_rgb","text":"<p>Type: <code>Std::I64 -&gt; (Std::U8, Std::U8, Std::U8) -&gt; Minilib.Media.Image::Image -&gt; Minilib.Media.Image::Image</code></p>"},{"location":"Minilib.Media.Image/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Media.Image/#namespace-minilibmediaimage_1","title":"namespace Minilib.Media.Image","text":""},{"location":"Minilib.Media.Image/#image","title":"Image","text":"<p>Defined as: <code>type Image = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.Media.Image/#field-width","title":"field <code>width</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Image/#field-height","title":"field <code>height</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Image/#field-channels","title":"field <code>channels</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Image/#field-format","title":"field <code>format</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Media.Image/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Media.Image/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Media.Image/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Media.Png/","title":"Minilib.Media.Png","text":"<p>Defined in minilib-media@0.5.1</p> <p>PNG image I/O.</p> <p>How to use:  1. Install PNG library. For example, run the command below.     <code>$ sudo apt install libpng-dev</code>  2. Add <code>-d png</code> option to <code>fix run</code> and <code>fix build</code> arguments.</p> <p>NOTE: Currently only writing is supported. Reading is not supported yet.</p>"},{"location":"Minilib.Media.Png/#values","title":"Values","text":""},{"location":"Minilib.Media.Png/#namespace-minilibmediapng","title":"namespace Minilib.Media.Png","text":""},{"location":"Minilib.Media.Png/#_to_png_imageio","title":"_to_png_imageio","text":"<p>Type: <code>Minilib.Media.Image::Image -&gt; Std::IO::IOFail Minilib.Media.Png::PngImageIO</code></p>"},{"location":"Minilib.Media.Png/#write_png_file","title":"write_png_file","text":"<p>Type: <code>Std::String -&gt; Minilib.Media.Image::Image -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Media.Png/#write_png_to_memory","title":"write_png_to_memory","text":"<p>Type: <code>Minilib.Media.Image::Image -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p>"},{"location":"Minilib.Media.Png/#namespace-minilibmediapngpngimageio","title":"namespace Minilib.Media.Png::PngImageIO","text":""},{"location":"Minilib.Media.Png/#_png_format_flag_afirst","title":"_PNG_FORMAT_FLAG_AFIRST","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_alpha","title":"_PNG_FORMAT_FLAG_ALPHA","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_associated_alpha","title":"_PNG_FORMAT_FLAG_ASSOCIATED_ALPHA","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_bgr","title":"_PNG_FORMAT_FLAG_BGR","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_color","title":"_PNG_FORMAT_FLAG_COLOR","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_colormap","title":"_PNG_FORMAT_FLAG_COLORMAP","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_png_format_flag_linear","title":"_PNG_FORMAT_FLAG_LINEAR","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Media.Png/#_check_warning_or_error","title":"_check_warning_or_error","text":"<p>Type: <code>Std::String -&gt; Std::FFI::CInt -&gt; Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Media.Png/#get_message","title":"get_message","text":"<p>Type: <code>Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail Std::String</code></p>"},{"location":"Minilib.Media.Png/#get_warning_or_error","title":"get_warning_or_error","text":"<p>Type: <code>Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail Std::I64</code></p>"},{"location":"Minilib.Media.Png/#make","title":"make","text":"<p>Type: <code>Std::IO::IOFail Minilib.Media.Png::PngImageIO</code></p>"},{"location":"Minilib.Media.Png/#parse_format","title":"parse_format","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Std::I64</code></p>"},{"location":"Minilib.Media.Png/#set_format","title":"set_format","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Media.Png/#set_image_size","title":"set_image_size","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Media.Png/#write_to_file","title":"write_to_file","text":"<p>Type: <code>Std::String -&gt; Std::Bool -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Media.Png/#write_to_memory","title":"write_to_memory","text":"<p>Type: <code>Std::Bool -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; Minilib.Media.Png::PngImageIO -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p>"},{"location":"Minilib.Media.Png/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Media.Png/#namespace-minilibmediapng_1","title":"namespace Minilib.Media.Png","text":""},{"location":"Minilib.Media.Png/#pngimageio","title":"PngImageIO","text":"<p>Defined as: <code>type PngImageIO = unbox struct { ...fields... }</code></p>"},{"location":"Minilib.Media.Png/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::Ptr</code></p>"},{"location":"Minilib.Media.Png/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Media.Png/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Media.Svg/","title":"Minilib.Media.Svg","text":"<p>Defined in minilib-media@0.5.1</p> <p>Scalable Vector Graphics (SVG) 1.1</p> <p>This module uses <code>Minilib.Encoding.Xml</code> to handle XML.</p>"},{"location":"Minilib.Media.Svg/#values","title":"Values","text":""},{"location":"Minilib.Media.Svg/#namespace-minilibmediasvgpathdata","title":"namespace Minilib.Media.Svg::PathData","text":""},{"location":"Minilib.Media.Svg/#_append","title":"_append","text":"<p>Type: <code>Std::String -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p>Appends an string to PathData.</p>"},{"location":"Minilib.Media.Svg/#arcto","title":"arcto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum, b : Minilib.Media.Svg::SvgNum, r : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; r -&gt; b -&gt; b -&gt; a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.arcto(rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y)</code> draws a elliptical arc. Coordinates are absolute. For details, see W3C SVG 1.1: 8.3.8 The elliptical arc curve commands.</p>"},{"location":"Minilib.Media.Svg/#closepath","title":"closepath","text":"<p>Type: <code>Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.closepath</code> ends the current sub-path by connecting it back to its initial point.</p>"},{"location":"Minilib.Media.Svg/#curveto","title":"curveto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.curveto(x1, y1, x2, y2, x, y)</code> draws a cubic B\u00e9zier curve from the current point to <code>(x,y)</code> using <code>(x1,y1)</code> as the control point at the beginning of the curve and <code>(x2,y2)</code> as the control point at the end of the curve. Coordinates are absolute.</p>"},{"location":"Minilib.Media.Svg/#empty","title":"empty","text":"<p>Type: <code>Minilib.Media.Svg::PathData</code></p> <p><code>PathData::empty</code> is an empty PathData.</p>"},{"location":"Minilib.Media.Svg/#lineto","title":"lineto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.lineto(x, y)</code> draws a line from the current point to the given <code>(x,y)</code> coordinates which becomes the new current point. Coordinates are absolute.</p>"},{"location":"Minilib.Media.Svg/#moveto","title":"moveto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.moveto(x, y)</code> starts a new sub-path at the given <code>(x,y)</code> coordinates. Coordinates are absolute.</p>"},{"location":"Minilib.Media.Svg/#newpath","title":"newpath","text":"<p>Type: <code>Minilib.Media.Svg::PathData</code></p> <p>Synonym for <code>PathData::empty</code>.</p>"},{"location":"Minilib.Media.Svg/#quadto","title":"quadto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p><code>pathdata.quadto(x1, y1, x, y)</code> draws a quadratic B\u00e9zier curve from the current point to (x,y) using (x1,y1) as the control point. Coordinates are absolute.</p>"},{"location":"Minilib.Media.Svg/#rlineto","title":"rlineto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p>Same as <code>lineto</code> but coordinates are relative.</p>"},{"location":"Minilib.Media.Svg/#rmoveto","title":"rmoveto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p>Same as <code>moveto</code> but coordinates are relative.</p>"},{"location":"Minilib.Media.Svg/#scurveto","title":"scurveto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p>Shorthand/smooth version of <code>curveto</code>.</p>"},{"location":"Minilib.Media.Svg/#squadto","title":"squadto","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Media.Svg::PathData -&gt; Minilib.Media.Svg::PathData</code></p> <p>Shorthand/smooth version of <code>quadto</code>.</p>"},{"location":"Minilib.Media.Svg/#namespace-minilibmediasvgsvg","title":"namespace Minilib.Media.Svg::Svg","text":""},{"location":"Minilib.Media.Svg/#attr_num","title":"attr_num","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] Std::String -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.attr_num(name, value)</code> sets an attribute of specified name to the element.</p>"},{"location":"Minilib.Media.Svg/#circle","title":"circle","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::circle(cx, cy, r)</code> creates a <code>&lt;circle&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#ellipse","title":"ellipse","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::ellipse(cx, cy, rx, ry)</code> creates an <code>&lt;ellipse&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#fill","title":"fill","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.fill(paint)</code> sets a <code>fill</code> attribute to the element. NOTE: this function may conflict with <code>Array::fill</code>.</p>"},{"location":"Minilib.Media.Svg/#fill_","title":"fill_","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p>Synonym for <code>Svg::fill</code> to avoid conflicts.</p>"},{"location":"Minilib.Media.Svg/#font_family","title":"font_family","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.font_family()</code> sets a <code>font-family</code> attribute to the element.</p>"},{"location":"Minilib.Media.Svg/#font_size","title":"font_size","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.font_size()</code> sets a <code>font-size</code> attribute to the element.</p>"},{"location":"Minilib.Media.Svg/#group","title":"group","text":"<p>Type: <code>Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::group</code> is an empty <code>&lt;g&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#line","title":"line","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::line(x1, y1, x2, y2)</code> creates a <code>&lt;line&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#path","title":"path","text":"<p>Type: <code>Minilib.Media.Svg::PathData -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::path(pathdata)</code> creates a <code>&lt;path&gt;</code> element from a pathdata.</p>"},{"location":"Minilib.Media.Svg/#polygon","title":"polygon","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::polygon(points)</code> creates a <code>&lt;polygon&gt;</code> element. In most cases, <code>points</code> is an array of <code>(x, y)</code>, for example <code>[(x1, y1), (x2, y2), ...]</code>.</p>"},{"location":"Minilib.Media.Svg/#polyline","title":"polyline","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::polyline(points)</code> creates a <code>&lt;polyline&gt;</code> element. In most cases, <code>points</code> is an array of <code>(x, y)</code>, for example <code>[(x1, y1), (x2, y2), ...]</code>.</p>"},{"location":"Minilib.Media.Svg/#rect","title":"rect","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::rect(x, y, width, height)</code> creates a <code>&lt;rect&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#stroke","title":"stroke","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.stroke(paint)</code> sets a <code>stroke</code> attribute to the element.</p>"},{"location":"Minilib.Media.Svg/#stroke_width","title":"stroke_width","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.stroke_width(num)</code> sets a <code>stroke-width</code> attribute to the element.</p>"},{"location":"Minilib.Media.Svg/#svg","title":"svg","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::svg(width, height)</code> creates a <code>&lt;svg&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#text","title":"text","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>Svg::text(content)</code> creates a <code>&lt;text&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#view_box","title":"view_box","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.view_box(min_x, min_y, width, height)</code> sets the <code>viewBox</code> attribute to the element. <code>element</code> must be one of <code>&lt;svg&gt;</code>, <code>&lt;marker&gt;</code>, <code>&lt;pattern&gt;</code>, <code>&lt;symbol&gt;</code>, <code>&lt;view&gt;</code>.</p>"},{"location":"Minilib.Media.Svg/#write_file","title":"write_file","text":"<p>Type: <code>Std::String -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Std::IO::IOFail ()</code></p> <p><code>element.write_file(filepath)</code> writes a SVG file. <code>element</code> must be a <code>&lt;svg&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#xy","title":"xy","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; a -&gt; Minilib.Encoding.Xml::XmlElement -&gt; Minilib.Encoding.Xml::XmlElement</code></p> <p><code>element.xy(x, y)</code> sets <code>x</code> and <code>y</code> attributes to the element.</p>"},{"location":"Minilib.Media.Svg/#namespace-minilibmediasvgsvgnum","title":"namespace Minilib.Media.Svg::SvgNum","text":""},{"location":"Minilib.Media.Svg/#to_attr_value","title":"to_attr_value","text":"<p>Type: <code>[a : Minilib.Media.Svg::SvgNum] a -&gt; Std::String</code></p> <p>Convert to an attribute value of a SVG element.</p>"},{"location":"Minilib.Media.Svg/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Media.Svg/#namespace-minilibmediasvg","title":"namespace Minilib.Media.Svg","text":""},{"location":"Minilib.Media.Svg/#pathdata","title":"PathData","text":"<p>Defined as: <code>type PathData = unbox struct { ...fields... }</code></p> <p>Path data of <code>&lt;path&gt;</code> element.</p>"},{"location":"Minilib.Media.Svg/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Media.Svg/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Media.Svg/#namespace-minilibmediasvg_1","title":"namespace Minilib.Media.Svg","text":""},{"location":"Minilib.Media.Svg/#trait-a-svgnum","title":"trait <code>a : SvgNum</code>","text":"<p>A trait that can be converted to an attribute value of a SVG element. For example, a number, or a list of numbers is an instance of this trait.</p>"},{"location":"Minilib.Media.Svg/#method-to_attr_value","title":"method <code>to_attr_value</code>","text":"<p>Type: <code>a -&gt; Std::String</code></p> <p>Convert to an attribute value of a SVG element.</p>"},{"location":"Minilib.Media.Svg/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Media.Svg/#impl-a-minilibmediasvgsvgnum-a-a-minilibmediasvgsvgnum","title":"impl <code>[a : Minilib.Media.Svg::SvgNum] (a, a) : Minilib.Media.Svg::SvgNum</code>","text":"<p><code>(a, a)</code> is converted to a string <code>a a</code>. For example, <code>(123.45, 100.00)</code> -&gt; <code>\"123.45 100\"</code>.</p>"},{"location":"Minilib.Media.Svg/#impl-a-minilibmediasvgsvgnum-stdarray-a-minilibmediasvgsvgnum","title":"impl <code>[a : Minilib.Media.Svg::SvgNum] Std::Array a : Minilib.Media.Svg::SvgNum</code>","text":"<p>An array is converted to a string by joining elements with <code>\", \"</code>. For example, <code>[(123.45, 100.00), (234.60, 345.70)]</code> -&gt; <code>\"123.45 100, 234.6 345.7\"</code>.</p>"},{"location":"Minilib.Media.Svg/#impl-stdbool-minilibmediasvgsvgnum","title":"impl <code>Std::Bool : Minilib.Media.Svg::SvgNum</code>","text":"<p>Bool is converted to either \"1\" or \"0\". For example, <code>true</code> -&gt; <code>\"1\"</code>, <code>false</code> -&gt; <code>\"0\"</code>.</p>"},{"location":"Minilib.Media.Svg/#impl-stdf64-minilibmediasvgsvgnum","title":"impl <code>Std::F64 : Minilib.Media.Svg::SvgNum</code>","text":"<p>F64 is converted to a decimal string. Trailing zeros and trailing periods are stripped. For example, <code>123.45</code> -&gt; <code>\"123.45\"</code>, <code>100.00</code> -&gt; <code>\"100\"</code>.</p>"},{"location":"Minilib.Media.Svg/#impl-stdi64-minilibmediasvgsvgnum","title":"impl <code>Std::I64 : Minilib.Media.Svg::SvgNum</code>","text":"<p>I64 is converted to a decimal string. For example, <code>100</code> -&gt; <code>\"100\"</code>.</p>"},{"location":"Minilib.Monad.Cont/","title":"Minilib.Monad.Cont","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Continuation Monad.</p>"},{"location":"Minilib.Monad.Cont/#values","title":"Values","text":""},{"location":"Minilib.Monad.Cont/#namespace-minilibmonadcont","title":"namespace Minilib.Monad.Cont","text":""},{"location":"Minilib.Monad.Cont/#cont","title":"cont","text":"<p>Type: <code>((a -&gt; r) -&gt; r) -&gt; Minilib.Monad.Cont::Cont r a</code></p> <p>Creates a Cont monad from a function which receives a continuation function and returns the result value.</p>"},{"location":"Minilib.Monad.Cont/#cont_t","title":"cont_t","text":"<p>Type: <code>[m : Std::Monad] ((a -&gt; m r) -&gt; m r) -&gt; Minilib.Monad.Cont::ContT r m a</code></p> <p>Creates a ContT monad from a function which receives a continuation function and returns the monadic value of the result.</p>"},{"location":"Minilib.Monad.Cont/#lift_cont","title":"lift_cont","text":"<p>Type: <code>[m : Std::Monad] m a -&gt; Minilib.Monad.Cont::ContT r m a</code></p> <p>Deprecated: Please use <code>MonadTrans::lift_t</code>.</p> <p>Lifts an underlying monad to a continuation monad.</p>"},{"location":"Minilib.Monad.Cont/#run_cont","title":"run_cont","text":"<p>Type: <code>(a -&gt; r) -&gt; Minilib.Monad.Cont::Cont r a -&gt; r</code></p> <p>Runs a Cont monad with the supplied continuation function.</p>"},{"location":"Minilib.Monad.Cont/#run_cont_t","title":"run_cont_t","text":"<p>Type: <code>[m : Std::Monad] (a -&gt; m r) -&gt; Minilib.Monad.Cont::ContT r m a -&gt; m r</code></p> <p>Runs a ContT monad with the supplied continuation function.</p>"},{"location":"Minilib.Monad.Cont/#namespace-minilibmonadcontmonadcontif","title":"namespace Minilib.Monad.Cont::MonadContIF","text":""},{"location":"Minilib.Monad.Cont/#call_cc","title":"call_cc","text":"<p>Type: <code>[cm : Minilib.Monad.Cont::MonadContIF] ((a -&gt; cm b) -&gt; cm a) -&gt; cm a</code></p> <p><code>call_cc(f)</code> calls <code>f</code> with the current continuation, and returns a continuation monad. <code>f</code> takes the current continuation (the exit function) and should return a continuation monad. For example, <code>call_cc(|exit| ... if condition { exit(false) }; ... pure(true))</code>. The exit function can be passed to another function.</p>"},{"location":"Minilib.Monad.Cont/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Cont/#namespace-minilibmonadcont_1","title":"namespace Minilib.Monad.Cont","text":""},{"location":"Minilib.Monad.Cont/#cont_1","title":"Cont","text":"<p>Defined as: <code>type Cont r = Minilib.Monad.Cont::ContT r Minilib.Monad.Identity::Identity</code></p> <p>A continuation monad whose undelying monad is Identity.</p>"},{"location":"Minilib.Monad.Cont/#contt","title":"ContT","text":"<p>Defined as: <code>type [m : *-&gt;*] ContT r m a = unbox struct { ...fields... }</code></p> <p>A continuation monad transformer. <code>r</code> is a type of the result of the continuation function. <code>m</code> is a type of an underlyind monad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Monad.Cont/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>(a -&gt; m r) -&gt; m r</code></p>"},{"location":"Minilib.Monad.Cont/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Cont/#namespace-minilibmonadcont_2","title":"namespace Minilib.Monad.Cont","text":""},{"location":"Minilib.Monad.Cont/#trait-cm-cm-monadcontif","title":"trait <code>[cm : *-&gt;*] cm : MonadContIF</code>","text":"<p>A trait for generic continuation  monads.</p>"},{"location":"Minilib.Monad.Cont/#method-call_cc","title":"method <code>call_cc</code>","text":"<p>Type: <code>((a -&gt; cm b) -&gt; cm a) -&gt; cm a</code></p> <p><code>call_cc(f)</code> calls <code>f</code> with the current continuation, and returns a continuation monad. <code>f</code> takes the current continuation (the exit function) and should return a continuation monad. For example, <code>call_cc(|exit| ... if condition { exit(false) }; ... pure(true))</code>. The exit function can be passed to another function.</p>"},{"location":"Minilib.Monad.Cont/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Cont/#impl-minilibmonadcontcontt-r-minilibmonadtransmonadtrans","title":"impl <code>Minilib.Monad.Cont::ContT r : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.Cont/#impl-m-stdmonad-minilibmonadcontcontt-r-m-minilibmonadcontmonadcontif","title":"impl <code>[m : Std::Monad] Minilib.Monad.Cont::ContT r m : Minilib.Monad.Cont::MonadContIF</code>","text":""},{"location":"Minilib.Monad.Cont/#impl-m-stdmonad-minilibmonadcontcontt-r-m-stdfunctor","title":"impl <code>[m : Std::Monad] Minilib.Monad.Cont::ContT r m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Cont/#impl-m-stdmonad-minilibmonadcontcontt-r-m-stdmonad","title":"impl <code>[m : Std::Monad] Minilib.Monad.Cont::ContT r m : Std::Monad</code>","text":""},{"location":"Minilib.Monad.Error/","title":"Minilib.Monad.Error","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Definition of <code>MonadErrorIF</code> trait which can report errors.</p>"},{"location":"Minilib.Monad.Error/#values","title":"Values","text":""},{"location":"Minilib.Monad.Error/#namespace-minilibmonaderror","title":"namespace Minilib.Monad.Error","text":""},{"location":"Minilib.Monad.Error/#from_result_t","title":"from_result_t","text":"<p>Type: <code>[m : Minilib.Monad.Error::MonadError] Std::Result Std::ErrMsg a -&gt; m a</code></p> <p>Synonym of <code>lift_result</code>.</p>"},{"location":"Minilib.Monad.Error/#lift_result","title":"lift_result","text":"<p>Type: <code>[m : Minilib.Monad.Error::MonadError] Std::Result Std::ErrMsg a -&gt; m a</code></p> <p>Lifts an operation result to a monad.</p>"},{"location":"Minilib.Monad.Error/#to_result_t","title":"to_result_t","text":"<p>Type: <code>[m : Minilib.Monad.Error::MonadError] m a -&gt; m (Std::Result Std::ErrMsg a)</code></p> <p>Converts to an operation result.</p>"},{"location":"Minilib.Monad.Error/#namespace-minilibmonaderrormonaderrorif","title":"namespace Minilib.Monad.Error::MonadErrorIF","text":""},{"location":"Minilib.Monad.Error/#catch","title":"catch","text":"<p>Type: <code>[m : Minilib.Monad.Error::MonadErrorIF] (Std::ErrMsg -&gt; m a) -&gt; m a -&gt; m a</code></p> <p><code>ma.catch(handler)</code> catches any error that is thrown during the computation of <code>ma</code>.</p>"},{"location":"Minilib.Monad.Error/#error","title":"error","text":"<p>Type: <code>[m : Minilib.Monad.Error::MonadErrorIF] Std::ErrMsg -&gt; m a</code></p> <p><code>error(e)</code> throws an error.</p>"},{"location":"Minilib.Monad.Error/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Error/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Error/#namespace-minilibmonaderror_1","title":"namespace Minilib.Monad.Error","text":""},{"location":"Minilib.Monad.Error/#trait-m-m-monaderrorif","title":"trait <code>[m : *-&gt;*] m : MonadErrorIF</code>","text":"<p>A trait for monads which can report errors.</p>"},{"location":"Minilib.Monad.Error/#method-error","title":"method <code>error</code>","text":"<p>Type: <code>Std::String -&gt; m a</code></p> <p><code>error(e)</code> throws an error.</p>"},{"location":"Minilib.Monad.Error/#method-catch","title":"method <code>catch</code>","text":"<p>Type: <code>(Std::String -&gt; m a) -&gt; m a -&gt; m a</code></p> <p><code>ma.catch(handler)</code> catches any error that is thrown during the computation of <code>ma</code>.</p>"},{"location":"Minilib.Monad.Error/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Error/#impl-stdioiofail-minilibmonaderrormonaderrorif","title":"impl <code>Std::IO::IOFail : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.Error/#impl-stdresult-stdstring-minilibmonaderrormonaderrorif","title":"impl <code>Std::Result Std::String : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.FreeRandom/","title":"Minilib.Monad.FreeRandom","text":"<p>Defined in minilib-random@0.5.2</p> <p>Free Random Monad.</p>"},{"location":"Minilib.Monad.FreeRandom/#values","title":"Values","text":""},{"location":"Minilib.Monad.FreeRandom/#namespace-minilibmonadfreerandomfreerandom","title":"namespace Minilib.Monad.FreeRandom::FreeRandom","text":""},{"location":"Minilib.Monad.FreeRandom/#interpret","title":"interpret","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Minilib.Monad.FreeRandom::FreeRandom a -&gt; m a</code></p>"},{"location":"Minilib.Monad.FreeRandom/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.FreeRandom/#namespace-minilibmonadfreerandom","title":"namespace Minilib.Monad.FreeRandom","text":""},{"location":"Minilib.Monad.FreeRandom/#freerandom","title":"FreeRandom","text":"<p>Defined as: <code>type FreeRandom a = box union { ...variants... }</code></p> <p>Free Random Monad.</p> <p>This type may be used in a situation such as polymorphic types cannot be used, for example an interface of an API.</p>"},{"location":"Minilib.Monad.FreeRandom/#variant-fr_pure","title":"variant <code>fr_pure</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Monad.FreeRandom/#variant-fr_u64","title":"variant <code>fr_u64</code>","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Monad.FreeRandom::FreeRandom a</code></p>"},{"location":"Minilib.Monad.FreeRandom/#variant-fr_bytes","title":"variant <code>fr_bytes</code>","text":"<p>Type: <code>(Std::I64, Std::Array Std::U8 -&gt; Minilib.Monad.FreeRandom::FreeRandom a)</code></p>"},{"location":"Minilib.Monad.FreeRandom/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.FreeRandom/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.FreeRandom/#impl-minilibmonadfreerandomfreerandom-minilibmonadrandommonadrandomif","title":"impl <code>Minilib.Monad.FreeRandom::FreeRandom : Minilib.Monad.Random::MonadRandomIF</code>","text":""},{"location":"Minilib.Monad.FreeRandom/#impl-minilibmonadfreerandomfreerandom-stdfunctor","title":"impl <code>Minilib.Monad.FreeRandom::FreeRandom : Std::Functor</code>","text":""},{"location":"Minilib.Monad.FreeRandom/#impl-minilibmonadfreerandomfreerandom-stdmonad","title":"impl <code>Minilib.Monad.FreeRandom::FreeRandom : Std::Monad</code>","text":""},{"location":"Minilib.Monad.IO/","title":"Minilib.Monad.IO","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Monadic traits which can lift IO and IOFail monad.</p>"},{"location":"Minilib.Monad.IO/#values","title":"Values","text":""},{"location":"Minilib.Monad.IO/#namespace-minilibmonadiomonadiofailif","title":"namespace Minilib.Monad.IO::MonadIOFailIF","text":""},{"location":"Minilib.Monad.IO/#lift_iofail","title":"lift_iofail","text":"<p>Type: <code>[m : Minilib.Monad.IO::MonadIOFailIF] Std::IO::IOFail a -&gt; m a</code></p>"},{"location":"Minilib.Monad.IO/#namespace-minilibmonadiomonadioif","title":"namespace Minilib.Monad.IO::MonadIOIF","text":""},{"location":"Minilib.Monad.IO/#lift_io","title":"lift_io","text":"<p>Type: <code>[m : Minilib.Monad.IO::MonadIOIF] Std::IO a -&gt; m a</code></p>"},{"location":"Minilib.Monad.IO/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.IO/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.IO/#namespace-minilibmonadio","title":"namespace Minilib.Monad.IO","text":""},{"location":"Minilib.Monad.IO/#trait-m-m-monadiofailif","title":"trait <code>[m : *-&gt;*] m : MonadIOFailIF</code>","text":"<p>An interface of a monadic trait which can lift IOFail monad.</p>"},{"location":"Minilib.Monad.IO/#method-lift_iofail","title":"method <code>lift_iofail</code>","text":"<p>Type: <code>Std::IO::IOFail a -&gt; m a</code></p>"},{"location":"Minilib.Monad.IO/#trait-m-m-monadioif","title":"trait <code>[m : *-&gt;*] m : MonadIOIF</code>","text":"<p>An interface of a monadic trait which can lift IO monad.</p>"},{"location":"Minilib.Monad.IO/#method-lift_io","title":"method <code>lift_io</code>","text":"<p>Type: <code>Std::IO a -&gt; m a</code></p>"},{"location":"Minilib.Monad.IO/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.IO/#impl-stdio-minilibmonadiomonadioif","title":"impl <code>Std::IO : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.IO/#impl-stdioiofail-minilibmonadiomonadiofailif","title":"impl <code>Std::IO::IOFail : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.IO/#impl-stdioiofail-minilibmonadiomonadioif","title":"impl <code>Std::IO::IOFail : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.Identity/","title":"Minilib.Monad.Identity","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Identity monad</p>"},{"location":"Minilib.Monad.Identity/#values","title":"Values","text":""},{"location":"Minilib.Monad.Identity/#namespace-minilibmonadidentity","title":"namespace Minilib.Monad.Identity","text":""},{"location":"Minilib.Monad.Identity/#get","title":"get","text":"<p>Type: <code>Minilib.Monad.Identity::Identity a -&gt; a</code></p> <p>Gets a value from an identity monad.</p>"},{"location":"Minilib.Monad.Identity/#make","title":"make","text":"<p>Type: <code>a -&gt; Minilib.Monad.Identity::Identity a</code></p> <p>Creates an identity monad from a value.</p>"},{"location":"Minilib.Monad.Identity/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Identity/#namespace-minilibmonadidentity_1","title":"namespace Minilib.Monad.Identity","text":""},{"location":"Minilib.Monad.Identity/#identity","title":"Identity","text":"<p>Defined as: <code>type Identity a = unbox struct { ...fields... }</code></p> <p>Identity monad</p>"},{"location":"Minilib.Monad.Identity/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Minilib.Monad.Identity/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Identity/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Identity/#impl-minilibmonadidentityidentity-stdfunctor","title":"impl <code>Minilib.Monad.Identity::Identity : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Identity/#impl-minilibmonadidentityidentity-stdmonad","title":"impl <code>Minilib.Monad.Identity::Identity : Std::Monad</code>","text":""},{"location":"Minilib.Monad.Option/","title":"Minilib.Monad.Option","text":"<p>Defined in minilib-monad@0.5.1</p> <p>A monad transformer that wraps <code>m (Option a)</code>.</p>"},{"location":"Minilib.Monad.Option/#values","title":"Values","text":""},{"location":"Minilib.Monad.Option/#namespace-minilibmonadoption","title":"namespace Minilib.Monad.Option","text":""},{"location":"Minilib.Monad.Option/#lift_option","title":"lift_option","text":"<p>Type: <code>[m : Std::Monad] Std::Option a -&gt; Minilib.Monad.Option::OptionT m a</code></p> <p>Lifts an optional value to an <code>OptionT</code> monad.</p>"},{"location":"Minilib.Monad.Option/#option_t","title":"option_t","text":"<p>Type: <code>m (Std::Option a) -&gt; Minilib.Monad.Option::OptionT m a</code></p> <p>Creates an OptionT monad from an optional value.</p>"},{"location":"Minilib.Monad.Option/#run_option_t","title":"run_option_t","text":"<p>Type: <code>Minilib.Monad.Option::OptionT m a -&gt; m (Std::Option a)</code></p> <p>Gets the optional value.</p>"},{"location":"Minilib.Monad.Option/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Option/#namespace-minilibmonadoption_1","title":"namespace Minilib.Monad.Option","text":""},{"location":"Minilib.Monad.Option/#optiont","title":"OptionT","text":"<p>Defined as: <code>type [m : *-&gt;*] OptionT m a = unbox struct { ...fields... }</code></p> <p>A monad transformer that wraps <code>m (Option a)</code>. This represents an optional value which may or may not exist. <code>m</code> is a type of an underlying monad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Monad.Option/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>m (Std::Option a)</code></p>"},{"location":"Minilib.Monad.Option/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Option/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Option/#impl-minilibmonadoptionoptiont-minilibmonadtransmonadtrans","title":"impl <code>Minilib.Monad.Option::OptionT : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.Option/#impl-m-minilibmonaderrormonaderror-minilibmonadoptionoptiont-m-minilibmonaderrormonaderrorif","title":"impl <code>[m : Minilib.Monad.Error::MonadError] Minilib.Monad.Option::OptionT m : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.Option/#impl-m-minilibmonadiomonadiofail-minilibmonadoptionoptiont-m-minilibmonadiomonadiofailif","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail] Minilib.Monad.Option::OptionT m : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.Option/#impl-m-minilibmonadiomonadio-minilibmonadoptionoptiont-m-minilibmonadiomonadioif","title":"impl <code>[m : Minilib.Monad.IO::MonadIO] Minilib.Monad.Option::OptionT m : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.Option/#impl-m-stdfunctor-minilibmonadoptionoptiont-m-stdfunctor","title":"impl <code>[m : Std::Functor] Minilib.Monad.Option::OptionT m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Option/#impl-m-stdmonad-minilibmonadoptionoptiont-m-stdmonad","title":"impl <code>[m : Std::Monad] Minilib.Monad.Option::OptionT m : Std::Monad</code>","text":""},{"location":"Minilib.Monad.Random/","title":"Minilib.Monad.Random","text":"<p>Defined in minilib-random@0.5.2</p> <p>Random Number Generator Monad</p>"},{"location":"Minilib.Monad.Random/#values","title":"Values","text":""},{"location":"Minilib.Monad.Random/#namespace-minilibmonadrandom","title":"namespace Minilib.Monad.Random","text":""},{"location":"Minilib.Monad.Random/#random_i64_range","title":"random_I64_range","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Std::I64 -&gt; Std::I64 -&gt; m Std::I64</code></p> <p><code>random_I64_range(begin, end)</code> generates a random integer <code>r</code> such that <code>begin &lt;= r &amp;&amp; r &lt; end</code>. if <code>begin &gt;= end</code>, it panicks.</p>"},{"location":"Minilib.Monad.Random/#random_u16","title":"random_U16","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] m Std::U16</code></p> <p><code>random_U16</code> generates a random integer of U8.</p>"},{"location":"Minilib.Monad.Random/#random_u32","title":"random_U32","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] m Std::U32</code></p> <p><code>random_U32</code> generates a random integer of U32.</p>"},{"location":"Minilib.Monad.Random/#random_u8","title":"random_U8","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] m Std::U8</code></p> <p><code>random_U8</code> generates a random integer of U8.</p>"},{"location":"Minilib.Monad.Random/#random_array","title":"random_array","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Std::I64 -&gt; m a -&gt; m (Std::Array a)</code></p> <p><code>random_array(size, random)</code> generates a random array of specified size by performing <code>random</code> repeatedly.</p>"},{"location":"Minilib.Monad.Random/#shuffle","title":"shuffle","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandom] Std::Array a -&gt; m (Std::Array a)</code></p> <p>Shuffles an array.</p>"},{"location":"Minilib.Monad.Random/#namespace-minilibmonadrandommonadrandomif","title":"namespace Minilib.Monad.Random::MonadRandomIF","text":""},{"location":"Minilib.Monad.Random/#random_u64","title":"random_U64","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandomIF] m Std::U64</code></p> <p><code>random_U64</code> generates a random integer of U64.</p>"},{"location":"Minilib.Monad.Random/#random_bytes","title":"random_bytes","text":"<p>Type: <code>[m : Minilib.Monad.Random::MonadRandomIF] Std::I64 -&gt; m (Std::Array Std::U8)</code></p> <p><code>random_bytes</code> generates random bytes of specified size.</p>"},{"location":"Minilib.Monad.Random/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Random/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Random/#namespace-minilibmonadrandom_1","title":"namespace Minilib.Monad.Random","text":""},{"location":"Minilib.Monad.Random/#trait-m-m-monadrandomif","title":"trait <code>[m : *-&gt;*] m : MonadRandomIF</code>","text":"<p>A trait for a monad that generates random numbers every time.</p>"},{"location":"Minilib.Monad.Random/#method-random_u64","title":"method <code>random_U64</code>","text":"<p>Type: <code>m Std::U64</code></p> <p><code>random_U64</code> generates a random integer of U64.</p>"},{"location":"Minilib.Monad.Random/#method-random_bytes","title":"method <code>random_bytes</code>","text":"<p>Type: <code>Std::I64 -&gt; m (Std::Array Std::U8)</code></p> <p><code>random_bytes</code> generates random bytes of specified size.</p>"},{"location":"Minilib.Monad.Random/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Random/#impl-rg-minilibtraitrngrng-lf1-minilibtraitlifterlifter-lf2-minilibtraitlifterlifter-m-stdmonad-minilibmonadstatestatet-rg-m-minilibmonadrandommonadrandomif","title":"impl <code>[rg : Minilib.Trait.Rng::Rng, lf1 : Minilib.Trait.Lifter::Lifter, lf2 : Minilib.Trait.Lifter::Lifter, m : Std::Monad] Minilib.Monad.State::StateT rg m : Minilib.Monad.Random::MonadRandomIF</code>","text":"<p>An implementation of <code>MonadRandomIF</code> for the <code>StateT</code> monad.</p> <p>A state monad <code>StateT rg m</code> can be used as a <code>MonadRandom</code>, if the state <code>rg</code> implements <code>Rng</code> trait, and the target monad <code>m</code> is compatible to <code>RngResult</code>. The result type of <code>Rng</code> is lifted to the target monad <code>m</code> by the lifter.</p>"},{"location":"Minilib.Monad.Reader/","title":"Minilib.Monad.Reader","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Reader monad.</p> <p>For details, see blog post: The Reader and Writer Monads and Comonads.</p>"},{"location":"Minilib.Monad.Reader/#values","title":"Values","text":""},{"location":"Minilib.Monad.Reader/#namespace-minilibmonadreader","title":"namespace Minilib.Monad.Reader","text":""},{"location":"Minilib.Monad.Reader/#map_reader_t","title":"map_reader_t","text":"<p>Type: <code>[m : Std::Monad, n : Std::Monad] (m a -&gt; n b) -&gt; Minilib.Monad.Reader::ReaderT e m a -&gt; Minilib.Monad.Reader::ReaderT e n b</code></p> <p>Maps an underlying monad and a value using the specified function.</p>"},{"location":"Minilib.Monad.Reader/#read","title":"read","text":"<p>Type: <code>[m : Std::Monad] Minilib.Monad.Reader::ReaderT e m e</code></p> <p>A reader monad that returns the environment as a value.</p>"},{"location":"Minilib.Monad.Reader/#reader","title":"reader","text":"<p>Type: <code>(e -&gt; a) -&gt; Minilib.Monad.Reader::Reader e a</code></p> <p>Creates a reader monad from a function.</p>"},{"location":"Minilib.Monad.Reader/#reader_t","title":"reader_t","text":"<p>Type: <code>[m : Std::Monad] (e -&gt; m a) -&gt; Minilib.Monad.Reader::ReaderT e m a</code></p> <p>Creates a generic reader monad from a function.</p>"},{"location":"Minilib.Monad.Reader/#run_reader","title":"run_reader","text":"<p>Type: <code>e -&gt; Minilib.Monad.Reader::Reader e a -&gt; a</code></p> <p>Runs a reader monad with the supplied environment.</p>"},{"location":"Minilib.Monad.Reader/#run_reader_t","title":"run_reader_t","text":"<p>Type: <code>[m : Std::Monad] e -&gt; Minilib.Monad.Reader::ReaderT e m a -&gt; m a</code></p> <p>Runs a generic reader monad with the supplied environment.</p>"},{"location":"Minilib.Monad.Reader/#with_reader_t","title":"with_reader_t","text":"<p>Type: <code>[m : Std::Monad] (e1 -&gt; e) -&gt; Minilib.Monad.Reader::ReaderT e m a -&gt; Minilib.Monad.Reader::ReaderT e1 m a</code></p> <p>Creates a reader monad with the modified environment.</p>"},{"location":"Minilib.Monad.Reader/#namespace-minilibmonadreadermonadreaderif","title":"namespace Minilib.Monad.Reader::MonadReaderIF","text":""},{"location":"Minilib.Monad.Reader/#ask","title":"ask","text":"<p>Type: <code>[rm : Minilib.Monad.Reader::MonadReaderIF] rm (Minilib.Monad.Reader::MonadReaderIF::EnvType rm)</code></p> <p>A monad that returns the internal environment as a value.</p>"},{"location":"Minilib.Monad.Reader/#local","title":"local","text":"<p>Type: <code>[rm : Minilib.Monad.Reader::MonadReaderIF] (Minilib.Monad.Reader::MonadReaderIF::EnvType rm -&gt; Minilib.Monad.Reader::MonadReaderIF::EnvType rm) -&gt; rm a -&gt; rm a</code></p> <p><code>rm.local(f)</code> creates a reader monad with an environment modified by <code>f</code>.</p>"},{"location":"Minilib.Monad.Reader/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Reader/#namespace-minilibmonadreader_1","title":"namespace Minilib.Monad.Reader","text":""},{"location":"Minilib.Monad.Reader/#reader_1","title":"Reader","text":"<p>Defined as: <code>type Reader e = Minilib.Monad.Reader::ReaderT e Minilib.Monad.Identity::Identity</code></p>"},{"location":"Minilib.Monad.Reader/#readert","title":"ReaderT","text":"<p>Defined as: <code>type [m : *-&gt;*] ReaderT e m a = unbox struct { ...fields... }</code></p> <p>Reader monad wraps a function from an environment to a value. <code>e</code> is a type of an environment. <code>m</code> is a type of an underlyind monad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Monad.Reader/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>e -&gt; m a</code></p>"},{"location":"Minilib.Monad.Reader/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Reader/#namespace-minilibmonadreader_2","title":"namespace Minilib.Monad.Reader","text":""},{"location":"Minilib.Monad.Reader/#trait-rm-rm-monadreaderif","title":"trait <code>[rm : *-&gt;*] rm : MonadReaderIF</code>","text":"<p>A trait for generic reader monads that manages the internal environment.</p>"},{"location":"Minilib.Monad.Reader/#type-envtype","title":"type <code>EnvType</code>","text":"<p>Defined as: <code>EnvType rm</code></p> <p>The type of the internal environment.</p>"},{"location":"Minilib.Monad.Reader/#method-ask","title":"method <code>ask</code>","text":"<p>Type: <code>rm (Minilib.Monad.Reader::MonadReaderIF::EnvType rm)</code></p> <p>A monad that returns the internal environment as a value.</p>"},{"location":"Minilib.Monad.Reader/#method-local","title":"method <code>local</code>","text":"<p>Type: <code>(Minilib.Monad.Reader::MonadReaderIF::EnvType rm -&gt; Minilib.Monad.Reader::MonadReaderIF::EnvType rm) -&gt; rm a -&gt; rm a</code></p> <p><code>rm.local(f)</code> creates a reader monad with an environment modified by <code>f</code>.</p>"},{"location":"Minilib.Monad.Reader/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Reader/#impl-minilibmonadreaderreadert-e-minilibmonadtransmonadtrans","title":"impl <code>Minilib.Monad.Reader::ReaderT e : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-minilibmonaderrormonaderror-minilibmonadreaderreadert-e-m-minilibmonaderrormonaderrorif","title":"impl <code>[m : Minilib.Monad.Error::MonadError] Minilib.Monad.Reader::ReaderT e m : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-minilibmonadiomonadiofail-minilibmonadreaderreadert-e-m-minilibmonadiomonadiofailif","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail] Minilib.Monad.Reader::ReaderT e m : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-minilibmonadiomonadio-minilibmonadreaderreadert-e-m-minilibmonadiomonadioif","title":"impl <code>[m : Minilib.Monad.IO::MonadIO] Minilib.Monad.Reader::ReaderT e m : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-stdmonad-minilibmonadreaderreadert-e-m-minilibmonadreadermonadreaderif","title":"impl <code>[m : Std::Monad] Minilib.Monad.Reader::ReaderT e m : Minilib.Monad.Reader::MonadReaderIF</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-stdmonad-minilibmonadreaderreadert-e-m-stdfunctor","title":"impl <code>[m : Std::Monad] Minilib.Monad.Reader::ReaderT e m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Reader/#impl-m-stdmonad-minilibmonadreaderreadert-e-m-stdmonad","title":"impl <code>[m : Std::Monad] Minilib.Monad.Reader::ReaderT e m : Std::Monad</code>","text":""},{"location":"Minilib.Monad.Result/","title":"Minilib.Monad.Result","text":"<p>Defined in minilib-monad@0.5.1</p> <p>A monad transformer that wraps <code>m (Result e a)</code>.</p>"},{"location":"Minilib.Monad.Result/#values","title":"Values","text":""},{"location":"Minilib.Monad.Result/#namespace-minilibmonadresult","title":"namespace Minilib.Monad.Result","text":""},{"location":"Minilib.Monad.Result/#result_t","title":"result_t","text":"<p>Type: <code>m (Std::Result e a) -&gt; Minilib.Monad.Result::ResultT e m a</code></p> <p>Creates a ResultT monad from an operation result.</p>"},{"location":"Minilib.Monad.Result/#run_result_t","title":"run_result_t","text":"<p>Type: <code>Minilib.Monad.Result::ResultT e m a -&gt; m (Std::Result e a)</code></p> <p>Gets the operation result.</p>"},{"location":"Minilib.Monad.Result/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Result/#namespace-minilibmonadresult_1","title":"namespace Minilib.Monad.Result","text":""},{"location":"Minilib.Monad.Result/#resultt","title":"ResultT","text":"<p>Defined as: <code>type [m : *-&gt;*] ResultT e m a = unbox struct { ...fields... }</code></p> <p>A monad transformer that wraps <code>m (Result e a)</code>. This represents an operation result (success or error). <code>e</code> is a type of an error if the operation fails. <code>m</code> is a type of an underlying monad. <code>a</code> is a type of an operation result if operation is successful.</p>"},{"location":"Minilib.Monad.Result/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>m (Std::Result e a)</code></p>"},{"location":"Minilib.Monad.Result/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Result/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Result/#impl-m-stdmonad-minilibmonadresultresultt-stdstring-m-minilibmonaderrormonaderrorif","title":"impl <code>[m : Std::Monad] Minilib.Monad.Result::ResultT Std::String m : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.Result/#impl-minilibmonadresultresultt-e-minilibmonadtransmonadtrans","title":"impl <code>Minilib.Monad.Result::ResultT e : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.Result/#impl-m-minilibmonadiomonadiofail-minilibmonadresultresultt-e-m-minilibmonadiomonadiofailif","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail] Minilib.Monad.Result::ResultT e m : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.Result/#impl-m-minilibmonadiomonadio-minilibmonadresultresultt-e-m-minilibmonadiomonadioif","title":"impl <code>[m : Minilib.Monad.IO::MonadIO] Minilib.Monad.Result::ResultT e m : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.Result/#impl-m-stdfunctor-minilibmonadresultresultt-e-m-stdfunctor","title":"impl <code>[m : Std::Functor] Minilib.Monad.Result::ResultT e m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Result/#impl-m-stdmonad-minilibmonadresultresultt-e-m-stdmonad","title":"impl <code>[m : Std::Monad] Minilib.Monad.Result::ResultT e m : Std::Monad</code>","text":""},{"location":"Minilib.Monad.State/","title":"Minilib.Monad.State","text":"<p>Defined in minilib-monad@0.5.1</p> <p>State Monad which maintains a mutable state.</p>"},{"location":"Minilib.Monad.State/#values","title":"Values","text":""},{"location":"Minilib.Monad.State/#namespace-minilibmonadstate","title":"namespace Minilib.Monad.State","text":""},{"location":"Minilib.Monad.State/#eval_state","title":"eval_state","text":"<p>Type: <code>s -&gt; Minilib.Monad.State::State s a -&gt; a</code></p> <p>Runs a State monad with the supplied initial state and return the final value, discarding the final state.</p>"},{"location":"Minilib.Monad.State/#eval_state_t","title":"eval_state_t","text":"<p>Type: <code>[m : Std::Monad] s -&gt; Minilib.Monad.State::StateT s m a -&gt; m a</code></p> <p>Runs a StateT monad with the supplied initial state and return the final value, discarding the final state.</p>"},{"location":"Minilib.Monad.State/#exec_state","title":"exec_state","text":"<p>Type: <code>s -&gt; Minilib.Monad.State::State s a -&gt; s</code></p> <p>Runs a State monad with the supplied initial state and return the final state, discarding the final value.</p>"},{"location":"Minilib.Monad.State/#exec_state_t","title":"exec_state_t","text":"<p>Type: <code>[m : Std::Monad] s -&gt; Minilib.Monad.State::StateT s m a -&gt; m s</code></p> <p>Runs a StateT monad with the supplied initial state and return the final state, discarding the final value.</p>"},{"location":"Minilib.Monad.State/#lens_state","title":"lens_state","text":"<p>Type: <code>((s -&gt; Minilib.Functor.Pair::PairLT a Minilib.Monad.Identity::Identity s) -&gt; t -&gt; Minilib.Functor.Pair::PairLT a Minilib.Monad.Identity::Identity t) -&gt; Minilib.Monad.State::State s a -&gt; Minilib.Monad.State::State t a</code></p>"},{"location":"Minilib.Monad.State/#lens_state_t","title":"lens_state_t","text":"<p>Type: <code>[m : Std::Monad, m : Std::Functor] ((s -&gt; Minilib.Functor.Pair::PairLT a m s) -&gt; t -&gt; Minilib.Functor.Pair::PairLT a m t) -&gt; Minilib.Monad.State::StateT s m a -&gt; Minilib.Monad.State::StateT t m a</code></p> <p>Transforms a state monad with a lens action. For example, if <code>Foo</code> has a field <code>bar: Bar</code>, then <code>act_bar</code> is a function of type <code>[f: Functor] (Bar -&gt; f Bar) -&gt; (Foo -&gt; f Foo)</code>. Using <code>act_bar</code>, a state monad of <code>Bar</code> can be transformed to a state monad of <code>Foo</code>.</p> <pre><code>change_bar: StateT Bar IO ();\nchange_bar = ...;\nchange_foo: StateT Foo IO ();\nchange_foo = change_bar.lens_state_t(Foo::act_bar);\n</code></pre> <p>Note that <code>act_xxx</code> can be composed, for example <code>Foo::act_bar &lt;&lt; Bar::act_baz &lt;&lt; Baz::act_qux</code>.</p>"},{"location":"Minilib.Monad.State/#make_state_monad","title":"make_state_monad","text":"<p>Type: <code>(s -&gt; (s, a)) -&gt; Minilib.Monad.State::State s a</code></p> <p>Creates a State monad from a function.</p>"},{"location":"Minilib.Monad.State/#make_state_t_monad","title":"make_state_t_monad","text":"<p>Type: <code>[m : Std::Monad] (s -&gt; m (s, a)) -&gt; Minilib.Monad.State::StateT s m a</code></p> <p>Creates a StateT monad from a function.</p>"},{"location":"Minilib.Monad.State/#map_state_t","title":"map_state_t","text":"<p>Type: <code>[m : Std::Monad, n : Std::Monad] (m (s, a) -&gt; n (s, b)) -&gt; Minilib.Monad.State::StateT s m a -&gt; Minilib.Monad.State::StateT s n b</code></p> <p>Maps both the return value and final state.</p>"},{"location":"Minilib.Monad.State/#mod_state","title":"mod_state","text":"<p>Type: <code>[sm : Minilib.Monad.State::MonadState] (Minilib.Monad.State::MonadStateIF::StateType sm -&gt; Minilib.Monad.State::MonadStateIF::StateType sm) -&gt; sm ()</code></p> <p>A monad that modifies the current state with the specified function.</p>"},{"location":"Minilib.Monad.State/#run_state","title":"run_state","text":"<p>Type: <code>s -&gt; Minilib.Monad.State::State s a -&gt; (s, a)</code></p> <p>Runs a State monad with the supplied initial state.</p>"},{"location":"Minilib.Monad.State/#run_state_t","title":"run_state_t","text":"<p>Type: <code>[m : Std::Monad] s -&gt; Minilib.Monad.State::StateT s m a -&gt; m (s, a)</code></p> <p>Runs a StateT monad with the supplied initial state.</p>"},{"location":"Minilib.Monad.State/#state","title":"state","text":"<p>Type: <code>(s -&gt; (s, a)) -&gt; Minilib.Monad.State::State s a</code></p> <p>Synonym of <code>make_state_monad</code>.</p>"},{"location":"Minilib.Monad.State/#state_t","title":"state_t","text":"<p>Type: <code>[m : Std::Monad] (s -&gt; m (s, a)) -&gt; Minilib.Monad.State::StateT s m a</code></p> <p>Synonym of <code>make_state_t_monad</code>.</p>"},{"location":"Minilib.Monad.State/#namespace-minilibmonadstatemonadstateif","title":"namespace Minilib.Monad.State::MonadStateIF","text":""},{"location":"Minilib.Monad.State/#get_state","title":"get_state","text":"<p>Type: <code>[sm : Minilib.Monad.State::MonadStateIF] sm (Minilib.Monad.State::MonadStateIF::StateType sm)</code></p> <p>A monad that returns the internal state as a value.</p>"},{"location":"Minilib.Monad.State/#put_state","title":"put_state","text":"<p>Type: <code>[sm : Minilib.Monad.State::MonadStateIF] Minilib.Monad.State::MonadStateIF::StateType sm -&gt; sm ()</code></p> <p>A monad that puts the specified value to the internal state.</p>"},{"location":"Minilib.Monad.State/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.State/#namespace-minilibmonadstate_1","title":"namespace Minilib.Monad.State","text":""},{"location":"Minilib.Monad.State/#state_1","title":"State","text":"<p>Defined as: <code>type State s = Minilib.Monad.State::StateT s Minilib.Monad.Identity::Identity</code></p>"},{"location":"Minilib.Monad.State/#statet","title":"StateT","text":"<p>Defined as: <code>type [m : *-&gt;*] StateT s m a = unbox struct { ...fields... }</code></p> <p>State monad wraps a function from a initial state to a pair of a value and a final state.</p>"},{"location":"Minilib.Monad.State/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>s -&gt; m (s, a)</code></p>"},{"location":"Minilib.Monad.State/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.State/#namespace-minilibmonadstate_2","title":"namespace Minilib.Monad.State","text":""},{"location":"Minilib.Monad.State/#trait-sm-sm-monadstateif","title":"trait <code>[sm : *-&gt;*] sm : MonadStateIF</code>","text":"<p>A trait for generic state monads that manages the internal state.</p>"},{"location":"Minilib.Monad.State/#type-statetype","title":"type <code>StateType</code>","text":"<p>Defined as: <code>StateType sm</code></p> <p>The type of the internal state.</p>"},{"location":"Minilib.Monad.State/#method-get_state","title":"method <code>get_state</code>","text":"<p>Type: <code>sm (Minilib.Monad.State::MonadStateIF::StateType sm)</code></p> <p>A monad that returns the internal state as a value.</p>"},{"location":"Minilib.Monad.State/#method-put_state","title":"method <code>put_state</code>","text":"<p>Type: <code>Minilib.Monad.State::MonadStateIF::StateType sm -&gt; sm ()</code></p> <p>A monad that puts the specified value to the internal state.</p>"},{"location":"Minilib.Monad.State/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.State/#impl-minilibmonadstatestatet-s-minilibmonadtransmonadtrans","title":"impl <code>Minilib.Monad.State::StateT s : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-minilibmonaderrormonaderror-minilibmonadstatestatet-s-m-minilibmonaderrormonaderrorif","title":"impl <code>[m : Minilib.Monad.Error::MonadError] Minilib.Monad.State::StateT s m : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-minilibmonadiomonadiofail-minilibmonadstatestatet-s-m-minilibmonadiomonadiofailif","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail] Minilib.Monad.State::StateT s m : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-minilibmonadiomonadio-minilibmonadstatestatet-s-m-minilibmonadiomonadioif","title":"impl <code>[m : Minilib.Monad.IO::MonadIO] Minilib.Monad.State::StateT s m : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-stdmonad-minilibmonadstatestatet-s-m-minilibmonadstatemonadstateif","title":"impl <code>[m : Std::Monad] Minilib.Monad.State::StateT s m : Minilib.Monad.State::MonadStateIF</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-stdmonad-minilibmonadstatestatet-s-m-stdfunctor","title":"impl <code>[m : Std::Monad] Minilib.Monad.State::StateT s m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.State/#impl-m-stdmonad-minilibmonadstatestatet-s-m-stdmonad","title":"impl <code>[m : Std::Monad] Minilib.Monad.State::StateT s m : Std::Monad</code>","text":""},{"location":"Minilib.Monad.Trans/","title":"Minilib.Monad.Trans","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Trait for a monad transformer.</p>"},{"location":"Minilib.Monad.Trans/#values","title":"Values","text":""},{"location":"Minilib.Monad.Trans/#namespace-minilibmonadtransmonadtrans","title":"namespace Minilib.Monad.Trans::MonadTrans","text":""},{"location":"Minilib.Monad.Trans/#lift_t","title":"lift_t","text":"<p>Type: <code>[t : Minilib.Monad.Trans::MonadTrans, m : Std::Monad] m a -&gt; t m a</code></p> <p>Lifts an underlying monad to a transformed monad.</p>"},{"location":"Minilib.Monad.Trans/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Trans/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Trans/#namespace-minilibmonadtrans","title":"namespace Minilib.Monad.Trans","text":""},{"location":"Minilib.Monad.Trans/#trait-t-t-monadtrans","title":"trait <code>[t : (*-&gt;*)-&gt;*-&gt;*] t : MonadTrans</code>","text":"<p>Trait for a monad transformer.</p>"},{"location":"Minilib.Monad.Trans/#method-lift_t","title":"method <code>lift_t</code>","text":"<p>Type: <code>[m : Std::Monad] m a -&gt; t m a</code></p> <p>Lifts an underlying monad to a transformed monad.</p>"},{"location":"Minilib.Monad.Trans/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Writer/","title":"Minilib.Monad.Writer","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Writer monad.</p> <p>For details, see blog post: The Reader and Writer Monads and Comonads.</p>"},{"location":"Minilib.Monad.Writer/#values","title":"Values","text":""},{"location":"Minilib.Monad.Writer/#namespace-minilibmonadwriter","title":"namespace Minilib.Monad.Writer","text":""},{"location":"Minilib.Monad.Writer/#get_env","title":"get_env","text":"<p>Type: <code>Minilib.Monad.Writer::Writer e a -&gt; e</code></p> <p>Gets the envirionment from a writer monad.</p>"},{"location":"Minilib.Monad.Writer/#get_env_t","title":"get_env_t","text":"<p>Type: <code>[m : Std::Monad] Minilib.Monad.Writer::WriterT e m a -&gt; m e</code></p> <p>Gets the envirionment from a generic writer monad.</p>"},{"location":"Minilib.Monad.Writer/#get_value","title":"get_value","text":"<p>Type: <code>Minilib.Monad.Writer::Writer e a -&gt; a</code></p> <p>Gets the value from a writer monad.</p>"},{"location":"Minilib.Monad.Writer/#get_value_t","title":"get_value_t","text":"<p>Type: <code>[m : Std::Monad] Minilib.Monad.Writer::WriterT e m a -&gt; m a</code></p> <p>Gets the value from a generic writer monad.</p>"},{"location":"Minilib.Monad.Writer/#map_writer_t","title":"map_writer_t","text":"<p>Type: <code>[m : Std::Monad, n : Std::Monad] (m (e, a) -&gt; n (e1, b)) -&gt; Minilib.Monad.Writer::WriterT e m a -&gt; Minilib.Monad.Writer::WriterT e1 n b</code></p> <p>Maps an underlying monad and a value using the specified function.</p>"},{"location":"Minilib.Monad.Writer/#run_writer","title":"run_writer","text":"<p>Type: <code>Minilib.Monad.Writer::Writer e a -&gt; (e, a)</code></p> <p>Runs a writer monad to get an enviroment and a value.</p>"},{"location":"Minilib.Monad.Writer/#run_writer_t","title":"run_writer_t","text":"<p>Type: <code>[m : Std::Monad] Minilib.Monad.Writer::WriterT e m a -&gt; m (e, a)</code></p> <p>Runs a generic writer monad to get an enviroment and a value.</p>"},{"location":"Minilib.Monad.Writer/#write","title":"write","text":"<p>Type: <code>[e : Minilib.Trait.Monoid::Monoid, m : Std::Monad] e -&gt; Minilib.Monad.Writer::WriterT e m ()</code></p> <p>Creates a writer monad that appends to the environment.</p>"},{"location":"Minilib.Monad.Writer/#writer","title":"writer","text":"<p>Type: <code>e -&gt; a -&gt; Minilib.Monad.Writer::Writer e a</code></p> <p>Creates a writer monad from an enviroment and a value.</p>"},{"location":"Minilib.Monad.Writer/#writer_t","title":"writer_t","text":"<p>Type: <code>[m : Std::Monad] m (e, a) -&gt; Minilib.Monad.Writer::WriterT e m a</code></p> <p>Creates a generic writer monad from an enviroment and a value.</p>"},{"location":"Minilib.Monad.Writer/#namespace-minilibmonadwritermonadwriterif","title":"namespace Minilib.Monad.Writer::MonadWriterIF","text":""},{"location":"Minilib.Monad.Writer/#listen","title":"listen","text":"<p>Type: <code>[wm : Minilib.Monad.Writer::MonadWriterIF] wm a -&gt; wm (Minilib.Monad.Writer::MonadWriterIF::EnvType wm, a)</code></p> <p>Listens the internal environment.</p>"},{"location":"Minilib.Monad.Writer/#pass","title":"pass","text":"<p>Type: <code>[wm : Minilib.Monad.Writer::MonadWriterIF] wm (Minilib.Monad.Writer::MonadWriterIF::EnvType wm -&gt; Minilib.Monad.Writer::MonadWriterIF::EnvType wm, a) -&gt; wm a</code></p> <p>Provide a writer transformer which changes internals of the written object.</p>"},{"location":"Minilib.Monad.Writer/#tell","title":"tell","text":"<p>Type: <code>[wm : Minilib.Monad.Writer::MonadWriterIF] Minilib.Monad.Writer::MonadWriterIF::EnvType wm -&gt; wm ()</code></p> <p>Tells specified value to the internal environment.</p>"},{"location":"Minilib.Monad.Writer/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Monad.Writer/#namespace-minilibmonadwriter_1","title":"namespace Minilib.Monad.Writer","text":""},{"location":"Minilib.Monad.Writer/#writer_1","title":"Writer","text":"<p>Defined as: <code>type Writer e = Minilib.Monad.Writer::WriterT e Minilib.Monad.Identity::Identity</code></p>"},{"location":"Minilib.Monad.Writer/#writert","title":"WriterT","text":"<p>Defined as: <code>type [m : *-&gt;*] WriterT e m a = unbox struct { ...fields... }</code></p> <p>Writer monad wraps a pair of an environment and a value. <code>e</code> is a type of an environment. <code>m</code> is a type of an underlyind monad. <code>a</code> is a type of a value.</p>"},{"location":"Minilib.Monad.Writer/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>m (e, a)</code></p>"},{"location":"Minilib.Monad.Writer/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Monad.Writer/#namespace-minilibmonadwriter_2","title":"namespace Minilib.Monad.Writer","text":""},{"location":"Minilib.Monad.Writer/#trait-wm-wm-monadwriterif","title":"trait <code>[wm : *-&gt;*] wm : MonadWriterIF</code>","text":"<p>A trait for generic writer monads that manages the internal environment.</p>"},{"location":"Minilib.Monad.Writer/#type-envtype","title":"type <code>EnvType</code>","text":"<p>Defined as: <code>EnvType wm</code></p> <p>The type of the environment.</p>"},{"location":"Minilib.Monad.Writer/#method-tell","title":"method <code>tell</code>","text":"<p>Type: <code>Minilib.Monad.Writer::MonadWriterIF::EnvType wm -&gt; wm ()</code></p> <p>Tells specified value to the internal environment.</p>"},{"location":"Minilib.Monad.Writer/#method-listen","title":"method <code>listen</code>","text":"<p>Type: <code>wm a -&gt; wm (Minilib.Monad.Writer::MonadWriterIF::EnvType wm, a)</code></p> <p>Listens the internal environment.</p>"},{"location":"Minilib.Monad.Writer/#method-pass","title":"method <code>pass</code>","text":"<p>Type: <code>wm (Minilib.Monad.Writer::MonadWriterIF::EnvType wm -&gt; Minilib.Monad.Writer::MonadWriterIF::EnvType wm, a) -&gt; wm a</code></p> <p>Provide a writer transformer which changes internals of the written object.</p>"},{"location":"Minilib.Monad.Writer/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Monad.Writer/#impl-e-minilibtraitmonoidmonoid-minilibmonadwriterwritert-e-minilibmonadtransmonadtrans","title":"impl <code>[e : Minilib.Trait.Monoid::Monoid] Minilib.Monad.Writer::WriterT e : Minilib.Monad.Trans::MonadTrans</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-e-minilibtraitmonoidmonoid-m-minilibmonaderrormonaderror-minilibmonadwriterwritert-e-m-minilibmonaderrormonaderrorif","title":"impl <code>[e : Minilib.Trait.Monoid::Monoid, m : Minilib.Monad.Error::MonadError] Minilib.Monad.Writer::WriterT e m : Minilib.Monad.Error::MonadErrorIF</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-m-minilibmonadiomonadiofail-e-minilibtraitmonoidmonoid-minilibmonadwriterwritert-e-m-minilibmonadiomonadiofailif","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail, e : Minilib.Trait.Monoid::Monoid] Minilib.Monad.Writer::WriterT e m : Minilib.Monad.IO::MonadIOFailIF</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-m-minilibmonadiomonadio-e-minilibtraitmonoidmonoid-minilibmonadwriterwritert-e-m-minilibmonadiomonadioif","title":"impl <code>[m : Minilib.Monad.IO::MonadIO, e : Minilib.Trait.Monoid::Monoid] Minilib.Monad.Writer::WriterT e m : Minilib.Monad.IO::MonadIOIF</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-e-minilibtraitmonoidmonoid-m-stdmonad-minilibmonadwriterwritert-e-m-minilibmonadwritermonadwriterif","title":"impl <code>[e : Minilib.Trait.Monoid::Monoid, m : Std::Monad] Minilib.Monad.Writer::WriterT e m : Minilib.Monad.Writer::MonadWriterIF</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-m-stdmonad-minilibmonadwriterwritert-e-m-stdfunctor","title":"impl <code>[m : Std::Monad] Minilib.Monad.Writer::WriterT e m : Std::Functor</code>","text":""},{"location":"Minilib.Monad.Writer/#impl-e-minilibtraitmonoidmonoid-m-stdmonad-minilibmonadwriterwritert-e-m-stdmonad","title":"impl <code>[e : Minilib.Trait.Monoid::Monoid, m : Std::Monad] Minilib.Monad.Writer::WriterT e m : Std::Monad</code>","text":""},{"location":"Minilib.Net.HTML/","title":"Minilib.Net.HTML","text":"<p>Defined in minilib-net@0.5.1</p> <p>Simple HTML DOM model, as well as escaping/unescaping HTML special characters.</p>"},{"location":"Minilib.Net.HTML/#values","title":"Values","text":""},{"location":"Minilib.Net.HTML/#namespace-minilibnethtmlhtml","title":"namespace Minilib.Net.HTML::HTML","text":""},{"location":"Minilib.Net.HTML/#body","title":"body","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;body&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#button","title":"button","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;button&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#div","title":"div","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;div&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#div_","title":"div_","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>to avoid ambiguity with Std::Div::div</p>"},{"location":"Minilib.Net.HTML/#h1","title":"h1","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;h1&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#h2","title":"h2","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;h2&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#h3","title":"h3","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;h3&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#h4","title":"h4","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;h4&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#h5","title":"h5","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;h5&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#head","title":"head","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;head&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#html","title":"html","text":"<p>Type: <code>Minilib.Net.HTML::HTMLDocument</code></p> <p>An empty HTML document.</p>"},{"location":"Minilib.Net.HTML/#input","title":"input","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;input&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#meta","title":"meta","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;meta&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#p","title":"p","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;p&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#script","title":"script","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;script&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#span","title":"span","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;span&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#table","title":"table","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;table&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#td","title":"td","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;td&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#th","title":"th","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;th&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#title","title":"title","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;title&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#tr","title":"tr","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p> <p>An empty <code>&lt;tr&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#namespace-minilibnethtmlhtmlattribute","title":"namespace Minilib.Net.HTML::HTMLAttribute","text":""},{"location":"Minilib.Net.HTML/#_output_html","title":"_output_html","text":"<p>Type: <code>Std::Array Std::String -&gt; Std::Iterator::DynIterator Minilib.Net.HTML::HTMLAttribute -&gt; Std::Array Std::String</code></p> <p><code>attrs._output_html</code> output the attributes as HTML string.</p>"},{"location":"Minilib.Net.HTML/#namespace-minilibnethtmlhtmldocument","title":"namespace Minilib.Net.HTML::HTMLDocument","text":""},{"location":"Minilib.Net.HTML/#add","title":"add","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement -&gt; Minilib.Net.HTML::HTMLDocument -&gt; Minilib.Net.HTML::HTMLDocument</code></p> <p>Adds a child element to <code>&lt;html&gt;</code> element.</p>"},{"location":"Minilib.Net.HTML/#empty","title":"empty","text":"<p>Type: <code>Minilib.Net.HTML::HTMLDocument</code></p> <p>An empty HTML document.</p>"},{"location":"Minilib.Net.HTML/#to_html","title":"to_html","text":"<p>Type: <code>Minilib.Net.HTML::HTMLDocument -&gt; Std::String</code></p> <p>Converts the HTML document to HTML string.</p>"},{"location":"Minilib.Net.HTML/#namespace-minilibnethtmlhtmlelement","title":"namespace Minilib.Net.HTML::HTMLElement","text":""},{"location":"Minilib.Net.HTML/#_output_html_1","title":"_output_html","text":"<p>Type: <code>Std::Array Std::String -&gt; Minilib.Net.HTML::HTMLElement -&gt; Std::Array Std::String</code></p> <p><code>el._output_html</code> output the element as HTML string.</p>"},{"location":"Minilib.Net.HTML/#add_1","title":"add","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement -&gt; Minilib.Net.HTML::HTMLElement -&gt; Minilib.Net.HTML::HTMLElement</code></p> <p><code>el.add(child)</code> adds a child element to <code>el</code>.</p>"},{"location":"Minilib.Net.HTML/#attr","title":"attr","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.HTML::HTMLElement -&gt; Minilib.Net.HTML::HTMLElement</code></p> <p><code>el.attr(name,value)</code> adds an attribute to <code>el</code>. If an attribute of same name exists, it will be removed first. NOTE: validity of attribute names are not checked.</p>"},{"location":"Minilib.Net.HTML/#make","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.HTML::HTMLElement</code></p> <p><code>HTMLElement::make(tag)</code> creates an empty element with specified tag name.</p>"},{"location":"Minilib.Net.HTML/#text","title":"text","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.HTML::HTMLElement -&gt; Minilib.Net.HTML::HTMLElement</code></p> <p><code>el.text(txt)</code> adds a text node to <code>el</code>.</p>"},{"location":"Minilib.Net.HTML/#to_html_1","title":"to_html","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement -&gt; Std::String</code></p> <p><code>el.to_html</code> converts the element to HTML string.</p>"},{"location":"Minilib.Net.HTML/#namespace-minilibnethtmlhtmlhelpers","title":"namespace Minilib.Net.HTML::HTMLHelpers","text":""},{"location":"Minilib.Net.HTML/#escape_html","title":"escape_html","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Escapes HTML special characters. eg. <code>&amp;</code> -&gt; <code>&amp;amp;</code>, <code>&lt;</code> -&gt; <code>&amp;lt;</code>, <code>&gt;</code> -&gt; <code>&amp;gt;</code>, <code>\\\"</code> -&gt; <code>&amp;quot;</code>, <code>'</code> -&gt; <code>&amp;#039;</code></p>"},{"location":"Minilib.Net.HTML/#unescape_html","title":"unescape_html","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Unescapes HTML special characters. eg. <code>&amp;amp;</code> -&gt; <code>&amp;</code>, <code>&amp;lt;</code> -&gt; <code>&lt;</code>, <code>&amp;gt;</code> -&gt; <code>&gt;</code>, <code>&amp;quot;</code> -&gt; <code>\\\"</code>, <code>&amp;#039;</code> -&gt; <code>'</code>. NOTE: Other character references is also converted.</p>"},{"location":"Minilib.Net.HTML/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.HTML/#namespace-minilibnethtml","title":"namespace Minilib.Net.HTML","text":""},{"location":"Minilib.Net.HTML/#htmlattribute","title":"HTMLAttribute","text":"<p>Defined as: <code>type HTMLAttribute = (Std::String, Std::String)</code></p> <p>A type that represents name and value of an attribute.</p>"},{"location":"Minilib.Net.HTML/#htmldocument","title":"HTMLDocument","text":"<p>Defined as: <code>type HTMLDocument = unbox struct { ...fields... }</code></p> <p>A type that represents an HTML document.</p>"},{"location":"Minilib.Net.HTML/#field-html","title":"field <code>html</code>","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p>"},{"location":"Minilib.Net.HTML/#htmlelement","title":"HTMLElement","text":"<p>Defined as: <code>type HTMLElement = unbox struct { ...fields... }</code></p> <p>A type that represents an HTML element.</p>"},{"location":"Minilib.Net.HTML/#field-tag","title":"field <code>tag</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.HTML/#field-attrs","title":"field <code>attrs</code>","text":"<p>Type: <code>Std::Iterator::DynIterator Minilib.Net.HTML::HTMLAttribute</code></p>"},{"location":"Minilib.Net.HTML/#field-children","title":"field <code>children</code>","text":"<p>Type: <code>Std::Array Minilib.Net.HTML::HTMLNode</code></p>"},{"location":"Minilib.Net.HTML/#htmlnode","title":"HTMLNode","text":"<p>Defined as: <code>type HTMLNode = box union { ...variants... }</code></p> <p>A type that represents an HTML node.</p>"},{"location":"Minilib.Net.HTML/#variant-element","title":"variant <code>element</code>","text":"<p>Type: <code>Minilib.Net.HTML::HTMLElement</code></p>"},{"location":"Minilib.Net.HTML/#variant-text_node","title":"variant <code>text_node</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.HTML/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.HTML/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.HttpServer/","title":"Minilib.Net.HttpServer","text":"<p>Defined in minilib-net@0.5.1</p> <p>Simple HTTP server. The interface is similar to <code>express</code> of Node.js. - Insert a request handler on specific path - Listen for incoming requests</p>"},{"location":"Minilib.Net.HttpServer/#values","title":"Values","text":""},{"location":"Minilib.Net.HttpServer/#namespace-minilibnethttpserverapp","title":"namespace Minilib.Net.HttpServer::App","text":""},{"location":"Minilib.Net.HttpServer/#insert_handler","title":"insert_handler","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.HttpServer::RequestHandler -&gt; Minilib.Net.HttpServer::App -&gt; Minilib.Net.HttpServer::App</code></p> <p><code>app.insert_handler(method, path, handler)</code> inserts a handler at <code>path</code> for <code>method</code>.</p>"},{"location":"Minilib.Net.HttpServer/#listen","title":"listen","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.HttpServer::App -&gt; Std::IO::IOFail Minilib.Net.HttpServer::App</code></p> <p><code>app.listen(server_host_port)</code> listens for incoming requests, and respond to accepted connections.</p> <p>This function sets the signal handler for SIGPIPE to SIG_IGN to avoid abnormal program termination when writing to a closed socket.</p>"},{"location":"Minilib.Net.HttpServer/#make","title":"make","text":"<p>Type: <code>() -&gt; Minilib.Net.HttpServer::App</code></p> <p><code>App::make()</code> creates an empty application.</p>"},{"location":"Minilib.Net.HttpServer/#on","title":"on","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.HttpServer::RequestHandler -&gt; Minilib.Net.HttpServer::App -&gt; Minilib.Net.HttpServer::App</code></p> <p>Alias of <code>insert_handler</code>.</p>"},{"location":"Minilib.Net.HttpServer/#namespace-minilibnethttpserverworker","title":"namespace Minilib.Net.HttpServer::Worker","text":""},{"location":"Minilib.Net.HttpServer/#_finally","title":"_finally","text":"<p>Type: <code>(() -&gt; Std::IO ()) -&gt; Std::IO::IOFail a -&gt; Std::IO::IOFail a</code></p>"},{"location":"Minilib.Net.HttpServer/#_not_found_handler","title":"_not_found_handler","text":"<p>Type: <code>Minilib.Net.Request::Request -&gt; Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p>"},{"location":"Minilib.Net.HttpServer/#handle","title":"handle","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::String -&gt; Minilib.Net.HttpServer::Worker -&gt; Std::IO ()</code></p> <p><code>worker.handle(connection, remote_addr)</code> receives an HTTP request from the socket connection, then finds the request handler for the request, and call that handler.</p>"},{"location":"Minilib.Net.HttpServer/#make_1","title":"make","text":"<p>Type: <code>Minilib.Net.HttpServer::App -&gt; Minilib.Net.HttpServer::Worker</code></p> <p>Creates a worker for the application.</p>"},{"location":"Minilib.Net.HttpServer/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.HttpServer/#namespace-minilibnethttpserver","title":"namespace Minilib.Net.HttpServer","text":""},{"location":"Minilib.Net.HttpServer/#app","title":"App","text":"<p>Defined as: <code>type App = unbox struct { ...fields... }</code></p> <p>This type represents an application.</p>"},{"location":"Minilib.Net.HttpServer/#field-router","title":"field <code>router</code>","text":"<p>Type: <code>Minilib.Net.Router::Router Minilib.Net.HttpServer::RequestHandler</code></p>"},{"location":"Minilib.Net.HttpServer/#field-backlog","title":"field <code>backlog</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Net.HttpServer/#requesthandler","title":"RequestHandler","text":"<p>Defined as: <code>type RequestHandler = Minilib.Net.Request::Request -&gt; Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p> <p>The request handler interprets an HTTP request and outputs an HTTP response to <code>response.@connection</code>. It returns an HTTP response.</p>"},{"location":"Minilib.Net.HttpServer/#worker","title":"Worker","text":"<p>Defined as: <code>type Worker = unbox struct { ...fields... }</code></p> <p>The worker is responsible for processing a request. Specifically, it reads one request from the socket, processes it, and writes a response to the socket.</p>"},{"location":"Minilib.Net.HttpServer/#field-app","title":"field <code>app</code>","text":"<p>Type: <code>Minilib.Net.HttpServer::App</code></p>"},{"location":"Minilib.Net.HttpServer/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.HttpServer/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.Request/","title":"Minilib.Net.Request","text":"<p>Defined in minilib-net@0.5.1</p> <p>HTTP request and response. - Parses HTTP request headers and query strings, POST data   (currently only <code>application/x-www-form-urlencoded</code> is supported) - Writes response back to client</p>"},{"location":"Minilib.Net.Request/#values","title":"Values","text":""},{"location":"Minilib.Net.Request/#namespace-minilibnetrequest","title":"namespace Minilib.Net.Request","text":""},{"location":"Minilib.Net.Request/#_content_type_aliases","title":"_CONTENT_TYPE_ALIASES","text":"<p>Type: <code>HashMap::HashMap Std::String Std::String</code></p> <p>Content-Type (MIME type) aliases</p>"},{"location":"Minilib.Net.Request/#_status_reason","title":"_STATUS_REASON","text":"<p>Type: <code>HashMap::HashMap Std::I64 Std::String</code></p> <p>RFC9110 HTTP status and reason-phrase</p>"},{"location":"Minilib.Net.Request/#namespace-minilibnetrequestheaders","title":"namespace Minilib.Net.Request::Headers","text":""},{"location":"Minilib.Net.Request/#append","title":"append","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.Request::Headers -&gt; Minilib.Net.Request::Headers</code></p> <p><code>headers.append(name, value)</code> appends a new field <code>(name, value)</code> to the current headers collection. The field name is converted to lowercase. It will not be removed even if a field with the same name already exists,</p>"},{"location":"Minilib.Net.Request/#empty","title":"empty","text":"<p>Type: <code>Minilib.Net.Request::Headers</code></p> <p>An empty collection of headers.</p>"},{"location":"Minilib.Net.Request/#find","title":"find","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Request::Headers -&gt; Std::Option Std::String</code></p> <p><code>headers.find(name)</code> finds the field with name <code>name</code>. The field name is converted to lowercase.</p>"},{"location":"Minilib.Net.Request/#set","title":"set","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.Request::Headers -&gt; Minilib.Net.Request::Headers</code></p> <p><code>headers.set(name, value)</code> sets the value of the field named <code>name</code> to <code>value</code>. The field name is converted to lowercase. If a field with the same name already exists, it will be removed first.</p>"},{"location":"Minilib.Net.Request/#to_iter","title":"to_iter","text":"<p>Type: <code>Minilib.Net.Request::Headers -&gt; Std::Iterator::DynIterator (Std::String, Std::String)</code></p> <p><code>headers.to_iter</code> returns an iterator of headers.</p>"},{"location":"Minilib.Net.Request/#namespace-minilibnetrequestrequest","title":"namespace Minilib.Net.Request::Request","text":""},{"location":"Minilib.Net.Request/#_parse_header","title":"_parse_header","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg (Std::String, Std::String)</code></p>"},{"location":"Minilib.Net.Request/#_parse_query_string","title":"_parse_query_string","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail (Std::Array (Std::String, Std::String))</code></p>"},{"location":"Minilib.Net.Request/#_parse_request_line","title":"_parse_request_line","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg (Std::String, Std::String, Std::String)</code></p>"},{"location":"Minilib.Net.Request/#find_query","title":"find_query","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Request::Request -&gt; Std::Option Std::String</code></p>"},{"location":"Minilib.Net.Request/#parse","title":"parse","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::String -&gt; Std::IO::IOFail Minilib.Net.Request::Request</code></p> <p><code>Request::parse(connection, remote_addr)</code> reads the HTTP request from <code>connection</code> and parse it.</p>"},{"location":"Minilib.Net.Request/#namespace-minilibnetrequestresponse","title":"namespace Minilib.Net.Request::Response","text":""},{"location":"Minilib.Net.Request/#_send_headers","title":"_send_headers","text":"<p>Type: <code>Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p> <p>Sends headers with a status line if they have not already been sent.</p>"},{"location":"Minilib.Net.Request/#content_type","title":"content_type","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Request::Response -&gt; Minilib.Net.Request::Response</code></p> <p><code>response.content_type(type)</code> sets the <code>Content-Type</code> header. You can specify an alias for the content type (e.g. \"text\", \"json\"). See the definition of <code>_CONTENT_TYPE_ALIASES</code> for a list of available aliases.</p>"},{"location":"Minilib.Net.Request/#end","title":"end","text":"<p>Type: <code>Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p> <p>Sends headers with a status line if they have not already been sent. Then flush the connection.</p>"},{"location":"Minilib.Net.Request/#header","title":"header","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.Request::Response -&gt; Minilib.Net.Request::Response</code></p> <p><code>response.header(name, value)</code> sets a response header.</p>"},{"location":"Minilib.Net.Request/#make","title":"make","text":"<p>Type: <code>Minilib.Net.Request::Request -&gt; Minilib.Net.Request::Response</code></p> <p><code>Response::make(request)</code> creates a basic HTTP response for an HTTP request.</p>"},{"location":"Minilib.Net.Request/#status","title":"status","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Net.Request::Response -&gt; Minilib.Net.Request::Response</code></p> <p><code>response.status(code)</code> sets the HTTP status code. (eg. 404) It will also set the reason phrase (eg. \"Not Found\") of the status.</p>"},{"location":"Minilib.Net.Request/#write_bytes","title":"write_bytes","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p> <p><code>response.write_bytes(bytes)</code> sends headers with a status line if they have not already been sent. Then it sends the specified bytes.</p>"},{"location":"Minilib.Net.Request/#write_str","title":"write_str","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Request::Response -&gt; Std::IO::IOFail Minilib.Net.Request::Response</code></p> <p><code>response.write_str(str)</code> sends headers with a status line if they have not already been sent. Then it sends the specified string.</p>"},{"location":"Minilib.Net.Request/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.Request/#namespace-minilibnetrequest_1","title":"namespace Minilib.Net.Request","text":""},{"location":"Minilib.Net.Request/#header_1","title":"Header","text":"<p>Defined as: <code>type Header = (Std::String, Std::String)</code></p> <p>A type that represents a header. The header is a tuple of field name and field value. Note that the field name is case-insensitive (RFC9112).</p>"},{"location":"Minilib.Net.Request/#headers","title":"Headers","text":"<p>Defined as: <code>type Headers = unbox struct { ...fields... }</code></p> <p>A collection of headers.</p>"},{"location":"Minilib.Net.Request/#field-iter","title":"field <code>iter</code>","text":"<p>Type: <code>Std::Iterator::DynIterator Minilib.Net.Request::Header</code></p>"},{"location":"Minilib.Net.Request/#request","title":"Request","text":"<p>Defined as: <code>type Request = unbox struct { ...fields... }</code></p> <p>A type that represents an HTTP request.</p>"},{"location":"Minilib.Net.Request/#field-connection","title":"field <code>connection</code>","text":"<p>Type: <code>Std::IO::IOHandle</code></p>"},{"location":"Minilib.Net.Request/#field-remote_addr","title":"field <code>remote_addr</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-method","title":"field <code>method</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-request_target","title":"field <code>request_target</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-http_version","title":"field <code>http_version</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-headers","title":"field <code>headers</code>","text":"<p>Type: <code>Minilib.Net.Request::Headers</code></p>"},{"location":"Minilib.Net.Request/#field-path","title":"field <code>path</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-query","title":"field <code>query</code>","text":"<p>Type: <code>Std::Array (Std::String, Std::String)</code></p>"},{"location":"Minilib.Net.Request/#field-body","title":"field <code>body</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Net.Request/#response","title":"Response","text":"<p>Defined as: <code>type Response = unbox struct { ...fields... }</code></p> <p>A type that represents an HTTP response.</p>"},{"location":"Minilib.Net.Request/#field-request","title":"field <code>request</code>","text":"<p>Type: <code>Minilib.Net.Request::Request</code></p>"},{"location":"Minilib.Net.Request/#field-connection_1","title":"field <code>connection</code>","text":"<p>Type: <code>Std::IO::IOHandle</code></p>"},{"location":"Minilib.Net.Request/#field-http_version_1","title":"field <code>http_version</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-status","title":"field <code>status</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Net.Request/#field-reason","title":"field <code>reason</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.Request/#field-headers_1","title":"field <code>headers</code>","text":"<p>Type: <code>Minilib.Net.Request::Headers</code></p>"},{"location":"Minilib.Net.Request/#field-headerssent","title":"field <code>headersSent</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.Net.Request/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.Request/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.Request/#impl-minilibnetrequestheaders-stdtostring","title":"impl <code>Minilib.Net.Request::Headers : Std::ToString</code>","text":""},{"location":"Minilib.Net.Request/#impl-minilibnetrequestrequest-stdtostring","title":"impl <code>Minilib.Net.Request::Request : Std::ToString</code>","text":""},{"location":"Minilib.Net.Router/","title":"Minilib.Net.Router","text":"<p>Defined in minilib-net@0.5.1</p> <p>HTTP request router. - Mounts a request handler to specific path and method - Finds a request handler from path and method of the HTTP request</p>"},{"location":"Minilib.Net.Router/#values","title":"Values","text":""},{"location":"Minilib.Net.Router/#namespace-minilibnetrouterrouter","title":"namespace Minilib.Net.Router::Router","text":""},{"location":"Minilib.Net.Router/#empty","title":"empty","text":"<p>Type: <code>Minilib.Net.Router::Router h</code></p> <p>An empty router.</p>"},{"location":"Minilib.Net.Router/#find","title":"find","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Minilib.Net.Router::Router h -&gt; Std::Option h</code></p> <p><code>router.find(method, path)</code> finds the handler that matches <code>method</code> and <code>path</code>.</p>"},{"location":"Minilib.Net.Router/#insert","title":"insert","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; h -&gt; Minilib.Net.Router::Router h -&gt; Minilib.Net.Router::Router h</code></p> <p><code>router.insert(method, path, handler)</code> tells that <code>method</code> and  path should be mapped to this handler.</p>"},{"location":"Minilib.Net.Router/#namespace-minilibnetrouterrouterentry","title":"namespace Minilib.Net.Router::RouterEntry","text":""},{"location":"Minilib.Net.Router/#empty_1","title":"empty","text":"<p>Type: <code>Minilib.Net.Router::RouterEntry h</code></p> <p>An empty entry.</p>"},{"location":"Minilib.Net.Router/#find_1","title":"find","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Router::RouterEntry h -&gt; Std::Option h</code></p> <p><code>router_entry.find(method)</code> finds the handler of the method.</p>"},{"location":"Minilib.Net.Router/#is_empty","title":"is_empty","text":"<p>Type: <code>Minilib.Net.Router::RouterEntry h -&gt; Std::Bool</code></p> <p>Returns true iff it is an empty entry.</p>"},{"location":"Minilib.Net.Router/#update","title":"update","text":"<p>Type: <code>Std::String -&gt; h -&gt; Minilib.Net.Router::RouterEntry h -&gt; Minilib.Net.Router::RouterEntry h</code></p> <p><code>router_entry.update(method, handler)</code> sets the handler of the method <code>method</code> to <code>handler</code>.</p>"},{"location":"Minilib.Net.Router/#namespace-minilibnetrouterrouternode","title":"namespace Minilib.Net.Router::RouterNode","text":""},{"location":"Minilib.Net.Router/#create","title":"create","text":"<p>Type: <code>Std::Iterator::DynIterator Std::String -&gt; (Minilib.Net.Router::RouterEntry h -&gt; Minilib.Net.Router::RouterEntry h) -&gt; Minilib.Net.Router::RouterNode h</code></p> <p><code>RouterNode::create(path, entry_updater)</code> creates a node.</p>"},{"location":"Minilib.Net.Router/#empty_2","title":"empty","text":"<p>Type: <code>Minilib.Net.Router::RouterNode h</code></p> <p>An empty router node.</p>"},{"location":"Minilib.Net.Router/#find_2","title":"find","text":"<p>Type: <code>Std::Iterator::DynIterator Std::String -&gt; Minilib.Net.Router::RouterNode h -&gt; Std::Option (Minilib.Net.Router::RouterEntry h)</code></p> <p>Finds the entry in the node following the path from the current node.</p>"},{"location":"Minilib.Net.Router/#show","title":"show","text":"<p>Type: <code>[h : Std::ToString] Std::String -&gt; Minilib.Net.Router::RouterNode h -&gt; Std::IO ()</code></p> <p>TODO: use Writer monad</p>"},{"location":"Minilib.Net.Router/#update_1","title":"update","text":"<p>Type: <code>Std::Iterator::DynIterator Std::String -&gt; (Minilib.Net.Router::RouterEntry h -&gt; Minilib.Net.Router::RouterEntry h) -&gt; Minilib.Net.Router::RouterNode h -&gt; Minilib.Net.Router::RouterNode h</code></p> <p><code>current_node.update(path, entry_updater)</code> updates the entry of a target node that is reached via <code>path</code> from <code>current_node</code>. <code>path</code> is a path from <code>current_node</code> to the target node. If <code>path</code> is an empty iterator, <code>current_node</code> becomes the target node. <code>entry_updater</code> is a function that updates the <code>RouterEntry</code> of the target node.</p>"},{"location":"Minilib.Net.Router/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.Router/#namespace-minilibnetrouter","title":"namespace Minilib.Net.Router","text":""},{"location":"Minilib.Net.Router/#router","title":"Router","text":"<p>Defined as: <code>type Router h = box struct { ...fields... }</code></p> <p>Router is a mapping from a method name and a path to a request handler. <code>h</code> is a type of request handler.</p>"},{"location":"Minilib.Net.Router/#field-root","title":"field <code>root</code>","text":"<p>Type: <code>Minilib.Net.Router::RouterNode h</code></p>"},{"location":"Minilib.Net.Router/#routerentry","title":"RouterEntry","text":"<p>Defined as: <code>type RouterEntry h = box struct { ...fields... }</code></p> <p><code>RouterEntry h</code> represents a map from method name to a request handler. <code>h</code> is a type of request handler.</p>"},{"location":"Minilib.Net.Router/#field-map","title":"field <code>map</code>","text":"<p>Type: <code>HashMap::HashMap Std::String h</code></p>"},{"location":"Minilib.Net.Router/#routernode","title":"RouterNode","text":"<p>Defined as: <code>type RouterNode h = box struct { ...fields... }</code></p> <p><code>RouterNode h</code> represents a resource of URI. <code>h</code> is a type of request handler.</p>"},{"location":"Minilib.Net.Router/#field-directory","title":"field <code>directory</code>","text":"<p>Type: <code>HashMap::HashMap Std::String (Minilib.Net.Router::RouterNode h)</code></p>"},{"location":"Minilib.Net.Router/#field-entry","title":"field <code>entry</code>","text":"<p>Type: <code>Minilib.Net.Router::RouterEntry h</code></p>"},{"location":"Minilib.Net.Router/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.Router/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.Router/#impl-h-stdtostring-minilibnetrouterrouterentry-h-stdtostring","title":"impl <code>[h : Std::ToString] Minilib.Net.Router::RouterEntry h : Std::ToString</code>","text":""},{"location":"Minilib.Net.Tcp/","title":"Minilib.Net.Tcp","text":"<p>Defined in minilib-net@0.5.1</p> <p>IPv4 TCP Socket operations.</p> <p>Features: - IP address, port number - Resolves IP address from hostname - IPv4 Socket address - IPv4 TCP Socket</p> <p>Tested platform: x86_64-linux-gnu, aarch64-linux-gnu WARNING: IPv6 is not supported yet.</p>"},{"location":"Minilib.Net.Tcp/#values","title":"Values","text":""},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcp","title":"namespace Minilib.Net.Tcp","text":""},{"location":"Minilib.Net.Tcp/#connect_to_tcp_server","title":"connect_to_tcp_server","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.Net.Tcp::Socket</code></p> <p>Connects to a remote TCP server as a client. The first argument is <code>{host}:{port}</code>, where <code>{host}</code> is an IP Address (eg. <code>192.168.0.1</code>), or a FQDN host name (eg. <code>www.example.com</code>), and <code>{port}</code> is a port number (eg. <code>8080</code>). If the port number is omitted, the default port number is 80.</p>"},{"location":"Minilib.Net.Tcp/#listen_tcp_server","title":"listen_tcp_server","text":"<p>Type: <code>Std::String -&gt; Std::I64 -&gt; Std::IO::IOFail Minilib.Net.Tcp::Socket</code></p> <p>Listens at the specified address as a server.</p> <p>The first argument is <code>{host}:{port}</code>, where <code>{host}</code> is an IP Address (typically, <code>127.0.0.1</code>), or a FQDN host name (typically, <code>localhost</code>), and <code>{port}</code> is a port number (eg. <code>8080</code>). If the port number is omitted, the default port number is 80.</p> <p>The second argument (<code>backlog</code>) is the maximum length to which the queue of pending connections for the socket may grow.</p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpbufferedsocket","title":"namespace Minilib.Net.Tcp::BufferedSocket","text":""},{"location":"Minilib.Net.Tcp/#_bufsize","title":"_BUFSIZE","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Net.Tcp/#flush","title":"flush","text":"<p>Type: <code>Minilib.Net.Tcp::BufferedSocket -&gt; Std::IO::IOFail Minilib.Net.Tcp::BufferedSocket</code></p> <p>Sends the contents of the writer buffer to the socket and cleans the write buffer.</p>"},{"location":"Minilib.Net.Tcp/#make","title":"make","text":"<p>Type: <code>Minilib.Net.Tcp::Socket -&gt; Minilib.Net.Tcp::BufferedSocket</code></p> <p>Makes a <code>BufferedSocket</code> from a <code>Socket</code>.</p>"},{"location":"Minilib.Net.Tcp/#read_line","title":"read_line","text":"<p>Type: <code>Minilib.Net.Tcp::BufferedSocket -&gt; Std::IO::IOFail (Std::String, Minilib.Net.Tcp::BufferedSocket)</code></p> <p>Reads out a line (ie. a string that ends with a newline) from the read buffer. When the read buffer does not contain a newline, it will read some bytes upto _BUFSIZE from the socket, and search for a newline again. When the connection is closed, the return value may or may not contain a newline. The next call of <code>read_line()</code> returns an empty string, which represents that the connection is closed.</p>"},{"location":"Minilib.Net.Tcp/#write_str","title":"write_str","text":"<p>Type: <code>Std::String -&gt; Minilib.Net.Tcp::BufferedSocket -&gt; Std::IO::IOFail Minilib.Net.Tcp::BufferedSocket</code></p> <p>Writes a string to the write buffer. The contents of the write buffer is not sent until the size of the write buffer is equal to or greater than <code>_BUFSIZE</code>, or <code>flush()</code> is called.</p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpipaddress","title":"namespace Minilib.Net.Tcp::IpAddress","text":""},{"location":"Minilib.Net.Tcp/#_resolve_ipaddress_v4","title":"_resolve_ipaddress_v4","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.Net.Tcp::IpAddress</code></p>"},{"location":"Minilib.Net.Tcp/#from_u32","title":"from_U32","text":"<p>Type: <code>Std::U32 -&gt; Minilib.Net.Tcp::IpAddress</code></p> <p>Converts U32 to an <code>IpAddress</code>, for example 0x7f000001_U32 -&gt; 127.0.0.1.</p>"},{"location":"Minilib.Net.Tcp/#from_array","title":"from_array","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Net.Tcp::IpAddress</code></p> <p>Converts a byte array to an <code>IpAddress</code>. The length of the byte array must be 4.</p>"},{"location":"Minilib.Net.Tcp/#resolve","title":"resolve","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.Net.Tcp::IpAddress</code></p> <p>Resolve a hostname such as \"127.0.0.1\" or \"www.example.com\".</p>"},{"location":"Minilib.Net.Tcp/#to_u32","title":"to_U32","text":"<p>Type: <code>Minilib.Net.Tcp::IpAddress -&gt; Std::U32</code></p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpport","title":"namespace Minilib.Net.Tcp::Port","text":""},{"location":"Minilib.Net.Tcp/#from_u16","title":"from_U16","text":"<p>Type: <code>Std::U16 -&gt; Minilib.Net.Tcp::Port</code></p>"},{"location":"Minilib.Net.Tcp/#to_u16","title":"to_U16","text":"<p>Type: <code>Minilib.Net.Tcp::Port -&gt; Std::U16</code></p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpsocket","title":"namespace Minilib.Net.Tcp::Socket","text":""},{"location":"Minilib.Net.Tcp/#_unsafe_from_fd","title":"_unsafe_from_fd","text":"<p>Type: <code>Std::FFI::CInt -&gt; Std::IO::IOFail Minilib.Net.Tcp::Socket</code></p> <p>Creates <code>Socket</code> from a file descriptor of a socket. The socket will be automatically closed when <code>Socket</code> is deallocated.</p>"},{"location":"Minilib.Net.Tcp/#accept","title":"accept","text":"<p>Type: <code>Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail (Minilib.Net.Tcp::Socket, Minilib.Net.Tcp::SocketAddress::SocketAddress)</code></p> <p>Waits for an incoming connection request. If an incoming connection arrives, accept it, and returns a socket of accepted connection and the remote socket address.</p>"},{"location":"Minilib.Net.Tcp/#accept_fd","title":"accept_fd","text":"<p>Type: <code>Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail (Std::FFI::CInt, Minilib.Net.Tcp::SocketAddress::SocketAddress)</code></p> <p>Same as <code>accept()</code>, except that it returns the accepted socket's file descriptor instead of <code>Socket</code>.</p>"},{"location":"Minilib.Net.Tcp/#bind","title":"bind","text":"<p>Type: <code>Minilib.Net.Tcp::SocketAddress::SocketAddress -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail ()</code></p> <p>Assigns an IPv4 ip address and a port number to the socket.</p>"},{"location":"Minilib.Net.Tcp/#borrow_fd_io","title":"borrow_fd_io","text":"<p>Type: <code>(Std::FFI::CInt -&gt; Std::IO a) -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO a</code></p> <p>Call an IO action with a file descriptor of a socket.</p>"},{"location":"Minilib.Net.Tcp/#connect","title":"connect","text":"<p>Type: <code>Minilib.Net.Tcp::SocketAddress::SocketAddress -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail ()</code></p> <p>Connects to the specified address.</p>"},{"location":"Minilib.Net.Tcp/#listen","title":"listen","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail ()</code></p> <p>Listens the socket for incoming connection requests. The first argument (backlog) is the maximum length to which the queue of pending connections for sockfd may grow.</p>"},{"location":"Minilib.Net.Tcp/#make_tcp_socket","title":"make_tcp_socket","text":"<p>Type: <code>() -&gt; Std::IO::IOFail Minilib.Net.Tcp::Socket</code></p> <p>Creates new tcp socket. The socket will be automatically closed when <code>Socket</code> is deallocated.</p>"},{"location":"Minilib.Net.Tcp/#recv","title":"recv","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Receives messages from a socket. The first argument is the maximum number of bytes to receive. If no message are available at the socket, <code>recv()</code> waits for a message to arrive. Returns the number of bytes received. When the socket has been shutdown, the return value will be 0.</p>"},{"location":"Minilib.Net.Tcp/#send","title":"send","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail Std::I64</code></p> <p>Transmits a message to another socket. May be used only when the socket is in a connected state. Returns the number of bytes sent.</p>"},{"location":"Minilib.Net.Tcp/#setsockopt_reuseaddr","title":"setsockopt_reuseaddr","text":"<p>Type: <code>Minilib.Net.Tcp::Socket -&gt; Std::IO::IOFail ()</code></p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpsocketaddress","title":"namespace Minilib.Net.Tcp::SocketAddress","text":""},{"location":"Minilib.Net.Tcp/#_unsafe_from_sockaddr_in","title":"_unsafe_from_sockaddr_in","text":"<p>Type: <code>Std::Ptr -&gt; Minilib.Net.Tcp::SocketAddress::SocketAddress</code></p> <p>Creates a <code>SocketAddress</code> from an allocated pointer to <code>struct sockaddr_in</code>.</p>"},{"location":"Minilib.Net.Tcp/#get_ipaddress","title":"get_ipaddress","text":"<p>Type: <code>Minilib.Net.Tcp::SocketAddress::SocketAddress -&gt; Minilib.Net.Tcp::IpAddress</code></p> <p>Extracts an ip address from the socket address.</p>"},{"location":"Minilib.Net.Tcp/#get_port","title":"get_port","text":"<p>Type: <code>Minilib.Net.Tcp::SocketAddress::SocketAddress -&gt; Minilib.Net.Tcp::Port</code></p> <p>Extracts a port number from the socket address.</p>"},{"location":"Minilib.Net.Tcp/#make_1","title":"make","text":"<p>Type: <code>Minilib.Net.Tcp::IpAddress -&gt; Minilib.Net.Tcp::Port -&gt; Minilib.Net.Tcp::SocketAddress::SocketAddress</code></p> <p>Creates a <code>SocketAddress</code> from an ip address and a port.</p>"},{"location":"Minilib.Net.Tcp/#resolve_1","title":"resolve","text":"<p>Type: <code>Std::String -&gt; Std::IO::IOFail Minilib.Net.Tcp::SocketAddress::SocketAddress</code></p> <p>Splits the first argument into a host name and a port number, then resolves the host name to an ip address, then creates a <code>SocketAddress</code> from the ip address and the port number.</p> <p>The first argument is <code>{host}:{port}</code>, where <code>{host}</code> is an IP Address (eg. <code>192.168.0.1</code>), or a FQDN host name (eg. <code>www.example.com</code>), and <code>{port}</code> is a port number (eg. <code>8080</code>). If the port number is omitted, the default port number is 80.</p>"},{"location":"Minilib.Net.Tcp/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcp_1","title":"namespace Minilib.Net.Tcp","text":""},{"location":"Minilib.Net.Tcp/#bufferedsocket","title":"BufferedSocket","text":"<p>Defined as: <code>type BufferedSocket = unbox struct { ...fields... }</code></p> <p>This type is a structure that wraps a <code>Socket</code> and maintains a write buffer, a read buffer and an EOF flag.</p>"},{"location":"Minilib.Net.Tcp/#field-socket","title":"field <code>socket</code>","text":"<p>Type: <code>Minilib.Net.Tcp::Socket</code></p>"},{"location":"Minilib.Net.Tcp/#field-write_buf","title":"field <code>write_buf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Net.Tcp/#field-read_buf","title":"field <code>read_buf</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Net.Tcp/#field-eof","title":"field <code>eof</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.Net.Tcp/#ipaddress","title":"IpAddress","text":"<p>Defined as: <code>type IpAddress = unbox struct { ...fields... }</code></p> <p>This type represents IPv4 ip address, eg. 127.0.0.1, 192.168.0.1 etc.</p>"},{"location":"Minilib.Net.Tcp/#field-addr","title":"field <code>addr</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Minilib.Net.Tcp/#port","title":"Port","text":"<p>Defined as: <code>type Port = unbox struct { ...fields... }</code></p> <p>This type reprents IPv4 port number, 0-65535.</p>"},{"location":"Minilib.Net.Tcp/#field-port","title":"field <code>port</code>","text":"<p>Type: <code>Std::U16</code></p>"},{"location":"Minilib.Net.Tcp/#socket","title":"Socket","text":"<p>Defined as: <code>type Socket = unbox struct { ...fields... }</code></p> <p>This type represents an IPv4 socket. It consists of a socket file descriptor. The socket file descripter is closed automatically when Socket is deallocated.</p>"},{"location":"Minilib.Net.Tcp/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::FFI::CInt</code></p>"},{"location":"Minilib.Net.Tcp/#namespace-minilibnettcpsocketaddress_1","title":"namespace Minilib.Net.Tcp::SocketAddress","text":""},{"location":"Minilib.Net.Tcp/#socketaddress","title":"SocketAddress","text":"<p>Defined as: <code>type SocketAddress = unbox struct { ...fields... }</code></p> <p>This type represents IPv4 ip address and port number.</p>"},{"location":"Minilib.Net.Tcp/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::Ptr</code></p>"},{"location":"Minilib.Net.Tcp/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.Tcp/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpipaddress-stdfromstring","title":"impl <code>Minilib.Net.Tcp::IpAddress : Std::FromString</code>","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpipaddress-stdtostring","title":"impl <code>Minilib.Net.Tcp::IpAddress : Std::ToString</code>","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpport-stdfromstring","title":"impl <code>Minilib.Net.Tcp::Port : Std::FromString</code>","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpport-stdtostring","title":"impl <code>Minilib.Net.Tcp::Port : Std::ToString</code>","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpsocket-stdtostring","title":"impl <code>Minilib.Net.Tcp::Socket : Std::ToString</code>","text":""},{"location":"Minilib.Net.Tcp/#impl-minilibnettcpsocketaddresssocketaddress-stdtostring","title":"impl <code>Minilib.Net.Tcp::SocketAddress::SocketAddress : Std::ToString</code>","text":""},{"location":"Minilib.Net.URL/","title":"Minilib.Net.URL","text":"<p>Defined in minilib-net@0.5.1</p> <p>URL and URI parsing</p>"},{"location":"Minilib.Net.URL/#values","title":"Values","text":""},{"location":"Minilib.Net.URL/#namespace-minilibneturluri","title":"namespace Minilib.Net.URL::URI","text":""},{"location":"Minilib.Net.URL/#_alpha_numeric","title":"_alpha_numeric","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>Lookup table of characters that consists of <code>[A-Za-z0-9]</code>.</p>"},{"location":"Minilib.Net.URL/#_decodeuricomponent_table","title":"_decodeURIComponent_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>Lookup table of characters that <code>decodeURIComponent()</code> should not unescape.</p>"},{"location":"Minilib.Net.URL/#_decodeuri_table","title":"_decodeURI_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>Lookup table of characters that <code>decodeURI()</code> should not unescape.</p>"},{"location":"Minilib.Net.URL/#_decode_with","title":"_decode_with","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p>Decodes a string with a table.</p>"},{"location":"Minilib.Net.URL/#_encodeuricomponent_table","title":"_encodeURIComponent_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>Lookup table of characters that <code>encodeURIComponent()</code> should not escape.</p>"},{"location":"Minilib.Net.URL/#_encodeuri_table","title":"_encodeURI_table","text":"<p>Type: <code>Std::Array Std::U8</code></p> <p>Lookup table of characters that <code>encodeURI()</code> should not escape.</p>"},{"location":"Minilib.Net.URL/#_encode_with","title":"_encode_with","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String -&gt; Std::String</code></p> <p>Encodes a string with a table.</p>"},{"location":"Minilib.Net.URL/#decodeuri","title":"decodeURI","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p>Same as JavaScript <code>decodeURI()</code>. For details, see decodeURI() of MDN web docs.</p>"},{"location":"Minilib.Net.URL/#decodeuricomponent","title":"decodeURIComponent","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p>Same as JavaScript <code>decodeURIComponent()</code>. For details, see decodeURIComponent() of MDN web docs.</p>"},{"location":"Minilib.Net.URL/#encodeuri","title":"encodeURI","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Same as JavaScript <code>encodeURI()</code>. For details, see encodeURI() of MDN web docs.</p>"},{"location":"Minilib.Net.URL/#encodeuricomponent","title":"encodeURIComponent","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Same as JavaScript <code>encodeURIComponent()</code>. For details, see encodeURIComponent() of MDN web docs.</p>"},{"location":"Minilib.Net.URL/#namespace-minilibneturlurl","title":"namespace Minilib.Net.URL::URL","text":""},{"location":"Minilib.Net.URL/#parse","title":"parse","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Minilib.Net.URL::URL</code></p> <p>Parses a string as a URL. Recognized format of a URL is:    [scheme://]host[:port][path] If the scheme part is omitted, a default value (\"http\") is used as a scheme. The host and port part should not contain \"/\". If the port part is omitted, a default value (\"443\" if scheme == \"https\", \"80\" otherwise) is used as a port. The path part should be starts with \"/\". If the path part is omitted, a default value (\"/\") is used as a path.</p>"},{"location":"Minilib.Net.URL/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Net.URL/#namespace-minilibneturl","title":"namespace Minilib.Net.URL","text":""},{"location":"Minilib.Net.URL/#url","title":"URL","text":"<p>Defined as: <code>type URL = unbox struct { ...fields... }</code></p> <p>A structure that represents an URL.</p>"},{"location":"Minilib.Net.URL/#field-url","title":"field <code>url</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.URL/#field-scheme","title":"field <code>scheme</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.URL/#field-host","title":"field <code>host</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.URL/#field-port","title":"field <code>port</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.URL/#field-path","title":"field <code>path</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Net.URL/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Net.URL/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Net.URL/#impl-minilibneturlurl-stdeq","title":"impl <code>Minilib.Net.URL::URL : Std::Eq</code>","text":"<p>Checks whether two URLs are equal.</p>"},{"location":"Minilib.Net.URL/#impl-minilibneturlurl-stdtostring","title":"impl <code>Minilib.Net.URL::URL : Std::ToString</code>","text":"<p>Converts an URL to a string.</p>"},{"location":"Minilib.Random.XorShift/","title":"Minilib.Random.XorShift","text":"<p>Defined in minilib-random@0.5.2</p> <p>A random number generator which uses Xorshift algorithm.</p> <p>For details, see: Wikipedia: Xorshift</p>"},{"location":"Minilib.Random.XorShift/#values","title":"Values","text":""},{"location":"Minilib.Random.XorShift/#namespace-minilibrandomxorshift","title":"namespace Minilib.Random.XorShift","text":""},{"location":"Minilib.Random.XorShift/#init_by_seed","title":"init_by_seed","text":"<p>Type: <code>Std::U64 -&gt; Minilib.Random.XorShift::XorShift</code></p> <p>Initializes a random number generator by a specified seed.</p>"},{"location":"Minilib.Random.XorShift/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Random.XorShift/#namespace-minilibrandomxorshift_1","title":"namespace Minilib.Random.XorShift","text":""},{"location":"Minilib.Random.XorShift/#xorshift","title":"XorShift","text":"<p>Defined as: <code>type XorShift = unbox struct { ...fields... }</code></p> <p>A random number generator which uses Xorshift algorithm.</p>"},{"location":"Minilib.Random.XorShift/#field-data","title":"field <code>data</code>","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Minilib.Random.XorShift/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Random.XorShift/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Random.XorShift/#impl-minilibrandomxorshiftxorshift-minilibtraitrngrng","title":"impl <code>Minilib.Random.XorShift::XorShift : Minilib.Trait.Rng::Rng</code>","text":""},{"location":"Minilib.Testing.UnitTest/","title":"Minilib.Testing.UnitTest","text":"<p>Defined in minilib-common@0.5.2</p> <p>Unit Test Framework</p>"},{"location":"Minilib.Testing.UnitTest/#values","title":"Values","text":""},{"location":"Minilib.Testing.UnitTest/#namespace-minilibtestingunittest","title":"namespace Minilib.Testing.UnitTest","text":""},{"location":"Minilib.Testing.UnitTest/#_test_verbose","title":"_TEST_VERBOSE","text":"<p>Type: <code>Std::Bool</code></p> <p>If _TEST_VERBOSE is true, the results of all testcases will be printed. If _TEST_VERBOSE is false, the results of only failed testcases will be printed.</p> <p>If the environment variable <code>TEST_VERBOSE</code> is set to non-empty string, _TEST_VERBOSE becomes true. For example, running the <code>TEST_VERBOSE=1 fix test</code> command at a shell prompt will report all testcases.</p>"},{"location":"Minilib.Testing.UnitTest/#assert_equal","title":"assert_equal","text":"<p>Type: <code>[a : Std::Eq, a : Std::ToString] Std::String -&gt; a -&gt; a -&gt; Std::IO::IOFail ()</code></p> <p>Verifies that two values are equal. If the values are different, the test will fail with the specified message.</p>"},{"location":"Minilib.Testing.UnitTest/#assert_not_equal","title":"assert_not_equal","text":"<p>Type: <code>[a : Std::Eq, a : Std::ToString] Std::String -&gt; a -&gt; a -&gt; Std::IO::IOFail ()</code></p> <p>Verifies that two values are not equal. If the values are equal, the test will fail with the specified message.</p>"},{"location":"Minilib.Testing.UnitTest/#assert_true","title":"assert_true","text":"<p>Type: <code>Std::String -&gt; Std::Bool -&gt; Std::IO::IOFail ()</code></p> <p>Verifies that the boolean value is true. If the boolean value is false, the test will fail with the specified message.</p>"},{"location":"Minilib.Testing.UnitTest/#make_table_test","title":"make_table_test","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; Std::Array a -&gt; (a -&gt; Std::IO::IOFail ()) -&gt; Minilib.Testing.UnitTest::TestCase</code></p> <p>Creates a set of test cases from parameters and a lazy <code>IOFail ()</code>.</p>"},{"location":"Minilib.Testing.UnitTest/#make_test","title":"make_test","text":"<p>Type: <code>Std::String -&gt; Std::Lazy (Std::IO::IOFail ()) -&gt; Minilib.Testing.UnitTest::TestCase</code></p> <p>Creates a named test case from a lazy <code>IOFail ()</code>.</p>"},{"location":"Minilib.Testing.UnitTest/#run_test_driver","title":"run_test_driver","text":"<p>Type: <code>Std::Array Minilib.Testing.UnitTest::TestCase -&gt; Std::IO ()</code></p> <p>Executes all test cases. This function: - Sets <code>stdout</code> and <code>stderr</code> to be unbuffered for immediate output. - Runs all test cases. - Prints a summary of the results, including the number of passed and failed tests. - If any test case fails or an error occurs, prints the error message and aborts the program. - If all test cases passed, returns <code>pure()</code>.</p>"},{"location":"Minilib.Testing.UnitTest/#run_tests","title":"run_tests","text":"<p>Type: <code>Std::Array Minilib.Testing.UnitTest::TestCase -&gt; Minilib.Testing.UnitTest::TestCase</code></p> <p>Executes all test cases and treat the results as one test case.</p>"},{"location":"Minilib.Testing.UnitTest/#namespace-minilibtestingunittesttestcase","title":"namespace Minilib.Testing.UnitTest::TestCase","text":""},{"location":"Minilib.Testing.UnitTest/#empty","title":"empty","text":"<p>Type: <code>Minilib.Testing.UnitTest::TestCase</code></p> <p>A test case where the number of successes and number of failures are both equal to 0. Can be used as a placeholder at the end of an array of test cases.</p>"},{"location":"Minilib.Testing.UnitTest/#namespace-minilibtestingunittesttestsuite","title":"namespace Minilib.Testing.UnitTest::TestSuite","text":""},{"location":"Minilib.Testing.UnitTest/#run","title":"run","text":"<p>Type: <code>Minilib.Testing.UnitTest::TestSuite -&gt; Std::IO ()</code></p>"},{"location":"Minilib.Testing.UnitTest/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Testing.UnitTest/#namespace-minilibtestingunittest_1","title":"namespace Minilib.Testing.UnitTest","text":""},{"location":"Minilib.Testing.UnitTest/#testcase","title":"TestCase","text":"<p>Defined as: <code>type TestCase = Std::Lazy (Std::IO::IOFail (Std::I64, Std::I64))</code></p> <p>TestCase is a type that counts the number of successful and failed tests.</p>"},{"location":"Minilib.Testing.UnitTest/#testsuite","title":"TestSuite","text":"<p>Defined as: <code>type TestSuite = Std::Array (Std::String, Std::IO ())</code></p>"},{"location":"Minilib.Testing.UnitTest/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Testing.UnitTest/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Text.Hex/","title":"Minilib.Text.Hex","text":"<p>Defined in minilib-binary@0.5.1</p> <p>Hexadecimal string conversion</p>"},{"location":"Minilib.Text.Hex/#values","title":"Values","text":""},{"location":"Minilib.Text.Hex/#namespace-minilibtexthex","title":"namespace Minilib.Text.Hex","text":""},{"location":"Minilib.Text.Hex/#_array_from_string_hex","title":"_array_from_string_hex","text":"<p>Type: <code>[a : Minilib.Text.Hex::FromStringHex] Std::I64 -&gt; Std::String -&gt; Std::Result Std::ErrMsg (Std::Array a)</code></p> <p><code>input._array_from_string_hex(n)</code> splits the input string to <code>n</code> characters each, then converts each component to numbers. Whitespaces are ignored.</p>"},{"location":"Minilib.Text.Hex/#_from_string_hex","title":"_from_string_hex","text":"<p>Type: <code>Std::I64 -&gt; Std::String -&gt; Std::Result Std::ErrMsg Std::U64</code></p> <p><code>input._from_string_hex(n)</code> converts a hex string of <code>1..n</code> characters to a 64bit number.</p>"},{"location":"Minilib.Text.Hex/#_to_string_hex","title":"_to_string_hex","text":"<p>Type: <code>Std::I64 -&gt; Std::U64 -&gt; Std::String</code></p> <p><code>input._to_string_hex(n)</code> converts least significant <code>4 * n</code> bits of <code>input</code> to a hex string of <code>n</code> characters.</p>"},{"location":"Minilib.Text.Hex/#decode_hex_char","title":"decode_hex_char","text":"<p>Type: <code>Std::U8 -&gt; Std::Result Std::ErrMsg Std::U8</code></p> <p>Converts a hex character ('0'..'9', 'A'..'F' or 'a'..'f') to a 4bit number (0..15).</p>"},{"location":"Minilib.Text.Hex/#encode_hex_char","title":"encode_hex_char","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>Converts a 4bit number (0..15) to a hex character ('0'..'9', 'a'..'f').</p>"},{"location":"Minilib.Text.Hex/#namespace-minilibtexthexfromstringhex","title":"namespace Minilib.Text.Hex::FromStringHex","text":""},{"location":"Minilib.Text.Hex/#from_string_hex","title":"from_string_hex","text":"<p>Type: <code>[a : Minilib.Text.Hex::FromStringHex] Std::String -&gt; Std::Result Std::ErrMsg a</code></p>"},{"location":"Minilib.Text.Hex/#namespace-minilibtexthextostringhex","title":"namespace Minilib.Text.Hex::ToStringHex","text":""},{"location":"Minilib.Text.Hex/#to_string_hex","title":"to_string_hex","text":"<p>Type: <code>[a : Minilib.Text.Hex::ToStringHex] a -&gt; Std::String</code></p>"},{"location":"Minilib.Text.Hex/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Text.Hex/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Text.Hex/#namespace-minilibtexthex_1","title":"namespace Minilib.Text.Hex","text":""},{"location":"Minilib.Text.Hex/#trait-a-fromstringhex","title":"trait <code>a : FromStringHex</code>","text":""},{"location":"Minilib.Text.Hex/#method-from_string_hex","title":"method <code>from_string_hex</code>","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::String a</code></p>"},{"location":"Minilib.Text.Hex/#trait-a-tostringhex","title":"trait <code>a : ToStringHex</code>","text":""},{"location":"Minilib.Text.Hex/#method-to_string_hex","title":"method <code>to_string_hex</code>","text":"<p>Type: <code>a -&gt; Std::String</code></p>"},{"location":"Minilib.Text.Hex/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Text.Hex/#impl-stdarray-stdu8-minilibtexthexfromstringhex","title":"impl <code>Std::Array Std::U8 : Minilib.Text.Hex::FromStringHex</code>","text":"<p>Converts a byte array from a hex string. For example, <code>\"a5b6\".from_string_hex == ok $ [ 0xa5_U8, 0xb6_U8 ]</code>. Whitespaces are ignored.</p>"},{"location":"Minilib.Text.Hex/#impl-a-minilibtexthextostringhex-stdarray-a-minilibtexthextostringhex","title":"impl <code>[a : Minilib.Text.Hex::ToStringHex] Std::Array a : Minilib.Text.Hex::ToStringHex</code>","text":"<p>Converts an array to a hex string by concatenation. For example, <code>[ 0xa5_U8, 0xb6_U8 ].to_hex_string == \"a5b6\"</code>.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu16-minilibtexthexfromstringhex","title":"impl <code>Std::U16 : Minilib.Text.Hex::FromStringHex</code>","text":"<p>Converts a hex string of 1..4 characters to U16.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu16-minilibtexthextostringhex","title":"impl <code>Std::U16 : Minilib.Text.Hex::ToStringHex</code>","text":"<p>Converts U16 to a hex string of 4 characters. For example, <code>0x0a1b_U16.to_hex_string == \"0a1b\"</code>.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu32-minilibtexthexfromstringhex","title":"impl <code>Std::U32 : Minilib.Text.Hex::FromStringHex</code>","text":"<p>Converts a hex string of 1..8 characters to U32.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu32-minilibtexthextostringhex","title":"impl <code>Std::U32 : Minilib.Text.Hex::ToStringHex</code>","text":"<p>Converts U32 to a hex string of 8 characters. For example, <code>0xdeadbeef_U32.to_hex_string == \"deadbeef\"</code>.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu64-minilibtexthexfromstringhex","title":"impl <code>Std::U64 : Minilib.Text.Hex::FromStringHex</code>","text":"<p>Converts a hex string of 1..16 characters to U64.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu64-minilibtexthextostringhex","title":"impl <code>Std::U64 : Minilib.Text.Hex::ToStringHex</code>","text":"<p>Converts U64 to a hex string of 16 characters. For example, <code>0xa5b6_U64.to_hex_string == \"000000000000a5b6\"</code>.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu8-minilibtexthexfromstringhex","title":"impl <code>Std::U8 : Minilib.Text.Hex::FromStringHex</code>","text":"<p>Converts a hex string of 1..2 characters to U8.</p>"},{"location":"Minilib.Text.Hex/#impl-stdu8-minilibtexthextostringhex","title":"impl <code>Std::U8 : Minilib.Text.Hex::ToStringHex</code>","text":"<p>Converts U8 to a hex string of 2 characters. For example, <code>0x03_U8.to_hex_string == \"03\"</code>.</p>"},{"location":"Minilib.Text.SimpleParser/","title":"Minilib.Text.SimpleParser","text":"<p>Defined in minilib-text@0.5.2</p> <p>Simple text parser. Customizable by monadic operations. - Stream of characters - Basic parsers such as character matching - Create complex parsers with composition</p>"},{"location":"Minilib.Text.SimpleParser/#values","title":"Values","text":""},{"location":"Minilib.Text.SimpleParser/#namespace-minilibtextsimpleparser","title":"namespace Minilib.Text.SimpleParser","text":""},{"location":"Minilib.Text.SimpleParser/#_notmatch","title":"_NotMatch","text":"<p>Type: <code>Std::ErrMsg</code></p> <p>A special error message that represents the parser is not matched.</p>"},{"location":"Minilib.Text.SimpleParser/#parser","title":"parser","text":"<p>Type: <code>(Minilib.Text.SimpleParser::Stream::Stream -&gt; Minilib.Text.SimpleParser::ParseResult a) -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>A function that creates a Parser structure based on the parsing function.</p>"},{"location":"Minilib.Text.SimpleParser/#namespace-minilibtextsimpleparserparser","title":"namespace Minilib.Text.SimpleParser::Parser","text":""},{"location":"Minilib.Text.SimpleParser/#debug","title":"debug","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>Prints the parser result.</p>"},{"location":"Minilib.Text.SimpleParser/#error_parser","title":"error_parser","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>Raises the specified string as an error.</p>"},{"location":"Minilib.Text.SimpleParser/#filter","title":"filter","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>Checks whether the parsed result of the specified Parser satisfies the specified conditions. Raises a <code>_NotMatch</code> error if the specified condition is not met.</p>"},{"location":"Minilib.Text.SimpleParser/#get_stream","title":"get_stream","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Stream::Stream</code></p> <p>Returns the current stream position.</p>"},{"location":"Minilib.Text.SimpleParser/#if_exists","title":"if_exists","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser (Std::Option a)</code></p> <p><code>p.if_exists</code> returns <code>some(x)</code> if <code>p</code> returns <code>x</code> as a parse result, or <code>none()</code> if <code>p</code> does not match.</p>"},{"location":"Minilib.Text.SimpleParser/#map_result","title":"map_result","text":"<p>Type: <code>(a -&gt; Std::Result Std::ErrMsg b) -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser b</code></p> <p><code>parser.map_result(f)</code> maps the parser result with <code>f</code>, possibly reports an error message.</p>"},{"location":"Minilib.Text.SimpleParser/#match_any_char","title":"match_any_char","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Char</code></p> <p>Matches any single character. The parsed result is a single matched character. If the match fails (eg. the end of stream), a <code>_NotMatch</code> error is raised.</p>"},{"location":"Minilib.Text.SimpleParser/#match_char","title":"match_char","text":"<p>Type: <code>Minilib.Text.SimpleParser::Char -&gt; Minilib.Text.SimpleParser::Parser ()</code></p> <p>Matches a single character specified by the argument. The parsed result is nothing. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"Minilib.Text.SimpleParser/#match_char_class","title":"match_char_class","text":"<p>Type: <code>(Minilib.Text.SimpleParser::Char -&gt; Std::Bool) -&gt; Minilib.Text.SimpleParser::Parser Minilib.Text.SimpleParser::Char</code></p> <p>Matches a character satisfying the specified condition.</p>"},{"location":"Minilib.Text.SimpleParser/#match_char_if_exists","title":"match_char_if_exists","text":"<p>Type: <code>Std::U8 -&gt; Minilib.Text.SimpleParser::Parser (Std::Option Std::U8)</code></p> <p>Matches a single character if it exists. The parsed result is <code>some(c)</code> if it exists, <code>none()</code> if it does not exist.</p>"},{"location":"Minilib.Text.SimpleParser/#match_empty_str","title":"match_empty_str","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-length string.</p>"},{"location":"Minilib.Text.SimpleParser/#match_end_of_stream","title":"match_end_of_stream","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>Matches zero-length string at the end of stream.</p>"},{"location":"Minilib.Text.SimpleParser/#match_integer","title":"match_integer","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::I64</code></p> <p>Matches an integer.</p>"},{"location":"Minilib.Text.SimpleParser/#match_one_of_char","title":"match_one_of_char","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a character which is included in the specified string. The parsed result is a string consisting of the single matched character. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"Minilib.Text.SimpleParser/#match_str","title":"match_str","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser ()</code></p> <p>Matches a string specified by the argument. The parsed result is nothing. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"Minilib.Text.SimpleParser/#match_str_class","title":"match_str_class","text":"<p>Type: <code>(Minilib.Text.SimpleParser::Char -&gt; Std::Bool) -&gt; Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string. Each character should satisfy the specified condition.</p>"},{"location":"Minilib.Text.SimpleParser/#match_str_class_digit","title":"match_str_class_digit","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of digit characters.</p>"},{"location":"Minilib.Text.SimpleParser/#match_str_class_lower","title":"match_str_class_lower","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of lowercase characters.</p>"},{"location":"Minilib.Text.SimpleParser/#match_str_class_whitespace","title":"match_str_class_whitespace","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of whitespace characters.</p>"},{"location":"Minilib.Text.SimpleParser/#not_match","title":"not_match","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a</code></p> <p>Raises a <code>_NotMatch</code> error.</p>"},{"location":"Minilib.Text.SimpleParser/#one_or_more","title":"one_or_more","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser (Std::Array a)</code></p> <p>Same as <code>zero_or_more</code>, but raises a _NotMatch error if the array length is zero.</p>"},{"location":"Minilib.Text.SimpleParser/#or_else","title":"or_else","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>If the first Parser raises a <code>_NotMatch</code> error, tries the second Parser. Note that <code>pa1.or_else(pa2)</code> is interpreted as <code>or_else(pa2, pa1)</code>, and  that <code>pa1.or_else $ pa2</code> is interpreted as <code>or_else(pa1, pa2)</code>.</p>"},{"location":"Minilib.Text.SimpleParser/#or_elsef","title":"or_elseF","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>Flipped version of <code>or_else</code>. <code>pa1.or_elseF $ pa2</code> is equivalent to <code>pa1.or_else(pa2)</code>.</p>"},{"location":"Minilib.Text.SimpleParser/#or_error","title":"or_error","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser a</code></p> <p>If the Parser reports any error (including <code>_NotMatch</code>), raises the specified string as an error.</p>"},{"location":"Minilib.Text.SimpleParser/#repeat","title":"repeat","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser (Std::Array a)</code></p> <p>Repeats matches as many as possible. The parse result is an array of successful matches. If a _NotMatch error is raised, returns as success. If an error other than _NotMatch is raised, reports that error.</p>"},{"location":"Minilib.Text.SimpleParser/#run_parser","title":"run_parser","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::ParseResult a</code></p> <p>Apply a stream to a parsing function and return the parsed result.</p>"},{"location":"Minilib.Text.SimpleParser/#run_parser_str","title":"run_parser_str","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::ParseResult a</code></p> <p>Create a stream from a string, then apply a stream to a parsing function and return the parsed result.</p>"},{"location":"Minilib.Text.SimpleParser/#unit","title":"unit","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser ()</code></p> <p>Match zero-length string.</p>"},{"location":"Minilib.Text.SimpleParser/#zero_or_more","title":"zero_or_more","text":"<p>Type: <code>Minilib.Text.SimpleParser::Parser a -&gt; Minilib.Text.SimpleParser::Parser (Std::Array a)</code></p> <p>Synonym for <code>repeat</code>.</p>"},{"location":"Minilib.Text.SimpleParser/#namespace-minilibtextsimpleparserstream","title":"namespace Minilib.Text.SimpleParser::Stream","text":""},{"location":"Minilib.Text.SimpleParser/#advance","title":"advance","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream -&gt; Std::Option (Minilib.Text.SimpleParser::Char, Minilib.Text.SimpleParser::Stream::Stream)</code></p> <p><code>stream.advance</code> gets next character and increment the stream position.</p>"},{"location":"Minilib.Text.SimpleParser/#empty","title":"empty","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream</code></p> <p>An empty Stream.</p>"},{"location":"Minilib.Text.SimpleParser/#error","title":"error","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Stream::Stream -&gt; Std::Result Std::ErrMsg a</code></p> <p><code>stream.error(str)</code> reports an error along with where it occurred.</p>"},{"location":"Minilib.Text.SimpleParser/#make","title":"make","text":"<p>Type: <code>Std::String -&gt; Minilib.Text.SimpleParser::Stream::Stream</code></p> <p>Creates a stream from specified string.</p>"},{"location":"Minilib.Text.SimpleParser/#read_all","title":"read_all","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream -&gt; (Std::Array Minilib.Text.SimpleParser::Char, Minilib.Text.SimpleParser::Stream::Stream)</code></p> <p><code>stream.read_all</code> reads all characters to the end of stream.</p>"},{"location":"Minilib.Text.SimpleParser/#read_string","title":"read_string","text":"<p>Type: <code>Std::I64 -&gt; Minilib.Text.SimpleParser::Stream::Stream -&gt; Std::String</code></p> <p><code>stream.read_string(n)</code> reads at most <code>n</code> characters and convert them to a string.</p>"},{"location":"Minilib.Text.SimpleParser/#read_string_between","title":"read_string_between","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream -&gt; Minilib.Text.SimpleParser::Stream::Stream -&gt; Std::String</code></p> <p><code>start_stream.read_string_between(end_stream)</code> reads characters from <code>start_stream</code> to <code>end_stream</code>  and convert them to a string.</p>"},{"location":"Minilib.Text.SimpleParser/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Text.SimpleParser/#namespace-minilibtextsimpleparser_1","title":"namespace Minilib.Text.SimpleParser","text":""},{"location":"Minilib.Text.SimpleParser/#char","title":"Char","text":"<p>Defined as: <code>type Char = Std::U8</code></p> <p>The type of characters. Currently only UTF-8 string is supported.</p>"},{"location":"Minilib.Text.SimpleParser/#parseresult","title":"ParseResult","text":"<p>Defined as: <code>type ParseResult a = Std::Result Std::ErrMsg (a, Minilib.Text.SimpleParser::Stream::Stream)</code></p> <p>Result type that returns a value of an arbitrary type and a stream.</p>"},{"location":"Minilib.Text.SimpleParser/#parser_1","title":"Parser","text":"<p>Defined as: <code>type Parser a = unbox struct { ...fields... }</code></p> <p>A structure with a function that receive a stream, parse it, and return the parsed result and the next stream position.</p>"},{"location":"Minilib.Text.SimpleParser/#field-_parser","title":"field <code>_parser</code>","text":"<p>Type: <code>Minilib.Text.SimpleParser::Stream::Stream -&gt; Minilib.Text.SimpleParser::ParseResult a</code></p>"},{"location":"Minilib.Text.SimpleParser/#namespace-minilibtextsimpleparserstream_1","title":"namespace Minilib.Text.SimpleParser::Stream","text":""},{"location":"Minilib.Text.SimpleParser/#stream","title":"Stream","text":"<p>Defined as: <code>type Stream = unbox struct { ...fields... }</code></p> <p>A character iterator that stores the file name, line number, column number, and offset from the beginning of the file.</p>"},{"location":"Minilib.Text.SimpleParser/#field-filename","title":"field <code>filename</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Minilib.Text.SimpleParser/#field-line","title":"field <code>line</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Text.SimpleParser/#field-column","title":"field <code>column</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Text.SimpleParser/#field-position","title":"field <code>position</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Minilib.Text.SimpleParser/#field-iter","title":"field <code>iter</code>","text":"<p>Type: <code>Std::Iterator::DynIterator Minilib.Text.SimpleParser::Char</code></p>"},{"location":"Minilib.Text.SimpleParser/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Text.SimpleParser/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Text.SimpleParser/#impl-minilibtextsimpleparserparser-stdfunctor","title":"impl <code>Minilib.Text.SimpleParser::Parser : Std::Functor</code>","text":""},{"location":"Minilib.Text.SimpleParser/#impl-minilibtextsimpleparserparser-stdmonad","title":"impl <code>Minilib.Text.SimpleParser::Parser : Std::Monad</code>","text":""},{"location":"Minilib.Text.SimpleParser/#impl-minilibtextsimpleparserstreamstream-stdfromstring","title":"impl <code>Minilib.Text.SimpleParser::Stream::Stream : Std::FromString</code>","text":"<p>Creates a stream from a string.</p>"},{"location":"Minilib.Text.SimpleParser/#impl-minilibtextsimpleparserstreamstream-stdtostring","title":"impl <code>Minilib.Text.SimpleParser::Stream::Stream : Std::ToString</code>","text":"<p>Converts a stream to a string, for example <code>\"Stream(pos=1001)\"</code></p>"},{"location":"Minilib.Text.StringEx/","title":"Minilib.Text.StringEx","text":"<p>Defined in minilib-common@0.5.2</p> <p>String utility functions.</p> <p>Features: - Array U8 -&gt; String conversion - Search, replace, split, comparison of String - Format</p>"},{"location":"Minilib.Text.StringEx/#values","title":"Values","text":""},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringex","title":"namespace Minilib.Text.StringEx","text":""},{"location":"Minilib.Text.StringEx/#_append_range","title":"_append_range","text":"<p>Type: <code>Std::Array a -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>(Internal function)</p>"},{"location":"Minilib.Text.StringEx/#_unsafe_to_string","title":"_unsafe_to_string","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String</code></p> <p>Converts a byte array to a string. Specifically, it calls <code>String::_unsafe_to_string()</code> after appending a null character to the end of the byte array.</p> <p>Example:</p> <pre><code>[ 'a', 'b', 'c' ]._unsafe_to_string\n==&gt; \"abc\"\n[ 0x41_U8, 0x42_U8, 0x43_U8 ]._unsafe_to_string\n==&gt; \"ABC\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#byte_to_string","title":"byte_to_string","text":"<p>Type: <code>Std::U8 -&gt; Std::String</code></p> <p>Deprecated: Please use <code>Std::String::from_U8</code>.</p> <p>Converts a byte (a character) to a string of length 1.</p> <p>Example:</p> <pre><code>0x41_U8.byte_to_string\n==&gt; \"A\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#ends_with","title":"ends_with","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Bool</code></p> <p>Checks if a string ends with the specified suffix.</p> <p>Example:</p> <pre><code>\"/foo/bar.txt\".ends_with(\".txt\")\n==&gt; true\n\"foo/bar.txt\".ends_with(\".bin\")\n==&gt; false\n</code></pre>"},{"location":"Minilib.Text.StringEx/#find_byte","title":"find_byte","text":"<p>Type: <code>Std::U8 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p>Searches for the specified byte from the beginning of a string. If found, returns the index of that byte.</p> <p>Example:</p> <pre><code>\"aaa/bbb/ccc\".find_byte('/')\n==&gt; some(3)\n\"aaa\".find_byte('/')\n==&gt; none()\n</code></pre>"},{"location":"Minilib.Text.StringEx/#find_last_byte","title":"find_last_byte","text":"<p>Type: <code>Std::U8 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p>Searches for the specified byte from the end of a string. If found, returns the index of that byte.</p> <p>Example:</p> <pre><code>\"aaa/bbb/ccc\".find_last_byte('/')\n==&gt; some(7)\n\"aaa\".find_last_byte('/')\n==&gt; none()\n</code></pre>"},{"location":"Minilib.Text.StringEx/#formatv","title":"formatv","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::String -&gt; Std::String</code></p> <p><code>array.formatv(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with each element of <code>array</code>. Currently only supports <code>{}</code>.</p> <p>Example:</p> <pre><code>[\"1\", \"2\", \"3\"].formatv(\"foo={} bar={} baz={}\")\n==&gt; \"foo=1 bar=2 baz=3\"\n[\"1\"].formatv(\"foo={} bar={} baz={}\")\n==&gt; \"foo=1 bar={} baz={}\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#replace_all","title":"replace_all","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String -&gt; Std::String</code></p> <p><code>input.replace_all(from, to)</code> replaces all occurrences of <code>from</code> in the input string with <code>to</code>. If <code>from</code> is empty, returns the input string unchanged.</p> <p>Example:</p> <pre><code>\"foo1:11,foo2:22,Foo3:33\".replace_all(\"foo\", \"piyo\")\n==&gt; \"piyo1:11,piyo2:22,Foo3:33\"\n\"foo1:11,foo2:22,Foo3:33\".replace_all(\"foo\", \"\")\n==&gt; \"1:11,2:22,Foo3:33\"\n\"foo1:11,foo2:22,Foo3:33\".replace_all(\"\", \"piyo\")\n==&gt; \"foo1:11,foo2:22,Foo3:33\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#replace_suffix","title":"replace_suffix","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p><code>str.replace_suffix(from, to)</code> replaces <code>from</code> at the end of <code>str</code> with <code>to</code>. if <code>str</code> does not end with <code>from</code>, an error occurs.</p> <p>Example:</p> <pre><code>\"test.txt\".replace_suffix(\".txt\", \".tmp\")\n ==&gt; ok(\"test.tmp\")\n\"test.jpg\".replace_suffix(\".txt\", \".tmp\")\n ==&gt; err(\"suffix does not match: test.jpg\")\n</code></pre>"},{"location":"Minilib.Text.StringEx/#split_by","title":"split_by","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; Std::Iterator::DynIterator Std::String</code></p> <p>Splits a string by a function that checks whether a character is a delimiter or not. The result will not contain any empty string.</p> <p>Example:</p> <pre><code>\"  aa bb  12 \".split_by(Character::is_space).to_array\n==&gt;  [\"aa\", \"bb\", \"12\"]\n</code></pre>"},{"location":"Minilib.Text.StringEx/#split_ex","title":"split_ex","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Iterator::DynIterator Std::String</code></p> <p>Deprecated: Please use <code>Std::String::split</code>.</p> <p>Same as Std::String::split, except that <code>\"foo\".split_ex(\",\")</code> returns a singleton iterator of \"foo\".</p> <p>Example:</p> <pre><code>\"foo,bar,baz\".split_ex(\",\").to_array\n==&gt; [\"foo\", \"bar\", \"baz\"]\n\"foo\".split_ex(\",\").to_array\n==&gt; [\"foo\"]\n</code></pre>"},{"location":"Minilib.Text.StringEx/#split_first","title":"split_first","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; (Std::String, Std::String)</code></p> <p><code>str.split_first(delim)</code> splits the string <code>str</code> into two parts at the first occurence of the delimiter <code>delim</code>. Returns <code>(left, right)</code> where <code>left</code> is the left part of the delimiter, and <code>right</code> is the right part of the delimiter. Returns <code>(str, \"\")</code> if the delimiter is not found.</p> <p>Example:</p> <pre><code>\"aaa/bbb/ccc\".split_first(\"/\")\n==&gt; (\"aaa\", \"bbb/ccc\")\n\"aaa/bbb/ccc\".split_first(\"bb\")\n==&gt; (\"aaa/\", \"b/ccc\")\n\"aaa/bbb/ccc\".split_first(\"!\")\n==&gt; (\"aaa/bbb/ccc\", \"\")\n</code></pre>"},{"location":"Minilib.Text.StringEx/#starts_with","title":"starts_with","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Bool</code></p> <p>Checks if a string starts with the specified prefix.</p> <p>Example:</p> <pre><code>\"/foo/bar.txt\".starts_with(\"/\")\n==&gt; true\n\"foo/bar.txt\".starts_with(\"/\")\n==&gt; false\n</code></pre>"},{"location":"Minilib.Text.StringEx/#subarray","title":"subarray","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Deprecated: Please use <code>Std::Array::get_sub</code>.</p> <p>Returns a subarray extracted from a specified range from an array. If the specified range exceeds the array, it will be truncated to fit within the array.</p> <p>Example:</p> <pre><code>[10, 11, 12, 13, 14].subarray(1, 2)\n==&gt; [11, 12]\n[10, 11, 12, 13, 14].subarray(0, 5)\n==&gt; [10, 11, 12, 13, 14]\n[10, 11, 12, 13, 14].subarray(-1, 6)\n==&gt; [10, 11, 12, 13, 14]\n</code></pre>"},{"location":"Minilib.Text.StringEx/#substring","title":"substring","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::String -&gt; Std::String</code></p> <p>Deprecated: Please use <code>Std::String::get_sub</code>.</p> <p>Returns a substring extracted from a specified range from a string. If the specified range exceeds the string, it will be truncated to fit within the string.</p> <p>Example:</p> <pre><code>\"abcdef\".substring(2, 3)\n==&gt; \"cde\"\n\"abcdef\".substring(0, 6)\n==&gt; \"abcdef\"\n\"abcdef\".substring(-1, 7)\n==&gt; \"abcdef\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#to_lower","title":"to_lower","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Converts the specified string to lowercase.</p> <p>Example:</p> <pre><code>\"ABCdef123\".to_lower\n==&gt; \"abcdef123\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#to_upper","title":"to_upper","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Converts the specified string to uppercase.</p> <p>Example:</p> <pre><code>\"ABCdef123\".to_upper\n==&gt; \"ABCDEF123\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringexarray","title":"namespace Minilib.Text.StringEx::Array","text":""},{"location":"Minilib.Text.StringEx/#format","title":"format","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; Std::Array a -&gt; Std::String</code></p> <p><code>array.format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with each element of <code>array</code>. Currently only supports <code>{}</code>.</p> <p>Example:</p> <pre><code>[some(1), some(2), none()].format(\"foo={} bar={} baz={}\")\n==&gt; \"foo=some(1) bar=some(2) baz=none()\"\n[some(1)].format(\"foo={} bar={} baz={}\")\n==&gt; \"foo=some(1) bar={} baz={}\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringextuple1","title":"namespace Minilib.Text.StringEx::Tuple1","text":""},{"location":"Minilib.Text.StringEx/#format_1","title":"format","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; (a,) -&gt; Std::String</code></p> <p><code>(a, ).format(str)</code> replaces an occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>.</p> <p>Example:</p> <pre><code>(12.345, ).format(\"float={}\")\n==&gt; \"float=12.345000\"\n([1, 2, 3], ).format(\"arr={}\")\n==&gt; \"arr=[1, 2, 3]\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringextuple2","title":"namespace Minilib.Text.StringEx::Tuple2","text":""},{"location":"Minilib.Text.StringEx/#format_2","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString] Std::String -&gt; (a, b) -&gt; Std::String</code></p> <p><code>(a, b).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>.</p> <p>Example:</p> <pre><code>(12, \"abc\").format(\"int={} str={}\")\n==&gt; \"int=12 str=abc\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringextuple3","title":"namespace Minilib.Text.StringEx::Tuple3","text":""},{"location":"Minilib.Text.StringEx/#format_3","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString, c : Std::ToString] Std::String -&gt; (a, b, c) -&gt; Std::String</code></p> <p><code>(a, b, c).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>, <code>c</code>.</p> <p>Example:</p> <pre><code>(12, 345.678, \"abc\").format(\"int={} float={} str={}\")\n==&gt; \"int=12 float=345.678000 str=abc\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringextuple4","title":"namespace Minilib.Text.StringEx::Tuple4","text":""},{"location":"Minilib.Text.StringEx/#format_4","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString, c : Std::ToString, d : Std::ToString] Std::String -&gt; (a, b, c, d) -&gt; Std::String</code></p> <p><code>(a, b, c, d).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>.</p> <p>Example:</p> <pre><code>(12, 345.678, \"abc\", some(1)).format(\"int={} float={} str={} option={}\")\n==&gt; \"int=12 float=345.678000 str=abc option=some(1)\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#namespace-minilibtextstringextuple5","title":"namespace Minilib.Text.StringEx::Tuple5","text":""},{"location":"Minilib.Text.StringEx/#format_5","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString, c : Std::ToString, d : Std::ToString, e : Std::ToString] Std::String -&gt; (a, b, c, d, e) -&gt; Std::String</code></p> <p><code>(a, b, c, d, e).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>.</p> <p>Example:</p> <pre><code>(12, 345.678, \"abc\", some(1), [1, 2, 3]).format(\"int={} float={} str={} option={} array={}\")\n==&gt; \"int=12 float=345.678000 str=abc option=some(1) array=[1, 2, 3]\"\n</code></pre>"},{"location":"Minilib.Text.StringEx/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Text.StringEx/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Text.StringEx/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Text.Unicode/","title":"Minilib.Text.Unicode","text":"<p>Defined in minilib-text@0.5.2</p> <p>Unicode conversions (UTF8 &lt;-&gt; UTF32 &lt;-&gt; UTF16)</p>"},{"location":"Minilib.Text.Unicode/#values","title":"Values","text":""},{"location":"Minilib.Text.Unicode/#namespace-minilibtextunicode","title":"namespace Minilib.Text.Unicode","text":""},{"location":"Minilib.Text.Unicode/#encode_code_point_to_utf8","title":"encode_code_point_to_utf8","text":"<p>Type: <code>Std::U32 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Encode a unicode code point to UTF-8</p>"},{"location":"Minilib.Text.Unicode/#utf16_to_utf32","title":"utf16_to_utf32","text":"<p>Type: <code>Std::Array Std::U16 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Convert UTF16 string to UTF32 string.</p>"},{"location":"Minilib.Text.Unicode/#utf32_to_utf16","title":"utf32_to_utf16","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U16 -&gt; Std::Array Std::U16</code></p> <p>Convert UTF32 string to UTF16 string.</p>"},{"location":"Minilib.Text.Unicode/#utf32_to_utf8","title":"utf32_to_utf8","text":"<p>Type: <code>Std::Array Std::U32 -&gt; Std::Array Std::U8 -&gt; Std::Array Std::U8</code></p> <p>Convert UTF32 string to UTF8 string. Please specify the output destination buffer.</p>"},{"location":"Minilib.Text.Unicode/#utf8_to_utf32","title":"utf8_to_utf32","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U32 -&gt; Std::Array Std::U32</code></p> <p>Convert UTF8 string to UTF32 string. Please specify the output destination buffer.</p>"},{"location":"Minilib.Text.Unicode/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Text.Unicode/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Text.Unicode/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Thread.Channel/","title":"Minilib.Thread.Channel","text":"<p>Defined in minilib-thread@0.5.1</p> <p>A Channel that can be used for the communication of threads.</p>"},{"location":"Minilib.Thread.Channel/#values","title":"Values","text":""},{"location":"Minilib.Thread.Channel/#namespace-minilibthreadchannel","title":"namespace Minilib.Thread.Channel","text":""},{"location":"Minilib.Thread.Channel/#clear","title":"clear","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO ()</code></p> <p><code>channel.clear</code> clears the queue of the channel.</p>"},{"location":"Minilib.Thread.Channel/#close","title":"close","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO ()</code></p> <p><code>channel.close</code> closes a channel. After close, <code>send()</code> will fail.</p>"},{"location":"Minilib.Thread.Channel/#closed_error","title":"closed_error","text":"<p>Type: <code>Std::ErrMsg</code></p> <p>An error message which is reported when the channel is closed.</p>"},{"location":"Minilib.Thread.Channel/#is_closed","title":"is_closed","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO Std::Bool</code></p> <p><code>channel.is_closed</code> checks whether the channel is closed.</p>"},{"location":"Minilib.Thread.Channel/#is_empty","title":"is_empty","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO Std::Bool</code></p> <p><code>channel.is_empty</code> checks whether the queue of the channel is empty.</p>"},{"location":"Minilib.Thread.Channel/#make","title":"make","text":"<p>Type: <code>Std::IO (Minilib.Thread.Channel::Channel a)</code></p> <p><code>Channel::make</code> creates a new channel.</p>"},{"location":"Minilib.Thread.Channel/#recv","title":"recv","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO::IOFail a</code></p> <p><code>channel.recv</code> receives a data from the queue of the channel. If the queue is empty, it waits until any data is sent, or the channel is closed. If the channel is closed and the queue is empty, it throws <code>closed_error</code>.</p>"},{"location":"Minilib.Thread.Channel/#send","title":"send","text":"<p>Type: <code>a -&gt; Minilib.Thread.Channel::Channel a -&gt; Std::IO::IOFail ()</code></p> <p><code>channel.send(a)</code> sends a data to the queue of the channel. If the channel is closed, it throws <code>closed_error</code>.</p>"},{"location":"Minilib.Thread.Channel/#take_and_clear","title":"take_and_clear","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO (Std::Iterator::DynIterator a)</code></p> <p><code>channel.take_and_clear</code> takes all items away from the queue of the channel and clears the queue. This function can be used after the channel is closed.</p>"},{"location":"Minilib.Thread.Channel/#try_recv","title":"try_recv","text":"<p>Type: <code>Minilib.Thread.Channel::Channel a -&gt; Std::IO::IOFail (Std::Option a)</code></p> <p><code>channel.recv</code> tries to receive a data from a channel. If there is no data, <code>none</code> is returned. If the channel is closed and the queue is empty, it throws <code>closed_error</code>.</p>"},{"location":"Minilib.Thread.Channel/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Thread.Channel/#namespace-minilibthreadchannel_1","title":"namespace Minilib.Thread.Channel","text":""},{"location":"Minilib.Thread.Channel/#channel","title":"Channel","text":"<p>Defined as: <code>type Channel a = unbox struct { ...fields... }</code></p> <p>A Channel that can be used for the communication of threads.</p>"},{"location":"Minilib.Thread.Channel/#field-var","title":"field <code>var</code>","text":"<p>Type: <code>AsyncTask::Var::Var (Minilib.Thread.Channel::ChannelData a)</code></p>"},{"location":"Minilib.Thread.Channel/#channeldata","title":"ChannelData","text":"<p>Defined as: <code>type ChannelData a = unbox struct { ...fields... }</code></p> <p>The channel data</p>"},{"location":"Minilib.Thread.Channel/#field-deque","title":"field <code>deque</code>","text":"<p>Type: <code>Minilib.Collection.Deque::Deque a</code></p>"},{"location":"Minilib.Thread.Channel/#field-closed","title":"field <code>closed</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Minilib.Thread.Channel/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Thread.Channel/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Thread.Future/","title":"Minilib.Thread.Future","text":"<p>Defined in minilib-thread@0.5.1</p> <p>A computation that is performed in a TaskPool in parallel.</p>"},{"location":"Minilib.Thread.Future/#values","title":"Values","text":""},{"location":"Minilib.Thread.Future/#namespace-minilibthreadfuture","title":"namespace Minilib.Thread.Future","text":""},{"location":"Minilib.Thread.Future/#get","title":"get","text":"<p>Type: <code>Minilib.Thread.Future::Future a -&gt; Std::IO::IOFail a</code></p> <p>Gets the result of the Future. It waits for future state to be either completed or canceled.</p>"},{"location":"Minilib.Thread.Future/#make","title":"make","text":"<p>Type: <code>Minilib.Thread.TaskPool::TaskPool -&gt; Std::IO a -&gt; Std::IO::IOFail (Minilib.Thread.Future::Future a)</code></p> <p><code>Future::make(task_pool, io) creates a Future.</code>io` is performed in the task pool. If the task pool has been shutdown, an error is thrown.</p>"},{"location":"Minilib.Thread.Future/#namespace-minilibthreadfuturefuturetoken","title":"namespace Minilib.Thread.Future::FutureToken","text":""},{"location":"Minilib.Thread.Future/#make_1","title":"make","text":"<p>Type: <code>AsyncTask::Var::Var Minilib.Thread.Future::FutureState -&gt; Std::IO () -&gt; Minilib.Thread.Future::FutureToken</code></p>"},{"location":"Minilib.Thread.Future/#set_state","title":"set_state","text":"<p>Type: <code>Minilib.Thread.Future::FutureState -&gt; Minilib.Thread.Future::FutureToken -&gt; Std::IO ()</code></p>"},{"location":"Minilib.Thread.Future/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Thread.Future/#namespace-minilibthreadfuture_1","title":"namespace Minilib.Thread.Future","text":""},{"location":"Minilib.Thread.Future/#future","title":"Future","text":"<p>Defined as: <code>type Future a = unbox struct { ...fields... }</code></p> <p>A computation that is performed in a TaskPool in parallel.</p>"},{"location":"Minilib.Thread.Future/#field-var_state","title":"field <code>var_state</code>","text":"<p>Type: <code>AsyncTask::Var::Var Minilib.Thread.Future::FutureState</code></p>"},{"location":"Minilib.Thread.Future/#field-var_result","title":"field <code>var_result</code>","text":"<p>Type: <code>AsyncTask::Var::Var (Std::Option a)</code></p>"},{"location":"Minilib.Thread.Future/#futurestate","title":"FutureState","text":"<p>Defined as: <code>type FutureState = unbox union { ...variants... }</code></p> <p>A state of a future.</p>"},{"location":"Minilib.Thread.Future/#variant-pending","title":"variant <code>pending</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Thread.Future/#variant-running","title":"variant <code>running</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Thread.Future/#variant-completed","title":"variant <code>completed</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Thread.Future/#variant-canceled","title":"variant <code>canceled</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Minilib.Thread.Future/#futuretoken","title":"FutureToken","text":"<p>Defined as: <code>type FutureToken = unbox struct { ...fields... }</code></p> <p>[nofixdoc] A token of a future for the taskpool. Since the taskpool has no type variable, it cannot perform <code>IO a</code>. So the future token has <code>IO ()</code>.</p>"},{"location":"Minilib.Thread.Future/#field-var_state_1","title":"field <code>var_state</code>","text":"<p>Type: <code>AsyncTask::Var::Var Minilib.Thread.Future::FutureState</code></p>"},{"location":"Minilib.Thread.Future/#field-io_unit","title":"field <code>io_unit</code>","text":"<p>Type: <code>Std::IO ()</code></p>"},{"location":"Minilib.Thread.Future/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Thread.Future/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Thread.TaskPool/","title":"Minilib.Thread.TaskPool","text":"<p>Defined in minilib-thread@0.5.1</p> <p>A task pool that can be used parallel computation.</p> <p>A task pool creates IOTasks and starts them. Each task waits for request until shutdown. When the task receives the request, it performs the request as a computation. When the task pool is shutdown, all tasks are stopped. Computations are never performed after shutdown.</p>"},{"location":"Minilib.Thread.TaskPool/#values","title":"Values","text":""},{"location":"Minilib.Thread.TaskPool/#namespace-minilibthreadtaskpool","title":"namespace Minilib.Thread.TaskPool","text":""},{"location":"Minilib.Thread.TaskPool/#_task_func","title":"_task_func","text":"<p>Type: <code>Minilib.Thread.Channel::Channel Minilib.Thread.Future::FutureToken -&gt; Std::IO ()</code></p> <p>The task function of the taskpool.</p>"},{"location":"Minilib.Thread.TaskPool/#cancel_all_pendings_futures","title":"cancel_all_pendings_futures","text":"<p>Type: <code>Minilib.Thread.TaskPool::TaskPool -&gt; Std::IO ()</code></p> <p>Cancel all pending futures and clears the queue.</p>"},{"location":"Minilib.Thread.TaskPool/#is_shutdown","title":"is_shutdown","text":"<p>Type: <code>Minilib.Thread.TaskPool::TaskPool -&gt; Std::IO Std::Bool</code></p> <p>Checks whether the taskpool has been shutdown.</p>"},{"location":"Minilib.Thread.TaskPool/#make","title":"make","text":"<p>Type: <code>Std::I64 -&gt; Std::IO Minilib.Thread.TaskPool::TaskPool</code></p> <p><code>TaskPool::make(task_count)</code> creates a TaskPool.</p>"},{"location":"Minilib.Thread.TaskPool/#register_future","title":"register_future","text":"<p>Type: <code>Minilib.Thread.Future::FutureToken -&gt; Minilib.Thread.TaskPool::TaskPool -&gt; Std::IO::IOFail ()</code></p> <p>Register a future. It sends a future token to the channel.</p>"},{"location":"Minilib.Thread.TaskPool/#shutdown","title":"shutdown","text":"<p>Type: <code>Minilib.Thread.TaskPool::TaskPool -&gt; Std::IO Minilib.Thread.TaskPool::TaskPool</code></p> <p>Shutdowns a taskpool.</p>"},{"location":"Minilib.Thread.TaskPool/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Thread.TaskPool/#namespace-minilibthreadtaskpool_1","title":"namespace Minilib.Thread.TaskPool","text":""},{"location":"Minilib.Thread.TaskPool/#taskpool","title":"TaskPool","text":"<p>Defined as: <code>type TaskPool = unbox struct { ...fields... }</code></p> <p>A task pool that manages a collection of IOTasks.</p>"},{"location":"Minilib.Thread.TaskPool/#field-chan","title":"field <code>chan</code>","text":"<p>Type: <code>Minilib.Thread.Channel::Channel Minilib.Thread.Future::FutureToken</code></p>"},{"location":"Minilib.Thread.TaskPool/#field-tasks","title":"field <code>tasks</code>","text":"<p>Type: <code>Std::Array (AsyncTask::AsyncIOTask::IOTask ())</code></p>"},{"location":"Minilib.Thread.TaskPool/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Thread.TaskPool/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Comonad/","title":"Minilib.Trait.Comonad","text":"<p>Defined in minilib-comonad@0.5.1</p> <p>Comonad trait and associated functions.</p> <p>For details, see web sites below. - Comonads in Haskell - Haskell: Control.Comonad</p>"},{"location":"Minilib.Trait.Comonad/#values","title":"Values","text":""},{"location":"Minilib.Trait.Comonad/#namespace-minilibtraitcomonadcomonad","title":"namespace Minilib.Trait.Comonad::Comonad","text":""},{"location":"Minilib.Trait.Comonad/#duplicate","title":"duplicate","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] w a -&gt; w (w a)</code></p> <p>Duplicates a comonad.</p>"},{"location":"Minilib.Trait.Comonad/#extend","title":"extend","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] (w b -&gt; a) -&gt; w b -&gt; w a</code></p> <p>Extends a comonad with a function.</p>"},{"location":"Minilib.Trait.Comonad/#extendf","title":"extendF","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] w b -&gt; (w b -&gt; a) -&gt; w a</code></p> <p>Flipped version of <code>extend</code>.</p>"},{"location":"Minilib.Trait.Comonad/#extract","title":"extract","text":"<p>Type: <code>[w : Minilib.Trait.Comonad::Comonad] w a -&gt; a</code></p> <p>Extracts a value from a comonad.</p>"},{"location":"Minilib.Trait.Comonad/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Comonad/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Comonad/#namespace-minilibtraitcomonad","title":"namespace Minilib.Trait.Comonad","text":""},{"location":"Minilib.Trait.Comonad/#trait-w-w-comonad","title":"trait <code>[w : *-&gt;*] w : Comonad</code>","text":""},{"location":"Minilib.Trait.Comonad/#method-extract","title":"method <code>extract</code>","text":"<p>Type: <code>w a -&gt; a</code></p> <p>Extracts a value from a comonad.</p>"},{"location":"Minilib.Trait.Comonad/#method-extend","title":"method <code>extend</code>","text":"<p>Type: <code>(w b -&gt; a) -&gt; w b -&gt; w a</code></p> <p>Extends a comonad with a function.</p>"},{"location":"Minilib.Trait.Comonad/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Lifter/","title":"Minilib.Trait.Lifter","text":"<p>Defined in minilib-random@0.5.2</p> <p>A trait which converts a value of a type to a value of another type.</p>"},{"location":"Minilib.Trait.Lifter/#values","title":"Values","text":""},{"location":"Minilib.Trait.Lifter/#namespace-minilibtraitlifterlifter","title":"namespace Minilib.Trait.Lifter::Lifter","text":""},{"location":"Minilib.Trait.Lifter/#lift_from","title":"lift_from","text":"<p>Type: <code>[lf : Minilib.Trait.Lifter::Lifter] Minilib.Trait.Lifter::Lifter::LiftFrom lf -&gt; lf -&gt; Minilib.Trait.Lifter::Lifter::LiftTo lf</code></p> <p>Converts a value of type <code>LiftFrom lf</code> to a value of type <code>LiftTo lf</code>. NOTE: The second argument <code>lf</code> is ignored. It is required to select the implementation of <code>Lifter</code> trait.</p>"},{"location":"Minilib.Trait.Lifter/#lifter","title":"lifter","text":"<p>Type: <code>[lf : Minilib.Trait.Lifter::Lifter] lf</code></p> <p>A singleton instance of the lifter. NOTE: This instance is required to select the implementation of <code>Lifter</code> trait.</p>"},{"location":"Minilib.Trait.Lifter/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Lifter/#namespace-minilibtraitlifter","title":"namespace Minilib.Trait.Lifter","text":""},{"location":"Minilib.Trait.Lifter/#lifterimpl","title":"LifterImpl","text":"<p>Defined as: <code>type LifterImpl from to = unbox struct { ...fields... }</code></p> <p>An empty structure for <code>Lifter</code> implementation.</p>"},{"location":"Minilib.Trait.Lifter/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Lifter/#namespace-minilibtraitlifter_1","title":"namespace Minilib.Trait.Lifter","text":""},{"location":"Minilib.Trait.Lifter/#trait-lf-lifter","title":"trait <code>lf : Lifter</code>","text":"<p>A trait which converts a value of a type to a value of another type.</p>"},{"location":"Minilib.Trait.Lifter/#type-liftto","title":"type <code>LiftTo</code>","text":"<p>Defined as: <code>LiftTo lf</code></p> <p>A type that the <code>lifter</code> converts to.</p>"},{"location":"Minilib.Trait.Lifter/#type-liftfrom","title":"type <code>LiftFrom</code>","text":"<p>Defined as: <code>LiftFrom lf</code></p> <p>A type that the <code>lifter</code> converts from.</p>"},{"location":"Minilib.Trait.Lifter/#method-lifter","title":"method <code>lifter</code>","text":"<p>Type: <code>lf</code></p> <p>A singleton instance of the lifter. NOTE: This instance is required to select the implementation of <code>Lifter</code> trait.</p>"},{"location":"Minilib.Trait.Lifter/#method-lift_from","title":"method <code>lift_from</code>","text":"<p>Type: <code>Minilib.Trait.Lifter::Lifter::LiftFrom lf -&gt; lf -&gt; Minilib.Trait.Lifter::Lifter::LiftTo lf</code></p> <p>Converts a value of type <code>LiftFrom lf</code> to a value of type <code>LiftTo lf</code>. NOTE: The second argument <code>lf</code> is ignored. It is required to select the implementation of <code>Lifter</code> trait.</p>"},{"location":"Minilib.Trait.Lifter/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Lifter/#impl-m-stdmonad-minilibtraitlifterlifterimpl-minilibmonadidentityidentity-a-m-a-minilibtraitlifterlifter","title":"impl <code>[m : Std::Monad] Minilib.Trait.Lifter::LifterImpl (Minilib.Monad.Identity::Identity a) (m a) : Minilib.Trait.Lifter::Lifter</code>","text":"<p>A lifter implementation which lifts <code>Identity</code> monad to any monad.</p>"},{"location":"Minilib.Trait.Lifter/#impl-m-minilibmonadiomonadio-minilibtraitlifterlifterimpl-stdio-a-m-a-minilibtraitlifterlifter","title":"impl <code>[m : Minilib.Monad.IO::MonadIO] Minilib.Trait.Lifter::LifterImpl (Std::IO a) (m a) : Minilib.Trait.Lifter::Lifter</code>","text":"<p>A lifter implementation which lifts <code>IO</code> monad to a monad of <code>MonadIO</code>.</p>"},{"location":"Minilib.Trait.Lifter/#impl-m-minilibmonadiomonadiofail-minilibtraitlifterlifterimpl-stdioiofail-a-m-a-minilibtraitlifterlifter","title":"impl <code>[m : Minilib.Monad.IO::MonadIOFail] Minilib.Trait.Lifter::LifterImpl (Std::IO::IOFail a) (m a) : Minilib.Trait.Lifter::Lifter</code>","text":"<p>A lifter implementation which lifts <code>IOFail</code> monad to a monad of <code>MonadIOFail</code>.</p>"},{"location":"Minilib.Trait.Monoid/","title":"Minilib.Trait.Monoid","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Monoid trait and its several implementations (Array, Iterator, String etc).</p> <p>Monoid is a semigroup with an identity.</p> <p>For details, see Wikipedia: Monoid.</p>"},{"location":"Minilib.Trait.Monoid/#values","title":"Values","text":""},{"location":"Minilib.Trait.Monoid/#namespace-minilibtraitmonoid","title":"namespace Minilib.Trait.Monoid","text":""},{"location":"Minilib.Trait.Monoid/#mconcat","title":"mconcat","text":"<p>Type: <code>[a : Minilib.Trait.Monoid::Monoid] Std::Iterator::DynIterator a -&gt; a</code></p> <p>Concats an iterator of monoids to a monoid.</p>"},{"location":"Minilib.Trait.Monoid/#namespace-minilibtraitmonoidmempty","title":"namespace Minilib.Trait.Monoid::MEmpty","text":""},{"location":"Minilib.Trait.Monoid/#mempty","title":"mempty","text":"<p>Type: <code>[a : Minilib.Trait.Monoid::MEmpty] a</code></p> <p>An identity of a monoid, such as an empty instance.</p>"},{"location":"Minilib.Trait.Monoid/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Monoid/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Monoid/#namespace-minilibtraitmonoid_1","title":"namespace Minilib.Trait.Monoid","text":""},{"location":"Minilib.Trait.Monoid/#trait-a-mempty","title":"trait <code>a : MEmpty</code>","text":"<p>A trait that represents an identity of a monoid.</p>"},{"location":"Minilib.Trait.Monoid/#method-mempty","title":"method <code>mempty</code>","text":"<p>Type: <code>a</code></p> <p>An identity of a monoid, such as an empty instance.</p>"},{"location":"Minilib.Trait.Monoid/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Monoid/#impl-minilibtraitmonoidmempty","title":"impl <code>() : Minilib.Trait.Monoid::MEmpty</code>","text":""},{"location":"Minilib.Trait.Monoid/#impl-stdarray-a-minilibtraitmonoidmempty","title":"impl <code>Std::Array a : Minilib.Trait.Monoid::MEmpty</code>","text":""},{"location":"Minilib.Trait.Monoid/#impl-stditeratordyniterator-a-minilibtraitmonoidmempty","title":"impl <code>Std::Iterator::DynIterator a : Minilib.Trait.Monoid::MEmpty</code>","text":""},{"location":"Minilib.Trait.Monoid/#impl-a-minilibtraitsemigroupsemigroup-stdoption-a-minilibtraitmonoidmempty","title":"impl <code>[a : Minilib.Trait.Semigroup::Semigroup] Std::Option a : Minilib.Trait.Monoid::MEmpty</code>","text":""},{"location":"Minilib.Trait.Monoid/#impl-stdstring-minilibtraitmonoidmempty","title":"impl <code>Std::String : Minilib.Trait.Monoid::MEmpty</code>","text":""},{"location":"Minilib.Trait.Rng/","title":"Minilib.Trait.Rng","text":"<p>Defined in minilib-random@0.5.2</p> <p>A trait for Random Number Generator.</p>"},{"location":"Minilib.Trait.Rng/#values","title":"Values","text":""},{"location":"Minilib.Trait.Rng/#namespace-minilibtraitrng","title":"namespace Minilib.Trait.Rng","text":""},{"location":"Minilib.Trait.Rng/#lens_rng","title":"lens_rng","text":"<p>Type: <code>[rg : Minilib.Trait.Rng::Rng, rg2 : Minilib.Trait.Rng::Rng, f : Std::Functor, Minilib.Trait.Rng::Rng::RngResult rg a = f a] ((rg -&gt; Minilib.Functor.Pair::PairLT a f rg) -&gt; rg2 -&gt; Minilib.Functor.Pair::PairLT a f rg2) -&gt; (rg -&gt; f (rg, a)) -&gt; rg2 -&gt; f (rg2, a)</code></p> <p>Converts a <code>rng_xxx</code> function using a lens action. Useful for implementing the <code>Rng</code> trait for containers that have a member implementing the <code>Rng</code> trait. For instance, <code>rng_U64.lens_rng(act_random)</code> creates an <code>rng_U64</code> function that performs the <code>act_random</code> action. Refer to the <code>Container</code> type in <code>monad_random_test.fix</code> for a detailed example. Note that this function is similar to <code>State::lens_state_t</code>.</p>"},{"location":"Minilib.Trait.Rng/#namespace-minilibtraitrngrng","title":"namespace Minilib.Trait.Rng::Rng","text":""},{"location":"Minilib.Trait.Rng/#rng_u64","title":"rng_U64","text":"<p>Type: <code>[rg : Minilib.Trait.Rng::Rng] rg -&gt; Minilib.Trait.Rng::Rng::RngResult rg (rg, Std::U64)</code></p> <p>Generates a random integer of U64.</p>"},{"location":"Minilib.Trait.Rng/#rng_bytes","title":"rng_bytes","text":"<p>Type: <code>[rg : Minilib.Trait.Rng::Rng] Std::I64 -&gt; rg -&gt; Minilib.Trait.Rng::Rng::RngResult rg (rg, Std::Array Std::U8)</code></p> <p>Generates random bytes of specified size.</p>"},{"location":"Minilib.Trait.Rng/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Rng/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Rng/#namespace-minilibtraitrng_1","title":"namespace Minilib.Trait.Rng","text":""},{"location":"Minilib.Trait.Rng/#trait-rg-rng","title":"trait <code>rg : Rng</code>","text":"<p>A trait for Random Number Generator.</p>"},{"location":"Minilib.Trait.Rng/#type-rngresult","title":"type <code>RngResult</code>","text":"<p>Defined as: <code>RngResult rg a</code></p> <p>The result type of <code>rng_xxx</code> functions. This should be a monad, for example <code>Identity a</code>, <code>IOFail a</code> etc. This result will be lifted by the lifter.</p>"},{"location":"Minilib.Trait.Rng/#type-rnglift","title":"type <code>RngLift</code>","text":"<p>Defined as: <code>[m : *-&gt;*] RngLift rg m a</code></p> <p>A lifter that lifts <code>RngResult</code> into a desired monad. Requirements: - Implements the <code>Lifter</code> trait. - <code>LiftFrom</code> type must be <code>RngResult rg a</code>. - <code>LiftTo</code> type must be <code>m a</code>. Typically, this type is set to <code>LifterImpl (n a) (m a)</code> where <code>n a</code> = <code>RngResult rg a</code>.</p>"},{"location":"Minilib.Trait.Rng/#method-rng_u64","title":"method <code>rng_U64</code>","text":"<p>Type: <code>rg -&gt; Minilib.Trait.Rng::Rng::RngResult rg (rg, Std::U64)</code></p> <p>Generates a random integer of U64.</p>"},{"location":"Minilib.Trait.Rng/#method-rng_bytes","title":"method <code>rng_bytes</code>","text":"<p>Type: <code>Std::I64 -&gt; rg -&gt; Minilib.Trait.Rng::Rng::RngResult rg (rg, Std::Array Std::U8)</code></p> <p>Generates random bytes of specified size.</p>"},{"location":"Minilib.Trait.Rng/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Rng/#impl-randomrandom-minilibtraitrngrng","title":"impl <code>Random::Random : Minilib.Trait.Rng::Rng</code>","text":"<p><code>Random</code> implements the <code>Rng</code> trait</p>"},{"location":"Minilib.Trait.Semigroup/","title":"Minilib.Trait.Semigroup","text":"<p>Defined in minilib-monad@0.5.1</p> <p>Semigroup trait and its several implementations (Array, Iterator, String etc).</p> <p>Semigroup has an associative binary operation, namely <code>sappend</code>. It may or may not have an identity.</p> <p>For details, see Wikipedia: Semigroup.</p>"},{"location":"Minilib.Trait.Semigroup/#values","title":"Values","text":""},{"location":"Minilib.Trait.Semigroup/#namespace-minilibtraitsemigroupsemigroup","title":"namespace Minilib.Trait.Semigroup::Semigroup","text":""},{"location":"Minilib.Trait.Semigroup/#sappend","title":"sappend","text":"<p>Type: <code>[a : Minilib.Trait.Semigroup::Semigroup] a -&gt; a -&gt; a</code></p> <p><code>a.sappend(b)</code> appends <code>b</code> after <code>a</code>.</p>"},{"location":"Minilib.Trait.Semigroup/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Semigroup/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Semigroup/#namespace-minilibtraitsemigroup","title":"namespace Minilib.Trait.Semigroup","text":""},{"location":"Minilib.Trait.Semigroup/#trait-a-semigroup","title":"trait <code>a : Semigroup</code>","text":"<p>A trait that represents a semigroup.</p>"},{"location":"Minilib.Trait.Semigroup/#method-sappend","title":"method <code>sappend</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p><code>a.sappend(b)</code> appends <code>b</code> after <code>a</code>.</p>"},{"location":"Minilib.Trait.Semigroup/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Semigroup/#impl-minilibtraitsemigroupsemigroup","title":"impl <code>() : Minilib.Trait.Semigroup::Semigroup</code>","text":"<p><code>()</code> does not change with <code>sappend</code>.</p>"},{"location":"Minilib.Trait.Semigroup/#impl-stdarray-a-minilibtraitsemigroupsemigroup","title":"impl <code>Std::Array a : Minilib.Trait.Semigroup::Semigroup</code>","text":"<p>For arrays, <code>sappend</code> appends two arrays.</p>"},{"location":"Minilib.Trait.Semigroup/#impl-stditeratordyniterator-a-minilibtraitsemigroupsemigroup","title":"impl <code>Std::Iterator::DynIterator a : Minilib.Trait.Semigroup::Semigroup</code>","text":"<p>For iterators, <code>sappend</code> appends two iterators.</p>"},{"location":"Minilib.Trait.Semigroup/#impl-a-minilibtraitsemigroupsemigroup-stdoption-a-minilibtraitsemigroupsemigroup","title":"impl <code>[a : Minilib.Trait.Semigroup::Semigroup] Std::Option a : Minilib.Trait.Semigroup::Semigroup</code>","text":"<p>For options, <code>sappand</code> appends two values if both is some.</p>"},{"location":"Minilib.Trait.Semigroup/#impl-stdstring-minilibtraitsemigroupsemigroup","title":"impl <code>Std::String : Minilib.Trait.Semigroup::Semigroup</code>","text":"<p>For strings, <code>sappend</code> concats two strings.</p>"},{"location":"Minilib.Trait.Traversable/","title":"Minilib.Trait.Traversable","text":"<p>Defined in minilib-common@0.5.2</p>"},{"location":"Minilib.Trait.Traversable/#values","title":"Values","text":""},{"location":"Minilib.Trait.Traversable/#namespace-minilibtraittraversable","title":"namespace Minilib.Trait.Traversable","text":""},{"location":"Minilib.Trait.Traversable/#foreach_m","title":"foreach_m","text":"<p>Type: <code>[m : Std::Monad, t : Minilib.Trait.Traversable::Traversable, t : Std::Functor] (a -&gt; m ()) -&gt; t a -&gt; m ()</code></p> <p><code>ta.foreach_m(f)</code> maps each element with <code>f</code>, then performs all elements sequentially and forgets the results. Similar to Haskell's <code>mapM</code> function, but the results are discarded.</p> <p>Example:</p> <pre><code>[\"hello\", \"world\"].foreach_m(println);;\n==&gt; (\"hello\\nworld\\n\" is printed)\n</code></pre>"},{"location":"Minilib.Trait.Traversable/#map_m","title":"map_m","text":"<p>Type: <code>[m : Std::Monad, t : Minilib.Trait.Traversable::Traversable, t : Std::Functor] (a -&gt; m b) -&gt; t a -&gt; m (t b)</code></p> <p><code>ta.map_m(f)</code> maps each element with <code>f</code>, then performs all elements sequentially and collects the results. Similar to Haskell's <code>mapM</code> function.</p> <p>Example:</p> <pre><code>let ios = ...Array of IO operations...;\nlet tasks = *ios.map_m(AsyncIOTask::make);\nlet results = *tasks.map_m(get);\n==&gt; (tasks are created and started in parallel, then the results of tasks are collected)\n</code></pre>"},{"location":"Minilib.Trait.Traversable/#traverse","title":"traverse","text":"<p>Type: <code>[m : Std::Monad, t : Minilib.Trait.Traversable::Traversable, t : Std::Functor] (a -&gt; m b) -&gt; t a -&gt; m (t b)</code></p> <p><code>ta.traverse(f)</code> maps each element with <code>f</code>, then performs all elements sequentially and collects the results. <code>traverse</code> is a synonym of <code>map_m</code>.</p>"},{"location":"Minilib.Trait.Traversable/#namespace-minilibtraittraversabletraversable","title":"namespace Minilib.Trait.Traversable::Traversable","text":""},{"location":"Minilib.Trait.Traversable/#sequence","title":"sequence","text":"<p>Type: <code>[t : Minilib.Trait.Traversable::Traversable, m : Std::Monad] t (m a) -&gt; m (t a)</code></p> <p><code>ta.sequence</code> performs all elements sequentially and collects the results. Similar to Haskell's <code>sequence</code> function.</p>"},{"location":"Minilib.Trait.Traversable/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Minilib.Trait.Traversable/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Minilib.Trait.Traversable/#namespace-minilibtraittraversable_1","title":"namespace Minilib.Trait.Traversable","text":""},{"location":"Minilib.Trait.Traversable/#trait-t-t-traversable","title":"trait <code>[t : *-&gt;*] t : Traversable</code>","text":"<p>A trait for types which can traverse all elements with <code>Monad</code>.</p>"},{"location":"Minilib.Trait.Traversable/#method-sequence","title":"method <code>sequence</code>","text":"<p>Type: <code>[m : Std::Monad] t (m a) -&gt; m (t a)</code></p> <p><code>ta.sequence</code> performs all elements sequentially and collects the results. Similar to Haskell's <code>sequence</code> function.</p>"},{"location":"Minilib.Trait.Traversable/#trait-implementations","title":"Trait implementations","text":""},{"location":"Minilib.Trait.Traversable/#impl-stdarray-minilibtraittraversabletraversable","title":"impl <code>Std::Array : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Minilib.Trait.Traversable/#impl-stditeratorarrayiterator-minilibtraittraversabletraversable","title":"impl <code>Std::Iterator::ArrayIterator : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Minilib.Trait.Traversable/#impl-stditeratordyniterator-minilibtraittraversabletraversable","title":"impl <code>Std::Iterator::DynIterator : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Minilib.Trait.Traversable/#impl-stdoption-minilibtraittraversabletraversable","title":"impl <code>Std::Option : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Minilib.Trait.Traversable/#impl-stdresult-e-minilibtraittraversabletraversable","title":"impl <code>Std::Result e : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Minilib.Trait.Traversable/#impl-stdtuple2-e-minilibtraittraversabletraversable","title":"impl <code>Std::Tuple2 e : Minilib.Trait.Traversable::Traversable</code>","text":""},{"location":"Random/","title":"Random","text":"<p>Defined in random@1.1.1</p> <p>Mersenne Twister, ported to Fix Language by https://github.com/pt9999.</p>"},{"location":"Random/#values","title":"Values","text":""},{"location":"Random/#namespace-random","title":"namespace Random","text":""},{"location":"Random/#_lm","title":"_LM","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Random/#_matrix_a","title":"_MATRIX_A","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Random/#_mm","title":"_MM","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Random/#_nn","title":"_NN","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Random/#_um","title":"_UM","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Random/#_mag01","title":"_mag01","text":"<p>Type: <code>Std::Array Std::U64</code></p>"},{"location":"Random/#generate_f64","title":"generate_F64","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::F64)</code></p> <p>Generates a random number on [0, 1]-real-interval.</p>"},{"location":"Random/#generate_f64_2","title":"generate_F64_2","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::F64)</code></p> <p>Generates a random number on [0, 1)-real-interval.</p>"},{"location":"Random/#generate_f64_3","title":"generate_F64_3","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::F64)</code></p> <p>Generates a random number on (0, 1)-real-interval.</p>"},{"location":"Random/#generate_i64_nonneg","title":"generate_I64_nonneg","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::I64)</code></p> <p>Generates a random number on [0, 2^63-1]-interval.</p>"},{"location":"Random/#generate_u64","title":"generate_U64","text":"<p>Type: <code>Random::Random -&gt; (Random::Random, Std::U64)</code></p> <p>Generates a random number on [0, 2^64-1]-interval.</p>"},{"location":"Random/#init_by_array","title":"init_by_array","text":"<p>Type: <code>Std::Array Std::U64 -&gt; Random::Random</code></p> <p>Initializes <code>Random</code> with an array.</p>"},{"location":"Random/#init_by_seed","title":"init_by_seed","text":"<p>Type: <code>Std::U64 -&gt; Random::Random</code></p> <p>Initializes <code>Random</code> with a seed.</p>"},{"location":"Random/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Random/#namespace-random_1","title":"namespace Random","text":""},{"location":"Random/#random_1","title":"Random","text":"<p>Defined as: <code>type Random = unbox struct { ...fields... }</code></p> <p>Random number generator.</p>"},{"location":"Random/#field-mt","title":"field <code>mt</code>","text":"<p>Type: <code>Std::Array Std::U64</code></p>"},{"location":"Random/#field-mti","title":"field <code>mti</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Random/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Random/#trait-implementations","title":"Trait implementations","text":""},{"location":"RegExp.RegExpNFA/","title":"RegExp.RegExpNFA","text":"<p>Defined in regexp@1.1.1</p> <p>NFA (Nondeterministic Finite Automaton). This is internal module of <code>RegExp</code>.</p> <p>For details, see web pages below. - https://swtch.com/~rsc/regexp/regexp1.html - https://zenn.dev/canalun/articles/regexp_and_automaton</p>"},{"location":"RegExp.RegExpNFA/#values","title":"Values","text":""},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfa","title":"namespace RegExp.RegExpNFA::NFA","text":""},{"location":"RegExp.RegExpNFA/#compile","title":"compile","text":"<p>Type: <code>RegExp.RegExpPattern::Pattern -&gt; RegExp.RegExpNFA::NFA</code></p> <p><code>NFA::compile(pattern)</code> compiles a pattern to NFA.</p>"},{"location":"RegExp.RegExpNFA/#debug","title":"debug","text":"<p>Type: <code>Std::String -&gt; RegExp.RegExpNFA::NFA -&gt; ()</code></p>"},{"location":"RegExp.RegExpNFA/#empty","title":"empty","text":"<p>Type: <code>RegExp.RegExpNFA::NFA</code></p> <p>An empty NFA.</p>"},{"location":"RegExp.RegExpNFA/#execute","title":"execute","text":"<p>Type: <code>Std::String -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p><code>nfa.execute(target)</code> executes matching.</p>"},{"location":"RegExp.RegExpNFA/#get_node","title":"get_node","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFANode</code></p> <p><code>nfa.get_node(id)</code> gets the node whose @id is <code>id</code>.</p>"},{"location":"RegExp.RegExpNFA/#mod_node","title":"mod_node","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID -&gt; (RegExp.RegExpNFA::NFANode -&gt; RegExp.RegExpNFA::NFANode) -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFA</code></p> <p><code>nfa.mod_node(id, f)</code> modifies the node whose @id is <code>id</code>.</p>"},{"location":"RegExp.RegExpNFA/#new_node","title":"new_node","text":"<p>Type: <code>RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NodeID)</code></p> <p>Creates new node. Returns the new node id.</p>"},{"location":"RegExp.RegExpNFA/#new_quant","title":"new_quant","text":"<p>Type: <code>RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::QuantID)</code></p> <p>Creates new quant. Returns the new quant id.</p>"},{"location":"RegExp.RegExpNFA/#set_frag_output","title":"set_frag_output","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NodeID -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFA</code></p> <p><code>nfa.set_frag_output(frag, out)</code> sets the output of the fragment to <code>out</code>.</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfaexecutor","title":"namespace RegExp.RegExpNFA::NFAExecutor","text":""},{"location":"RegExp.RegExpNFA/#_add_to_state_set_and_stack","title":"_add_to_state_set_and_stack","text":"<p>Type: <code>RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Adds a state to the state set if not added yet, then pushes the state to the stack.</p>"},{"location":"RegExp.RegExpNFA/#_check_for_accepting_state","title":"_check_for_accepting_state","text":"<p>Type: <code>RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Checks for accepting state</p>"},{"location":"RegExp.RegExpNFA/#_pop_stack","title":"_pop_stack","text":"<p>Type: <code>RegExp.RegExpNFA::NFAExecutor -&gt; Std::Option (RegExp.RegExpNFA::NFAState, RegExp.RegExpNFA::NFAExecutor)</code></p>"},{"location":"RegExp.RegExpNFA/#_transition_on_action","title":"_transition_on_action","text":"<p>Type: <code>RegExp.RegExpNFA::NFANode -&gt; RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Applies transitions on an action with empty string.</p>"},{"location":"RegExp.RegExpNFA/#_transition_with_char","title":"_transition_with_char","text":"<p>Type: <code>Std::U8 -&gt; RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Applies transitions with a string of one character.</p>"},{"location":"RegExp.RegExpNFA/#_transition_with_empty_string","title":"_transition_with_empty_string","text":"<p>Type: <code>RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Applies transitions with an empty string.</p>"},{"location":"RegExp.RegExpNFA/#execute_1","title":"execute","text":"<p>Type: <code>RegExp.RegExpNFA::NFAExecutor -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Make transitions until end of stream is reached, or the state set becomes empty.</p>"},{"location":"RegExp.RegExpNFA/#make","title":"make","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFAExecutor</code></p> <p>Creates an executor.</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfafrag","title":"namespace RegExp.RegExpNFA::NFAFrag","text":""},{"location":"RegExp.RegExpNFA/#_compile_action","title":"_compile_action","text":"<p>Type: <code>RegExp.RegExpNFA::NFANodeAction -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles an action to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_either","title":"_compile_either","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles an alternative of two fragments (<code>e1|e2</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_null_sequence","title":"_compile_null_sequence","text":"<p>Type: <code>RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles null sequence (``) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_one_or_more","title":"_compile_one_or_more","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles one or more occurrence (<code>e+</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_seq","title":"_compile_seq","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles a sequence of two fragments (<code>e1 e2</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_special_quant","title":"_compile_special_quant","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; Std::I64 -&gt; Std::I64 -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles special quant (<code>e{min,max}</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_zero_or_more","title":"_compile_zero_or_more","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles zero or more occurrence (<code>e*</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#_compile_zero_or_once","title":"_compile_zero_or_once","text":"<p>Type: <code>RegExp.RegExpNFA::NFAFrag -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p>Compiles zero or once occurrence (<code>e?</code>) to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#compile_pattern","title":"compile_pattern","text":"<p>Type: <code>RegExp.RegExpPattern::Pattern -&gt; RegExp.RegExpNFA::NFA -&gt; (RegExp.RegExpNFA::NFA, RegExp.RegExpNFA::NFAFrag)</code></p> <p><code>nfa.compile_pattern(pattern)</code> compiles a pattern to a fragment.</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfanode","title":"namespace RegExp.RegExpNFA::NFANode","text":""},{"location":"RegExp.RegExpNFA/#_invalid_node_id","title":"_INVALID_NODE_ID","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p> <p>An invalid node ID.</p>"},{"location":"RegExp.RegExpNFA/#empty_1","title":"empty","text":"<p>Type: <code>RegExp.RegExpNFA::NFANode</code></p> <p>An empty node</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfastate","title":"namespace RegExp.RegExpNFA::NFAState","text":""},{"location":"RegExp.RegExpNFA/#_sort_by_group0_begin_and_length","title":"_sort_by_group0_begin_and_length","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::NFAState -&gt; Std::Array RegExp.RegExpNFA::NFAState</code></p> <p>Sorts states by beginning of group 0 (ascending order) and length of group 0 (descending order).</p>"},{"location":"RegExp.RegExpNFA/#collect_all_non_overlapping","title":"collect_all_non_overlapping","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::NFAState -&gt; Std::Array RegExp.RegExpNFA::NFAState</code></p> <p>Collects all non overlapping matches.</p>"},{"location":"RegExp.RegExpNFA/#collect_first_match","title":"collect_first_match","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::NFAState -&gt; Std::Option RegExp.RegExpNFA::NFAState</code></p> <p>Collects first match.</p>"},{"location":"RegExp.RegExpNFA/#get_group","title":"get_group","text":"<p>Type: <code>Std::I64 -&gt; RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::Group</code></p> <p>Gets specified group. If group index is out of range, returns (-1, -1).</p>"},{"location":"RegExp.RegExpNFA/#get_quant","title":"get_quant","text":"<p>Type: <code>RegExp.RegExpNFA::QuantID -&gt; RegExp.RegExpNFA::NFAState -&gt; Std::I64</code></p> <p>get quant loop count</p>"},{"location":"RegExp.RegExpNFA/#group_length","title":"group_length","text":"<p>Type: <code>Std::I64 -&gt; RegExp.RegExpNFA::NFAState -&gt; Std::I64</code></p> <p>Gets the length of specified group.</p>"},{"location":"RegExp.RegExpNFA/#make_1","title":"make","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID -&gt; RegExp.RegExpNFA::Groups -&gt; RegExp.RegExpNFA::NFAState</code></p> <p>Creates a NFA state.</p>"},{"location":"RegExp.RegExpNFA/#mod_group","title":"mod_group","text":"<p>Type: <code>Std::I64 -&gt; (RegExp.RegExpNFA::Group -&gt; RegExp.RegExpNFA::Group) -&gt; RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAState</code></p> <p>Modify specified group.</p>"},{"location":"RegExp.RegExpNFA/#overlaps","title":"overlaps","text":"<p>Type: <code>RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAState -&gt; Std::Bool</code></p>"},{"location":"RegExp.RegExpNFA/#set_quant","title":"set_quant","text":"<p>Type: <code>RegExp.RegExpNFA::QuantID -&gt; Std::I64 -&gt; RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAState</code></p> <p>set quant loop count</p>"},{"location":"RegExp.RegExpNFA/#transition","title":"transition","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID -&gt; RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAState</code></p> <p>Makes transition to next node.</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfanfastateset","title":"namespace RegExp.RegExpNFA::NFAStateSet","text":""},{"location":"RegExp.RegExpNFA/#add","title":"add","text":"<p>Type: <code>RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAStateSet -&gt; RegExp.RegExpNFA::NFAStateSet</code></p> <p>Adds a state to the state set.</p>"},{"location":"RegExp.RegExpNFA/#contains","title":"contains","text":"<p>Type: <code>RegExp.RegExpNFA::NFAState -&gt; RegExp.RegExpNFA::NFAStateSet -&gt; Std::Bool</code></p> <p>Checks whether the state set contains a state.</p>"},{"location":"RegExp.RegExpNFA/#empty_2","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; RegExp.RegExpNFA::NFAStateSet</code></p> <p><code>NFAStateSet::empty(node_count)</code> creates an empty state set. <code>node_count</code> is number of NFA nodes.</p>"},{"location":"RegExp.RegExpNFA/#is_empty","title":"is_empty","text":"<p>Type: <code>RegExp.RegExpNFA::NFAStateSet -&gt; Std::Bool</code></p> <p>Checks whether the state set is empty.</p>"},{"location":"RegExp.RegExpNFA/#to_iter","title":"to_iter","text":"<p>Type: <code>RegExp.RegExpNFA::NFAStateSet -&gt; Std::Iterator::DynIterator RegExp.RegExpNFA::NFAState</code></p> <p>Returns an iterator of the states.</p>"},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfareplacement","title":"namespace RegExp.RegExpNFA::Replacement","text":""},{"location":"RegExp.RegExpNFA/#_parse_dollar","title":"_parse_dollar","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpNFA::ReplaceFrag</code></p>"},{"location":"RegExp.RegExpNFA/#_parse_literal","title":"_parse_literal","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpNFA::ReplaceFrag</code></p>"},{"location":"RegExp.RegExpNFA/#_parse_replacement_seq","title":"_parse_replacement_seq","text":"<p>Type: <code>RegExp.SimpleParser::Parser (Std::Array RegExp.RegExpNFA::ReplaceFrag)</code></p>"},{"location":"RegExp.RegExpNFA/#calc_replacement","title":"calc_replacement","text":"<p>Type: <code>Std::String -&gt; Std::Array RegExp.RegExpNFA::ReplaceFrag -&gt; RegExp.RegExpNFA::NFAState -&gt; Std::String</code></p> <p>Calculates actual replacement string.</p>"},{"location":"RegExp.RegExpNFA/#compile_1","title":"compile","text":"<p>Type: <code>Std::String -&gt; Std::Array RegExp.RegExpNFA::ReplaceFrag</code></p> <p>Compiles a replacement string to fragments.</p>"},{"location":"RegExp.RegExpNFA/#types-and-aliases","title":"Types and aliases","text":""},{"location":"RegExp.RegExpNFA/#namespace-regexpregexpnfa","title":"namespace RegExp.RegExpNFA","text":""},{"location":"RegExp.RegExpNFA/#group","title":"Group","text":"<p>Defined as: <code>type Group = (Std::I64, Std::I64)</code></p> <p>Type of a matched group. The group is represented as two stream positions: <code>(begin, end)</code>. <code>-1</code> means that the stream position is undefined.</p>"},{"location":"RegExp.RegExpNFA/#groups","title":"Groups","text":"<p>Defined as: <code>type Groups = Std::Array RegExp.RegExpNFA::Group</code></p> <p>Type of the array of matched groups.</p>"},{"location":"RegExp.RegExpNFA/#nfa","title":"NFA","text":"<p>Defined as: <code>type NFA = unbox struct { ...fields... }</code></p> <p>NFA</p>"},{"location":"RegExp.RegExpNFA/#field-nodes","title":"field <code>nodes</code>","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::NFANode</code></p>"},{"location":"RegExp.RegExpNFA/#field-initial_node","title":"field <code>initial_node</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-accepting_node","title":"field <code>accepting_node</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-group_count","title":"field <code>group_count</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#field-quant_count","title":"field <code>quant_count</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#field-debug","title":"field <code>debug</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"RegExp.RegExpNFA/#nfaexecutor","title":"NFAExecutor","text":"<p>Defined as: <code>type NFAExecutor = unbox struct { ...fields... }</code></p> <p>The NFA executor</p>"},{"location":"RegExp.RegExpNFA/#field-stream","title":"field <code>stream</code>","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream</code></p>"},{"location":"RegExp.RegExpNFA/#field-nfa","title":"field <code>nfa</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFA</code></p>"},{"location":"RegExp.RegExpNFA/#field-empty_state_set","title":"field <code>empty_state_set</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFAStateSet</code></p>"},{"location":"RegExp.RegExpNFA/#field-state_set","title":"field <code>state_set</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFAStateSet</code></p>"},{"location":"RegExp.RegExpNFA/#field-stack","title":"field <code>stack</code>","text":"<p>Type: <code>Std::Iterator::DynIterator RegExp.RegExpNFA::NFAState</code></p>"},{"location":"RegExp.RegExpNFA/#field-accepted_states","title":"field <code>accepted_states</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFAStateSet</code></p>"},{"location":"RegExp.RegExpNFA/#nfafrag","title":"NFAFrag","text":"<p>Defined as: <code>type NFAFrag = unbox struct { ...fields... }</code></p> <p>NFA Fragment</p> <p>NFA Fragment is a collection of nodes. It exports one input, And a function to set the output. Internally, the output of a fragment is a collection of outputs of one or more nodes. Calling <code>set_output()</code> will change them all.</p>"},{"location":"RegExp.RegExpNFA/#field-input","title":"field <code>input</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-set_output","title":"field <code>set_output</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID -&gt; RegExp.RegExpNFA::NFA -&gt; RegExp.RegExpNFA::NFA</code></p>"},{"location":"RegExp.RegExpNFA/#field-label","title":"field <code>label</code>","text":"<p>Type: <code>Std::String</code></p> <p>of this fragment</p>"},{"location":"RegExp.RegExpNFA/#nfanode","title":"NFANode","text":"<p>Defined as: <code>type NFANode = unbox struct { ...fields... }</code></p> <p>NFA node</p> <p>NFA node has one input (ID of this node) and three outputs (one output guarded by the action, and two outputs with no guard).</p>"},{"location":"RegExp.RegExpNFA/#field-id","title":"field <code>id</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-action","title":"field <code>action</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFANodeAction</code></p>"},{"location":"RegExp.RegExpNFA/#field-output_on_action","title":"field <code>output_on_action</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-output","title":"field <code>output</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-output2","title":"field <code>output2</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-label_1","title":"field <code>label</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"RegExp.RegExpNFA/#nfanodeaction","title":"NFANodeAction","text":"<p>Defined as: <code>type NFANodeAction = unbox union { ...variants... }</code></p> <p>Actions that has to be performed before the state makes a transition to <code>node.@out_on_action</code>.</p>"},{"location":"RegExp.RegExpNFA/#variant-sa_none","title":"variant <code>sa_none</code>","text":"<p>Type: <code>()</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_char_match","title":"variant <code>sa_char_match</code>","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_assert","title":"variant <code>sa_assert</code>","text":"<p>Type: <code>RegExp.RegExpPattern::PAssertion</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_group_begin","title":"variant <code>sa_group_begin</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_group_end","title":"variant <code>sa_group_end</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_quant_begin","title":"variant <code>sa_quant_begin</code>","text":"<p>Type: <code>RegExp.RegExpNFA::QuantID</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_quant_loop","title":"variant <code>sa_quant_loop</code>","text":"<p>Type: <code>RegExp.RegExpNFA::QuantID</code></p>"},{"location":"RegExp.RegExpNFA/#variant-sa_quant_end","title":"variant <code>sa_quant_end</code>","text":"<p>Type: <code>(RegExp.RegExpNFA::QuantID, Std::I64, Std::I64)</code></p>"},{"location":"RegExp.RegExpNFA/#nfastate","title":"NFAState","text":"<p>Defined as: <code>type NFAState = unbox struct { ...fields... }</code></p> <p>NFA state</p>"},{"location":"RegExp.RegExpNFA/#field-id_1","title":"field <code>id</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NodeID</code></p>"},{"location":"RegExp.RegExpNFA/#field-groups","title":"field <code>groups</code>","text":"<p>Type: <code>RegExp.RegExpNFA::Groups</code></p>"},{"location":"RegExp.RegExpNFA/#field-quants","title":"field <code>quants</code>","text":"<p>Type: <code>Std::Array Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#nfastateset","title":"NFAStateSet","text":"<p>Defined as: <code>type NFAStateSet = unbox struct { ...fields... }</code></p> <p>NFA state set, used for NFA state transition</p>"},{"location":"RegExp.RegExpNFA/#field-array","title":"field <code>array</code>","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::NFAState</code></p>"},{"location":"RegExp.RegExpNFA/#field-map","title":"field <code>map</code>","text":"<p>Type: <code>HashMap::HashMap RegExp.RegExpNFA::NFAState Std::Bool</code></p>"},{"location":"RegExp.RegExpNFA/#nodeid","title":"NodeID","text":"<p>Defined as: <code>type NodeID = unbox struct { ...fields... }</code></p> <p>ID of NFA node. -1 is invalid value.</p>"},{"location":"RegExp.RegExpNFA/#field-val","title":"field <code>val</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#quantid","title":"QuantID","text":"<p>Defined as: <code>type QuantID = Std::I64</code></p> <p>Type of special quantifiers ID. Special quantifiers are quantifieres other than <code>X?</code> <code>X*</code> <code>X+</code>. In other words, they are <code>X{n}</code> <code>X{n,}</code> <code>X{n,m}</code> etc. Special quantifiers are hard to implement only using node transition, so its iteration count are stored in the NFA state, and managed by <code>sa_quant_*</code> actions.</p>"},{"location":"RegExp.RegExpNFA/#replacefrag","title":"ReplaceFrag","text":"<p>Defined as: <code>type ReplaceFrag = unbox union { ...variants... }</code></p> <p>A replacement fragment</p>"},{"location":"RegExp.RegExpNFA/#variant-rep_literal","title":"variant <code>rep_literal</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"RegExp.RegExpNFA/#variant-rep_group","title":"variant <code>rep_group</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.RegExpNFA/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"RegExp.RegExpNFA/#trait-implementations","title":"Trait implementations","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfa-stdtostring","title":"impl <code>RegExp.RegExpNFA::NFA : Std::ToString</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfanode-stdtostring","title":"impl <code>RegExp.RegExpNFA::NFANode : Std::ToString</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfanodeaction-stdtostring","title":"impl <code>RegExp.RegExpNFA::NFANodeAction : Std::ToString</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfastate-hashhash","title":"impl <code>RegExp.RegExpNFA::NFAState : Hash::Hash</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfastate-stdeq","title":"impl <code>RegExp.RegExpNFA::NFAState : Std::Eq</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanfastate-stdtostring","title":"impl <code>RegExp.RegExpNFA::NFAState : Std::ToString</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanodeid-hashhash","title":"impl <code>RegExp.RegExpNFA::NodeID : Hash::Hash</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanodeid-stdeq","title":"impl <code>RegExp.RegExpNFA::NodeID : Std::Eq</code>","text":""},{"location":"RegExp.RegExpNFA/#impl-regexpregexpnfanodeid-stdtostring","title":"impl <code>RegExp.RegExpNFA::NodeID : Std::ToString</code>","text":""},{"location":"RegExp.RegExpPattern/","title":"RegExp.RegExpPattern","text":"<p>Defined in regexp@1.1.1</p> <p>Character class and Pattern parser. This is internal module of <code>RegExp</code>.</p>"},{"location":"RegExp.RegExpPattern/#values","title":"Values","text":""},{"location":"RegExp.RegExpPattern/#namespace-regexpregexppatterncharclass","title":"namespace RegExp.RegExpPattern::CharClass","text":""},{"location":"RegExp.RegExpPattern/#add","title":"add","text":"<p>Type: <code>Std::U8 -&gt; RegExp.RegExpPattern::CharClass -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Adds a character to the character class.</p>"},{"location":"RegExp.RegExpPattern/#cls_digit","title":"cls_digit","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\d</code>. (digits)</p>"},{"location":"RegExp.RegExpPattern/#cls_dot","title":"cls_dot","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>.</code>. (any character except newlines)</p>"},{"location":"RegExp.RegExpPattern/#cls_non_digit","title":"cls_non_digit","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\D</code>. (non-digits)</p>"},{"location":"RegExp.RegExpPattern/#cls_non_whitespace","title":"cls_non_whitespace","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\S</code>. (non-whitespaces)</p>"},{"location":"RegExp.RegExpPattern/#cls_non_word_char","title":"cls_non_word_char","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\W</code>. (ie. <code>[^A-Za-z0-9_]</code>)</p>"},{"location":"RegExp.RegExpPattern/#cls_whitespace","title":"cls_whitespace","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\s</code>. (whitespaces)</p>"},{"location":"RegExp.RegExpPattern/#cls_word_char","title":"cls_word_char","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A character class of <code>\\w</code>. (ie. <code>[A-Za-z0-9_]</code>)</p>"},{"location":"RegExp.RegExpPattern/#consists_of","title":"consists_of","text":"<p>Type: <code>Std::String -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Creates a character class whose members are characters in the specified string.</p>"},{"location":"RegExp.RegExpPattern/#contains","title":"contains","text":"<p>Type: <code>Std::U8 -&gt; RegExp.RegExpPattern::CharClass -&gt; Std::Bool</code></p> <p>Returns true if the character is a member of the class.</p>"},{"location":"RegExp.RegExpPattern/#empty","title":"empty","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>An empty character class.</p>"},{"location":"RegExp.RegExpPattern/#make","title":"make","text":"<p>Type: <code>Std::String -&gt; (Std::U8 -&gt; Std::Bool) -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Creates a character class from a label and a member function.</p>"},{"location":"RegExp.RegExpPattern/#negate","title":"negate","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Negate the member function of a character class.</p>"},{"location":"RegExp.RegExpPattern/#range","title":"range","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Creates a character class whose members are characters from start to end.</p>"},{"location":"RegExp.RegExpPattern/#singleton","title":"singleton","text":"<p>Type: <code>Std::U8 -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Creates a character class whose only member is the specified character.</p>"},{"location":"RegExp.RegExpPattern/#to_table","title":"to_table","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>For optimization, creates a lookup table of same members, and returns a character class using that table.</p>"},{"location":"RegExp.RegExpPattern/#union","title":"union","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass -&gt; RegExp.RegExpPattern::CharClass -&gt; RegExp.RegExpPattern::CharClass</code></p> <p>Creates union of two character classes.</p>"},{"location":"RegExp.RegExpPattern/#namespace-regexpregexppatternpattern","title":"namespace RegExp.RegExpPattern::Pattern","text":""},{"location":"RegExp.RegExpPattern/#_assign_group_number","title":"_assign_group_number","text":"<p>Type: <code>Std::I64 -&gt; RegExp.RegExpPattern::Pattern -&gt; (Std::I64, RegExp.RegExpPattern::Pattern)</code></p> <p><code>pat._assign_group_number(n)</code> assigns group number for each group. The first group number becomes <code>n</code>. It returns the translated pattern along with group count.</p>"},{"location":"RegExp.RegExpPattern/#_normal_chars","title":"_normal_chars","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>A table of normal characters, ie. not a meta character.</p>"},{"location":"RegExp.RegExpPattern/#_parse_backslash_char_class","title":"_parse_backslash_char_class","text":"<p>Type: <code>Std::Bool -&gt; RegExp.SimpleParser::Parser RegExp.RegExpPattern::CharClass</code></p> <p>Parses the char class that begins with a backslash. The backslash itself is parsed already.</p>"},{"location":"RegExp.RegExpPattern/#_parse_bracket_component","title":"_parse_bracket_component","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::CharClass</code></p> <p>Parses each component in a bracket.</p>"},{"location":"RegExp.RegExpPattern/#_parse_passert","title":"_parse_passert","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses an assertion pattern, ie. <code>^</code>, <code>$</code> etc.</p>"},{"location":"RegExp.RegExpPattern/#_parse_pclass","title":"_parse_pclass","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses character class pattern, ie. <code>.</code>, <code>[a-z]</code>, <code>\\w</code> etc.</p>"},{"location":"RegExp.RegExpPattern/#_parse_pclass_bracket","title":"_parse_pclass_bracket","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::CharClass</code></p> <p>Parses a character class that begins with '['. The <code>[</code> itself is parsed already.</p>"},{"location":"RegExp.RegExpPattern/#_parse_peither","title":"_parse_peither","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses either-pattern, ie. <code>X|Y</code></p>"},{"location":"RegExp.RegExpPattern/#_parse_pgroup","title":"_parse_pgroup","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses Group Pattern, ie. <code>(X)</code></p>"},{"location":"RegExp.RegExpPattern/#_parse_pquant","title":"_parse_pquant","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses Quantified Pattern, ie. <code>X?</code>, <code>X*</code>, <code>X+</code>, <code>X{n}</code>, <code>X{n,}</code>, <code>X{n,m}</code></p>"},{"location":"RegExp.RegExpPattern/#_parse_pquant_n_m_inner","title":"_parse_pquant_n_m_inner","text":"<p>Type: <code>RegExp.SimpleParser::Parser (Std::I64, Std::I64)</code></p> <p>Parses inner of <code>X{n}</code>, <code>X{n,}</code>, <code>X{n,m}</code></p>"},{"location":"RegExp.RegExpPattern/#_parse_psequence","title":"_parse_psequence","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses sequence of patterns, ie. <code>XYZ</code></p>"},{"location":"RegExp.RegExpPattern/#_parse_quantifiable_item","title":"_parse_quantifiable_item","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses quantifiable item.</p>"},{"location":"RegExp.RegExpPattern/#parse","title":"parse","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg RegExp.RegExpPattern::Pattern</code></p> <p>Parses a pattern from specified string.</p>"},{"location":"RegExp.RegExpPattern/#parse_pattern","title":"parse_pattern","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.RegExpPattern::Pattern</code></p> <p>Parses a pattern from the stream.</p>"},{"location":"RegExp.RegExpPattern/#types-and-aliases","title":"Types and aliases","text":""},{"location":"RegExp.RegExpPattern/#namespace-regexpregexppattern","title":"namespace RegExp.RegExpPattern","text":""},{"location":"RegExp.RegExpPattern/#charclass","title":"CharClass","text":"<p>Defined as: <code>type CharClass = unbox struct { ...fields... }</code></p> <p>Type of a character class.</p>"},{"location":"RegExp.RegExpPattern/#field-label","title":"field <code>label</code>","text":"<p>Type: <code>Std::String</code></p> <p>A label that describes this class (for debugging only)</p>"},{"location":"RegExp.RegExpPattern/#field-f","title":"field <code>f</code>","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p> <p>A member function that judges whether a character is contained in this class or not</p>"},{"location":"RegExp.RegExpPattern/#passertion","title":"PAssertion","text":"<p>Defined as: <code>type PAssertion = unbox union { ...variants... }</code></p> <p>Type of an assertion for regular expressions, such as <code>^</code>, <code>$</code>.</p>"},{"location":"RegExp.RegExpPattern/#variant-pa_begin","title":"variant <code>pa_begin</code>","text":"<p>Type: <code>()</code></p>"},{"location":"RegExp.RegExpPattern/#variant-pa_end","title":"variant <code>pa_end</code>","text":"<p>Type: <code>()</code></p>"},{"location":"RegExp.RegExpPattern/#pattern","title":"Pattern","text":"<p>Defined as: <code>type Pattern = box union { ...variants... }</code></p> <p>Type of a parsed regular expression.</p>"},{"location":"RegExp.RegExpPattern/#variant-pclass","title":"variant <code>pclass</code>","text":"<p>Type: <code>RegExp.RegExpPattern::CharClass</code></p> <p>Character class pattern, eg. <code>a</code>, <code>[a-z]</code>, <code>\\d</code> etc.</p>"},{"location":"RegExp.RegExpPattern/#variant-passert","title":"variant <code>passert</code>","text":"<p>Type: <code>RegExp.RegExpPattern::PAssertion</code></p> <p>Assertion pattern, eg. <code>^</code>, <code>$</code></p>"},{"location":"RegExp.RegExpPattern/#variant-psequence","title":"variant <code>psequence</code>","text":"<p>Type: <code>Std::Array RegExp.RegExpPattern::Pattern</code></p> <p>Sequence of patterns, eg. <code>XYZ</code></p>"},{"location":"RegExp.RegExpPattern/#variant-peither","title":"variant <code>peither</code>","text":"<p>Type: <code>(RegExp.RegExpPattern::Pattern, RegExp.RegExpPattern::Pattern)</code></p> <p>Either pattern, eg. <code>X|Y</code></p>"},{"location":"RegExp.RegExpPattern/#variant-pquant","title":"variant <code>pquant</code>","text":"<p>Type: <code>(RegExp.RegExpPattern::Pattern, Std::I64, Std::I64)</code></p> <p>Quantified pattern, eg. <code>X?</code>, <code>X*</code>, <code>X+</code>, <code>X{n,m}</code></p>"},{"location":"RegExp.RegExpPattern/#variant-pgroup","title":"variant <code>pgroup</code>","text":"<p>Type: <code>(Std::I64, RegExp.RegExpPattern::Pattern)</code></p> <p>Grouped pattern, eg. <code>(X)</code></p>"},{"location":"RegExp.RegExpPattern/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"RegExp.RegExpPattern/#trait-implementations","title":"Trait implementations","text":""},{"location":"RegExp.RegExpPattern/#impl-regexpregexppatterncharclass-stdtostring","title":"impl <code>RegExp.RegExpPattern::CharClass : Std::ToString</code>","text":"<p>Converts a character class to a string.</p>"},{"location":"RegExp.RegExpPattern/#impl-regexpregexppatternpassertion-stdtostring","title":"impl <code>RegExp.RegExpPattern::PAssertion : Std::ToString</code>","text":"<p>Converts an assertion to a string.</p>"},{"location":"RegExp.RegExpPattern/#impl-regexpregexppatternpattern-stdtostring","title":"impl <code>RegExp.RegExpPattern::Pattern : Std::ToString</code>","text":"<p>Converts a pattern to a string.</p>"},{"location":"RegExp.SimpleParser/","title":"RegExp.SimpleParser","text":"<p>Defined in regexp@1.1.1</p> <p>Simple text parser. Customizable by monadic operations. - Stream of characters - Basic parsers such as character matching - Create complex parsers with composition</p>"},{"location":"RegExp.SimpleParser/#values","title":"Values","text":""},{"location":"RegExp.SimpleParser/#namespace-regexpsimpleparser","title":"namespace RegExp.SimpleParser","text":""},{"location":"RegExp.SimpleParser/#_notmatch","title":"_NotMatch","text":"<p>Type: <code>Std::ErrMsg</code></p> <p>A special error message that represents the parser is not matched.</p>"},{"location":"RegExp.SimpleParser/#parser","title":"parser","text":"<p>Type: <code>(RegExp.SimpleParser::Stream::Stream -&gt; RegExp.SimpleParser::ParseResult a) -&gt; RegExp.SimpleParser::Parser a</code></p> <p>A function that creates a Parser structure based on the parsing function.</p>"},{"location":"RegExp.SimpleParser/#namespace-regexpsimpleparserparser","title":"namespace RegExp.SimpleParser::Parser","text":""},{"location":"RegExp.SimpleParser/#debug","title":"debug","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser a</code></p> <p>Prints the parser result.</p>"},{"location":"RegExp.SimpleParser/#error_parser","title":"error_parser","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Parser a</code></p> <p>Raises the specified string as an error.</p>"},{"location":"RegExp.SimpleParser/#filter","title":"filter","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser a</code></p> <p>Checks whether the parsed result of the specified Parser satisfies the specified conditions. Raises a <code>_NotMatch</code> error if the specified condition is not met.</p>"},{"location":"RegExp.SimpleParser/#get_stream","title":"get_stream","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.SimpleParser::Stream::Stream</code></p> <p>Returns the current stream position.</p>"},{"location":"RegExp.SimpleParser/#if_exists","title":"if_exists","text":"<p>Type: <code>RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser (Std::Option a)</code></p> <p><code>p.if_exists</code> returns <code>some(x)</code> if <code>p</code> returns <code>x</code> as a parse result, or <code>none()</code> if <code>p</code> does not match.</p>"},{"location":"RegExp.SimpleParser/#map_result","title":"map_result","text":"<p>Type: <code>(a -&gt; Std::Result Std::ErrMsg b) -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser b</code></p> <p><code>parser.map_result(f)</code> maps the parser result with <code>f</code>, possibly reports an error message.</p>"},{"location":"RegExp.SimpleParser/#match_any_char","title":"match_any_char","text":"<p>Type: <code>RegExp.SimpleParser::Parser RegExp.SimpleParser::Char</code></p> <p>Matches any single character. The parsed result is a single matched character. If the match fails (eg. the end of stream), a <code>_NotMatch</code> error is raised.</p>"},{"location":"RegExp.SimpleParser/#match_char","title":"match_char","text":"<p>Type: <code>RegExp.SimpleParser::Char -&gt; RegExp.SimpleParser::Parser ()</code></p> <p>Matches a single character specified by the argument. The parsed result is nothing. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"RegExp.SimpleParser/#match_char_class","title":"match_char_class","text":"<p>Type: <code>(RegExp.SimpleParser::Char -&gt; Std::Bool) -&gt; RegExp.SimpleParser::Parser RegExp.SimpleParser::Char</code></p> <p>Matches a character satisfying the specified condition.</p>"},{"location":"RegExp.SimpleParser/#match_char_if_exists","title":"match_char_if_exists","text":"<p>Type: <code>Std::U8 -&gt; RegExp.SimpleParser::Parser (Std::Option Std::U8)</code></p> <p>Matches a single character if it exists. The parsed result is <code>some(c)</code> if it exists, <code>none()</code> if it does not exist.</p>"},{"location":"RegExp.SimpleParser/#match_empty_str","title":"match_empty_str","text":"<p>Type: <code>RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-length string.</p>"},{"location":"RegExp.SimpleParser/#match_end_of_stream","title":"match_end_of_stream","text":"<p>Type: <code>RegExp.SimpleParser::Parser ()</code></p> <p>Matches zero-length string at the end of stream.</p>"},{"location":"RegExp.SimpleParser/#match_integer","title":"match_integer","text":"<p>Type: <code>RegExp.SimpleParser::Parser Std::I64</code></p> <p>Matches an integer.</p>"},{"location":"RegExp.SimpleParser/#match_one_of_char","title":"match_one_of_char","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a character which is included in the specified string. The parsed result is a string consisting of the single matched character. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"RegExp.SimpleParser/#match_str","title":"match_str","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Parser ()</code></p> <p>Matches a string specified by the argument. The parsed result is nothing. If the match fails, a <code>_NotMatch</code> error is raised.</p>"},{"location":"RegExp.SimpleParser/#match_str_class","title":"match_str_class","text":"<p>Type: <code>(RegExp.SimpleParser::Char -&gt; Std::Bool) -&gt; RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string. Each character should satisfy the specified condition.</p>"},{"location":"RegExp.SimpleParser/#match_str_class_digit","title":"match_str_class_digit","text":"<p>Type: <code>RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of digit characters.</p>"},{"location":"RegExp.SimpleParser/#match_str_class_lower","title":"match_str_class_lower","text":"<p>Type: <code>RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of lowercase characters.</p>"},{"location":"RegExp.SimpleParser/#match_str_class_whitespace","title":"match_str_class_whitespace","text":"<p>Type: <code>RegExp.SimpleParser::Parser Std::String</code></p> <p>Matches a zero-or-more-length string of whitespace characters.</p>"},{"location":"RegExp.SimpleParser/#not_match","title":"not_match","text":"<p>Type: <code>RegExp.SimpleParser::Parser a</code></p> <p>Raises a <code>_NotMatch</code> error.</p>"},{"location":"RegExp.SimpleParser/#one_or_more","title":"one_or_more","text":"<p>Type: <code>RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser (Std::Array a)</code></p> <p>Same as <code>zero_or_more</code>, but raises a _NotMatch error if the array length is zero.</p>"},{"location":"RegExp.SimpleParser/#or_else","title":"or_else","text":"<p>Type: <code>RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser a</code></p> <p>If the first Parser raises a <code>_NotMatch</code> error, tries the second Parser. Note that <code>pa1.or_else(pa2)</code> is interpreted as <code>or_else(pa2, pa1)</code>, and  that <code>pa1.or_else $ pa2</code> is interpreted as <code>or_else(pa1, pa2)</code>.</p>"},{"location":"RegExp.SimpleParser/#or_error","title":"or_error","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser a</code></p> <p>If the Parser reports any error (including <code>_NotMatch</code>), raises the specified string as an error.</p>"},{"location":"RegExp.SimpleParser/#repeat","title":"repeat","text":"<p>Type: <code>RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser (Std::Array a)</code></p> <p>Repeats matches as many as possible. The parse result is an array of successful matches. If a _NotMatch error is raised, returns as success. If an error other than _NotMatch is raised, reports that error.</p>"},{"location":"RegExp.SimpleParser/#run_parser","title":"run_parser","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::ParseResult a</code></p> <p>Apply a stream to a parsing function and return the parsed result.</p>"},{"location":"RegExp.SimpleParser/#run_parser_str","title":"run_parser_str","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::ParseResult a</code></p> <p>Create a stream from a string, then apply a stream to a parsing function and return the parsed result.</p>"},{"location":"RegExp.SimpleParser/#unit","title":"unit","text":"<p>Type: <code>RegExp.SimpleParser::Parser ()</code></p> <p>Match zero-length string.</p>"},{"location":"RegExp.SimpleParser/#zero_or_more","title":"zero_or_more","text":"<p>Type: <code>RegExp.SimpleParser::Parser a -&gt; RegExp.SimpleParser::Parser (Std::Array a)</code></p> <p>Synonym for <code>repeat</code>.</p>"},{"location":"RegExp.SimpleParser/#namespace-regexpsimpleparserstream","title":"namespace RegExp.SimpleParser::Stream","text":""},{"location":"RegExp.SimpleParser/#advance","title":"advance","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream -&gt; Std::Option (RegExp.SimpleParser::Char, RegExp.SimpleParser::Stream::Stream)</code></p> <p><code>stream.advance</code> gets next character and increment the stream position.</p>"},{"location":"RegExp.SimpleParser/#empty","title":"empty","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream</code></p> <p>An empty Stream.</p>"},{"location":"RegExp.SimpleParser/#error","title":"error","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Stream::Stream -&gt; Std::Result Std::ErrMsg a</code></p> <p><code>stream.error(str)</code> reports an error along with where it occurred.</p>"},{"location":"RegExp.SimpleParser/#make","title":"make","text":"<p>Type: <code>Std::String -&gt; RegExp.SimpleParser::Stream::Stream</code></p> <p>Creates a stream from specified string.</p>"},{"location":"RegExp.SimpleParser/#read_all","title":"read_all","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream -&gt; (Std::Array RegExp.SimpleParser::Char, RegExp.SimpleParser::Stream::Stream)</code></p> <p><code>stream.read_all</code> reads all characters to the end of stream.</p>"},{"location":"RegExp.SimpleParser/#read_string","title":"read_string","text":"<p>Type: <code>Std::I64 -&gt; RegExp.SimpleParser::Stream::Stream -&gt; Std::String</code></p> <p><code>stream.read_string(n)</code> reads at most <code>n</code> characters and convert them to a string.</p>"},{"location":"RegExp.SimpleParser/#types-and-aliases","title":"Types and aliases","text":""},{"location":"RegExp.SimpleParser/#namespace-regexpsimpleparser_1","title":"namespace RegExp.SimpleParser","text":""},{"location":"RegExp.SimpleParser/#char","title":"Char","text":"<p>Defined as: <code>type Char = Std::U8</code></p> <p>The type of characters. Currently only UTF-8 string is supported.</p>"},{"location":"RegExp.SimpleParser/#parseresult","title":"ParseResult","text":"<p>Defined as: <code>type ParseResult a = Std::Result Std::ErrMsg (a, RegExp.SimpleParser::Stream::Stream)</code></p> <p>Result type that returns a value of an arbitrary type and a stream.</p>"},{"location":"RegExp.SimpleParser/#parser_1","title":"Parser","text":"<p>Defined as: <code>type Parser a = unbox struct { ...fields... }</code></p> <p>A structure with a function that receive a stream, parse it, and return the parsed result and the next stream position.</p>"},{"location":"RegExp.SimpleParser/#field-_parser","title":"field <code>_parser</code>","text":"<p>Type: <code>RegExp.SimpleParser::Stream::Stream -&gt; RegExp.SimpleParser::ParseResult a</code></p>"},{"location":"RegExp.SimpleParser/#namespace-regexpsimpleparserstream_1","title":"namespace RegExp.SimpleParser::Stream","text":""},{"location":"RegExp.SimpleParser/#stream","title":"Stream","text":"<p>Defined as: <code>type Stream = unbox struct { ...fields... }</code></p> <p>A character iterator that stores the file name, line number, column number, and offset from the beginning of the file.</p>"},{"location":"RegExp.SimpleParser/#field-filename","title":"field <code>filename</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"RegExp.SimpleParser/#field-line","title":"field <code>line</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.SimpleParser/#field-column","title":"field <code>column</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.SimpleParser/#field-position","title":"field <code>position</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"RegExp.SimpleParser/#field-iter","title":"field <code>iter</code>","text":"<p>Type: <code>Std::Iterator::DynIterator RegExp.SimpleParser::Char</code></p>"},{"location":"RegExp.SimpleParser/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"RegExp.SimpleParser/#trait-implementations","title":"Trait implementations","text":""},{"location":"RegExp.SimpleParser/#impl-regexpsimpleparserparser-stdfunctor","title":"impl <code>RegExp.SimpleParser::Parser : Std::Functor</code>","text":""},{"location":"RegExp.SimpleParser/#impl-regexpsimpleparserparser-stdmonad","title":"impl <code>RegExp.SimpleParser::Parser : Std::Monad</code>","text":""},{"location":"RegExp.SimpleParser/#impl-regexpsimpleparserstreamstream-stdfromstring","title":"impl <code>RegExp.SimpleParser::Stream::Stream : Std::FromString</code>","text":"<p>Creates a stream from a string.</p>"},{"location":"RegExp.SimpleParser/#impl-regexpsimpleparserstreamstream-stdtostring","title":"impl <code>RegExp.SimpleParser::Stream::Stream : Std::ToString</code>","text":"<p>Converts a stream to a string, for example <code>\"Stream(pos=1001)\"</code></p>"},{"location":"RegExp.StringEx/","title":"RegExp.StringEx","text":"<p>Defined in regexp@1.1.1</p> <p>String extensions, such as: - ToString for Tuple, Option, Result, Array, HashMap - Array U8 -&gt; String conversion - Search, replace, split, comparison of String - Hexadecimal String - File Path handling</p>"},{"location":"RegExp.StringEx/#values","title":"Values","text":""},{"location":"RegExp.StringEx/#namespace-regexpstringex","title":"namespace RegExp.StringEx","text":""},{"location":"RegExp.StringEx/#_array_cmp_inner","title":"_array_cmp_inner","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Array Std::U8 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p>"},{"location":"RegExp.StringEx/#_unsafe_to_string","title":"_unsafe_to_string","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String</code></p> <p>Converts a byte array to a string. Specifically, it calls <code>String::_unsafe_to_string()</code> after appending a null character to the end of the byte array.</p>"},{"location":"RegExp.StringEx/#byte_to_string","title":"byte_to_string","text":"<p>Type: <code>Std::U8 -&gt; Std::String</code></p> <p>Converts a byte (a character) to a string of length 1.</p>"},{"location":"RegExp.StringEx/#decode_hex_char","title":"decode_hex_char","text":"<p>Type: <code>Std::U8 -&gt; Std::Result Std::ErrMsg Std::U8</code></p> <p>Converts a hex character ('0'..'9', 'A'..'F' or 'a'..'f') to a 4bit number (0..15).</p>"},{"location":"RegExp.StringEx/#dirname","title":"dirname","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p><code>dirname(path)</code> returns the path with its last non-slash component and trailing slashes removed. if <code>path</code> contains no <code>/</code>s, returns <code>\".\"</code>.</p>"},{"location":"RegExp.StringEx/#encode_hex_char","title":"encode_hex_char","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>Converts a 4bit number (0..15) to a hex character ('0'..'9', 'A'..'F').</p>"},{"location":"RegExp.StringEx/#ends_with","title":"ends_with","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Bool</code></p> <p>Checks if a string ends with the specified suffix.</p>"},{"location":"RegExp.StringEx/#find_byte","title":"find_byte","text":"<p>Type: <code>Std::U8 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p>Searches for the specified byte from the beginning of a string. If found, returns the index of that byte.</p>"},{"location":"RegExp.StringEx/#find_last_byte","title":"find_last_byte","text":"<p>Type: <code>Std::U8 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p>Searches for the specified byte from the end of a string. If found, returns the index of that byte.</p>"},{"location":"RegExp.StringEx/#formatv","title":"formatv","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::String -&gt; Std::String</code></p> <p><code>array.formatv(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with each element of <code>array</code>. Currently only supports <code>{}</code>.</p>"},{"location":"RegExp.StringEx/#from_string_hex","title":"from_string_hex","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::ErrMsg Std::U64</code></p> <p>Converts a hex string to a 64bit number.</p>"},{"location":"RegExp.StringEx/#is_path_sep","title":"is_path_sep","text":"<p>Type: <code>Std::U8 -&gt; Std::Bool</code></p> <p>Checks if the byte is a path separator. Currently only '/' is supported.</p>"},{"location":"RegExp.StringEx/#join_paths","title":"join_paths","text":"<p>Type: <code>Std::Array Std::String -&gt; Std::String</code></p> <p><code>join_paths(path_segments)</code> joins segments into a path.</p>"},{"location":"RegExp.StringEx/#replace_all","title":"replace_all","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String -&gt; Std::String</code></p> <p>Replaces all occurrences of <code>from</code> in the string with <code>to</code>.</p>"},{"location":"RegExp.StringEx/#replace_suffix","title":"replace_suffix","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String -&gt; Std::Result Std::ErrMsg Std::String</code></p> <p><code>str.replace_suffix(from, to)</code> replaces <code>from</code> at the end of <code>str</code> with <code>to</code>. if <code>str</code> does not end with <code>from</code>, an error occurs. Example:</p> <pre><code>\"test.txt\".replace_suffix(\".txt\", \".tmp\")  ==&gt; ok(\"test.tmp\")\n\"test.jpg\".replace_suffix(\".txt\", \".tmp\")  ==&gt; err(\"suffix does not match: test.jpg\")\n</code></pre>"},{"location":"RegExp.StringEx/#split_by","title":"split_by","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; RegExp.StringEx::SplitByIterator</code></p> <p>Splits a string by a function that checks whether a character is a delimiter or not. The result will not contain any empty string.</p>"},{"location":"RegExp.StringEx/#split_ex","title":"split_ex","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Iterator::DynIterator Std::String</code></p> <p>Same as Std::String::split, except that <code>\"foo\".split_ex(\",\")</code> returns a singleton iterator of \"foo\".</p>"},{"location":"RegExp.StringEx/#split_first","title":"split_first","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; (Std::String, Std::String)</code></p> <p><code>str.split_first(delim)</code> splits the string <code>str</code> into two parts with the delimiter <code>delim</code>. Returns <code>(left, right)</code> where <code>left</code> is the left part of the delimiter, and <code>right</code> is the right part of the delimiter. Returns <code>(str, \"\")</code> if the delimiter is not found.</p>"},{"location":"RegExp.StringEx/#starts_with","title":"starts_with","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Bool</code></p> <p>Checks if a string starts with the specified prefix.</p>"},{"location":"RegExp.StringEx/#string_less_than","title":"string_less_than","text":"<p>Type: <code>(Std::String, Std::String) -&gt; Std::Bool</code></p> <p><code>string_less_than((str1,str2))</code> compares two strings. Returns True if and only if <code>str1</code> is less than <code>str2</code> in lexicographical order.</p>"},{"location":"RegExp.StringEx/#substring","title":"substring","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::String -&gt; Std::String</code></p> <p>Returns a substring extracted from a specified range from a string. If the specified range exceeds the string, it will be truncated to fit within the string.</p>"},{"location":"RegExp.StringEx/#to_lower","title":"to_lower","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Converts the specified string to lowercase.</p>"},{"location":"RegExp.StringEx/#to_string_hex","title":"to_string_hex","text":"<p>Type: <code>Std::U64 -&gt; Std::String</code></p> <p>Converts a 64bit number to a hex string.</p>"},{"location":"RegExp.StringEx/#to_upper","title":"to_upper","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Converts the specified string to uppercase.</p>"},{"location":"RegExp.StringEx/#namespace-regexpstringexarray","title":"namespace RegExp.StringEx::Array","text":""},{"location":"RegExp.StringEx/#format","title":"format","text":"<p>Type: <code>[a : Std::ToString] Std::String -&gt; Std::Array a -&gt; Std::String</code></p> <p><code>array.format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with each element of <code>array</code>. Currently only supports <code>{}</code>.</p>"},{"location":"RegExp.StringEx/#namespace-regexpstringextuple2","title":"namespace RegExp.StringEx::Tuple2","text":""},{"location":"RegExp.StringEx/#format_1","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString] Std::String -&gt; (a, b) -&gt; Std::String</code></p> <p><code>(a, b).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>.</p>"},{"location":"RegExp.StringEx/#namespace-regexpstringextuple3","title":"namespace RegExp.StringEx::Tuple3","text":""},{"location":"RegExp.StringEx/#format_2","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString, c : Std::ToString] Std::String -&gt; (a, b, c) -&gt; Std::String</code></p> <p><code>(a, b, c).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>, <code>c</code>.</p>"},{"location":"RegExp.StringEx/#namespace-regexpstringextuple4","title":"namespace RegExp.StringEx::Tuple4","text":""},{"location":"RegExp.StringEx/#format_3","title":"format","text":"<p>Type: <code>[a : Std::ToString, b : Std::ToString, c : Std::ToString, d : Std::ToString] Std::String -&gt; (a, b, c, d) -&gt; Std::String</code></p> <p><code>(a, b, c, d).format(str)</code> replaces each occurence of <code>{}</code> in the format string <code>str</code> with <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>.</p>"},{"location":"RegExp.StringEx/#types-and-aliases","title":"Types and aliases","text":""},{"location":"RegExp.StringEx/#namespace-regexpstringex_1","title":"namespace RegExp.StringEx","text":""},{"location":"RegExp.StringEx/#splitbyiterator","title":"SplitByIterator","text":"<p>Defined as: <code>type SplitByIterator = Std::Iterator::ArrayIterator Std::String</code></p>"},{"location":"RegExp.StringEx/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"RegExp.StringEx/#trait-implementations","title":"Trait implementations","text":""},{"location":"RegExp/","title":"RegExp","text":"<p>Defined in regexp@1.1.1</p> <p>Simple regular expression.</p> <p>Currently it only supports patterns below: - Character classes: <code>[xyz]</code>, <code>[^xyz]</code>, <code>.</code>, <code>\\d</code>, <code>\\D</code>, <code>\\w</code>, <code>\\W</code>, <code>\\s</code>,   <code>\\S</code>, <code>\\t</code>, <code>\\r</code>, <code>\\n</code>, <code>\\v</code>, <code>\\f</code>, <code>[\\b]</code>, <code>x|y</code> - Assertions: <code>^</code>, <code>$</code> - Groups: <code>(x)</code> - Quantifiers: <code>x*</code>, <code>x+</code>, <code>x?</code>, <code>x{n}</code>, <code>x{n,}</code>, <code>x{n,m}</code></p> <p>For details, see mdn web docs: Regular expressions.</p> <p>LIMITATION:</p> <p>Currently, only single byte characters (U+0001..U+007F) can be specified in character classes. Non-ASCII characters (U+0080..U+10FFFF) are encoded to two or more bytes in UTF-8, so they cannot be specified in character classes. And the null character (U+0000) cannot be used in Fix strings.</p>"},{"location":"RegExp/#values","title":"Values","text":""},{"location":"RegExp/#namespace-regexpregexp","title":"namespace RegExp::RegExp","text":""},{"location":"RegExp/#_convert_groups_to_string","title":"_convert_groups_to_string","text":"<p>Type: <code>Std::Array RegExp.RegExpNFA::Group -&gt; Std::String -&gt; Std::Array Std::String</code></p>"},{"location":"RegExp/#compile","title":"compile","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::Result Std::ErrMsg RegExp::RegExp</code></p> <p><code>RegExp::compile(pattern, flags)</code> compiles <code>pattern</code> into a regular expression. <code>flags</code> change behavior of regular expression matching. Currently only global flag (<code>\"g\"</code>) is supported.</p>"},{"location":"RegExp/#match_all","title":"match_all","text":"<p>Type: <code>Std::String -&gt; RegExp::RegExp -&gt; Std::Array (Std::Array Std::String)</code></p> <p><code>regexp.match_all(target)</code> matches <code>target</code> against <code>regexp</code>. All matching results will be returned including captured groups.</p> <p>If the match against the regular expression fails, an empty array is returned.</p> <p>This function is similar to String.matchAll() function of JavaScript.</p>"},{"location":"RegExp/#match_one","title":"match_one","text":"<p>Type: <code>Std::String -&gt; RegExp::RegExp -&gt; Std::Result Std::ErrMsg (Std::Array Std::String)</code></p> <p><code>regexp.match(target)</code> matches <code>target</code> against <code>regexp</code>.</p> <p>If the global flag (<code>\"g\"</code>) is not set, it returns an array of the groups of the first match. Group 0 is a substring that matches the entire regular expression. Group 1 and beyond are the captured substrings in each group. If not captured, the group will be an empty string.</p> <p>Example:</p> <pre><code>let regexp = RegExp::compile(\"[a-z]+([0-9]+)\", \"\").as_ok;\nlet groups = regexp.match_one(\"abc012 def345\").as_ok;\n// groups == [\"abc012\", \"012\"]\n</code></pre> <p>If the global flag (<code>\"g\"</code>) is set, all matching results will be returned, but captured groups will not be included.</p> <p>Example:</p> <pre><code>let regexp = RegExp::compile(\"[a-z]+([0-9]+)\", \"g\").as_ok;\nlet groups = regexp.match_one(\"abc012 def345\").as_ok;\n// groups == [\"abc012\", \"def345\"]\n</code></pre> <p>If the match against the regular expression fails, an error <code>\"NotMatch\"</code> is reported.</p> <p>This function is similar to String.match() function of JavaScript.</p>"},{"location":"RegExp/#replace_all","title":"replace_all","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; RegExp::RegExp -&gt; Std::String</code></p> <p><code>regexp.replace_all(target, replacement)</code> matches <code>target</code> against <code>regexp</code>, and replace all matching substrings with <code>replacement</code>. If <code>replacement</code> contains <code>$&amp;</code>, it is substituted with entire matched substring. If <code>replacement</code> contains <code>$n</code> where <code>n</code> is an integer, it is substituted with the captured group. If <code>replacement</code> contains <code>$$</code>, it is substituted with single <code>$</code>.</p> <p>Example:</p> <pre><code>let regexp = RegExp::compile(\"(\\\\w\\\\w)(\\\\w)\", \"\").as_ok;\nlet result = regexp.replace_all(\"abc def ijk\", \"$2$1\");\n// result == \"cab fde kij\"\n</code></pre> <p>This function is similar to String.replaceAll() function of JavaScript. Note that <code>$'</code>, <code>$`</code>, <code>$&lt;Name&gt;</code> are not supported yet.</p>"},{"location":"RegExp/#types-and-aliases","title":"Types and aliases","text":""},{"location":"RegExp/#namespace-regexp","title":"namespace RegExp","text":""},{"location":"RegExp/#regexp_1","title":"RegExp","text":"<p>Defined as: <code>type RegExp = unbox struct { ...fields... }</code></p> <p>Type of a compiled regular expression.</p>"},{"location":"RegExp/#field-flags","title":"field <code>flags</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"RegExp/#field-nfa","title":"field <code>nfa</code>","text":"<p>Type: <code>RegExp.RegExpNFA::NFA</code></p>"},{"location":"RegExp/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"RegExp/#trait-implementations","title":"Trait implementations","text":""},{"location":"Std/","title":"Std","text":"<p>Defined in std-doc@0.1.0</p> <p>Module <code>Std</code> provides basic types, traits and values.</p> <p>This module is special in the sense that:</p> <ul> <li>It is always imported implicitly. If you don't want to import some or all of entities in this module, you should write <code>import Std {...entities...}</code> explicitly.</li> <li>It contains built-in types or values which are defined or implemented directly by Fix compiler, not by Fix source code.</li> </ul> <p>NOTE on tuples: The tuple types <code>Std::TupleN</code> are defined on demand, i.e., if the user uses N-tuple in the source code, the compiler generates definition <code>TupleN</code> and related functions / trait implementations. The document for <code>Std</code> module describes about them up to N=3, but you can use larger tuples in the same way.</p>"},{"location":"Std/#values","title":"Values","text":""},{"location":"Std/#namespace-std","title":"namespace Std","text":""},{"location":"Std/#compose","title":"compose","text":"<p>Type: <code>(a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</code></p> <p>Composes two functions. Composition operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> is translated to use of <code>compose</code>.</p>"},{"location":"Std/#fix","title":"fix","text":"<p>Type: <code>((a -&gt; b) -&gt; a -&gt; b) -&gt; a -&gt; b</code></p> <p><code>fix</code> enables you to make a recursive function locally.</p> <p>The idiom is <code>fix $ |loop, arg| -&gt; {loop_body}</code>. In <code>{loop_body}</code>, you can call <code>loop</code> to make a recursion.</p> <p>Example:</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    let fact = fix $ |loop, n| if n == 0 { 1 } else { n * loop (n-1) };\n    println $ fact(5).to_string // evaluates to 5 * 4 * 3 * 2 * 1 = 120\n);\n</code></pre>"},{"location":"Std/#loop","title":"loop","text":"<p>Type: <code>s -&gt; (s -&gt; Std::LoopState s r) -&gt; r</code></p> <p><code>loop</code> enables you to make a loop. <code>LoopState</code> is a union type defined as follows:</p> <pre><code>type LoopState s r = unbox union { continue : s, break : r };\n</code></pre> <p><code>loop</code> takes two arguments: the initial state of the loop <code>s0</code> and the loop body function <code>body</code>. It first calls <code>body</code> on <code>s0</code>. If <code>body</code> returns <code>break(r)</code>, then the loop ends and returns <code>r</code> as the result. If <code>body</code> returns <code>continue(s)</code>, then the loop calls again <code>body</code> on <code>s</code>.</p> <p>Example:</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    let sum = loop((0, 0), |(i, sum)|\n        if i == 100 { break $ sum };\n        continue $ (i + 1, sum + i)\n    );\n    println $ sum.to_string\n); // evaluates to 0 + 1 + ... + 99\n</code></pre>"},{"location":"Std/#loop_m","title":"loop_m","text":"<p>Type: <code>[m : Std::Monad] s -&gt; (s -&gt; m (Std::LoopState s r)) -&gt; m r</code></p> <p>Monadic loop function. This is similar to <code>loop</code> but can be used to perform monadic action at each loop.</p> <p>It is convenient to use <code>continue_m</code> and <code>break_m</code> to create monadic loop body function.</p> <p>The following program prints \"Hello World! (i)\" for i = 0, 1, 2.</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    loop_m(0, |i| (\n        if i == 3 { break_m $ () };\n        println(\"Hello World! (\" + i.to_string + \")\");;\n        continue_m $ i + 1\n    ))\n);\n</code></pre>"},{"location":"Std/#mark_threaded","title":"mark_threaded","text":"<p>Type: <code>a -&gt; a</code></p> <p>Traverses all values reachable from the given value, and changes the reference counters of them into multi-threaded mode.</p>"},{"location":"Std/#undefined","title":"undefined","text":"<p>Type: <code>Std::String -&gt; a</code></p> <p>Generates an undefined value.</p> <p>Calling this function prints <code>msg</code> to the stderr, flush stderr, and aborts the program (calls <code>abort</code> in libc). Since <code>undefined(msg)</code> has generic type <code>a</code>, you can put it anywhere and it will be type-checked.</p> <p>This is useful when you want to write a placeholder that will be implemented later:</p> <pre><code>truth : I64;\ntruth = undefined(\"I will implement the truth later.\");\n</code></pre> <p>Another use case is aborting the program when a certain branch of the code should not be reached:</p> <pre><code>if condition {\n    // Do something.\n} else {\n    undefined(\"This branch should not be reached.\");\n}\n</code></pre>"},{"location":"Std/#unsafe_is_unique","title":"unsafe_is_unique","text":"<p>Type: <code>a -&gt; (Std::Bool, a)</code></p> <p>This function checks if a value is uniquely referenced by a name, and returns the result paired with the given value itself. An unboxed value is always considered unique.</p> <p>NOTE: Changing outputs of your function depending on uniqueness breaks the referential transparency of the function. If you want to assert that a value is unique, consider using <code>Debug::assert_unique</code> instead.</p> <p>Example: </p> <pre><code>module Main;\n\n\nmain : IO ();\nmain = (\n    // For unboxed value, it returns true even if the value is used later.\n    let int_val = 42;\n    let (unique, _) = int_val.unsafe_is_unique;\n    let use = int_val + 1;\n    assert_eq(|_|\"fail: int_val is shared\", unique, true);;\n\n    // For boxed value, it returns true if the value isn't used later.\n    let arr = Array::fill(10, 10);\n    let (unique, arr) = arr.unsafe_is_unique;\n    let use = arr.@(0); // This `arr` is not the one passed to `is_unique`, but the one returned by `is_unique`.\n    assert_eq(|_|\"fail: arr is shared\", unique, true);;\n\n    // Fox boxed value, it returns false if the value will be used later.\n    let arr = Array::fill(10, 10);\n    let (unique, _) = arr.unsafe_is_unique;\n    let use = arr.@(0);\n    assert_eq(|_|\"fail: arr is unique\", unique, false);;\n\n    pure()\n);\n</code></pre>"},{"location":"Std/#with_retained","title":"with_retained","text":"<p>Type: <code>(a -&gt; b) -&gt; a -&gt; b</code></p> <p><code>x.with_retained(f)</code> runs <code>f</code> with retained <code>x</code>.  It is guaranteed that <code>x</code> is keep alive until <code>with_retained</code> is finished, even after <code>f</code> has finished using <code>x</code> in it. </p> <p>A typical use case of this function is the implementation of <code>Std::Array::borrow_ptr</code>.</p>"},{"location":"Std/#namespace-stdadd","title":"namespace Std::Add","text":""},{"location":"Std/#add","title":"add","text":"<p>Type: <code>[a : Std::Add] a -&gt; a -&gt; a</code></p> <p>Adds two values. An expression <code>x + y</code> is translated to <code>add(x, y)</code>.</p>"},{"location":"Std/#namespace-stdarray","title":"namespace Std::Array","text":""},{"location":"Std/#_1","title":"@","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; a</code></p> <p>Gets an element of an array at the specified index.</p>"},{"location":"Std/#_get_ptr","title":"_get_ptr","text":"<p>Type: <code>Std::Array a -&gt; Std::Ptr</code></p> <p>Get the pointer to the memory region where elements are stored.</p> <p>This function is dangerous because if the array is not used after call of this function, the array will be deallocated soon and the returned pointer will be dangling. Try using <code>borrow_ptr</code> instead.</p> <p>@deprecated Use <code>Std::FFI::_get_boxed_ptr</code> instead.</p>"},{"location":"Std/#_get_sub_size_with_length_and_additional_capacity","title":"_get_sub_size_with_length_and_additional_capacity","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>A function like <code>get_sub</code>, but behaves as if the size of the array is the specified value, and has a parameter to specify additional capacity of the returned <code>Array</code>.</p>"},{"location":"Std/#_sort_range_using_buffer","title":"_sort_range_using_buffer","text":"<p>Type: <code>Std::Array a -&gt; Std::I64 -&gt; Std::I64 -&gt; ((a, a) -&gt; Std::Bool) -&gt; Std::Array a -&gt; (Std::Array a, Std::Array a)</code></p> <p>Sorts elements in a range of a vector by \"less than\" comparator.</p> <p>This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.</p>"},{"location":"Std/#_unsafe_force_unique","title":"_unsafe_force_unique","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a</code></p> <p>Force the uniqueness of an array. If the given array is shared, this function returns the cloned array.</p> <p>DEPRECATED: This function is unsafe and deprecated because it is fragile when the \"common expression elimination\" optimization is implemented in the future.  Consider the following example:</p> <pre><code>f : Array a -&gt; Array a\nf = |arr| arr.force_unique.do_something_for_unique_array;\n\nlet x = [1, 2, 3];\nlet y = f(x);\nlet z = f(x);\n</code></pre> <p>When this function <code>f</code> is inlined, the code will be as follows.</p> <pre><code>let x = [1, 2, 3];\nlet y = x.force_unique.do_something_for_unique_array;\nlet z = x.force_unique.do_something_for_unique_array;\n</code></pre> <p>Here, if the optimization is applied to the two <code>x.force_unique</code>, the code will call <code>do_something_for_unique_array</code> with a non-unique array.</p> <pre><code>let x = [1, 2, 3];\nlet x = x.force_unique;\nlet y = x.do_something_for_unique_array; // Here `x` is not unique\nlet z = x.do_something_for_unique_array;\n</code></pre> <p>Therefore, to use this function safely, you need to suppress the inlining of the above <code>f</code>. It is uncertain whether a function attribute such as \"noinline\" will be added in the future, so this function is deprecated currently.</p>"},{"location":"Std/#_unsafe_get","title":"_unsafe_get","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; a</code></p> <p>Gets a value from an array and returns it paired with the array itself, without bounds checking and retaining the value.</p>"},{"location":"Std/#_unsafe_get_linear","title":"_unsafe_get_linear","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; (Std::Array a, a)</code></p> <p>Gets a value from an array, without bounds checking and retaining the returned value.</p>"},{"location":"Std/#_unsafe_set","title":"_unsafe_set","text":"<p>Type: <code>Std::I64 -&gt; a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Sets a value into an array, without uniqueness checking, bounds checking and releasing the old value.</p>"},{"location":"Std/#_unsafe_set_size","title":"_unsafe_set_size","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Updates the length of an array, without uniqueness checking or validation of the given length value.</p>"},{"location":"Std/#act","title":"act","text":"<p>Type: <code>[f : Std::Functor] Std::I64 -&gt; (a -&gt; f a) -&gt; Std::Array a -&gt; f (Std::Array a)</code></p> <p>Modifies an array by a functorial action.</p> <p>Semantically, <code>arr.act(idx, fun)</code> is equivalent to <code>fun(arr.@(idx)).map(|elm| arr.set(idx, elm))</code>.</p> <p>This function can be defined for any functor <code>f</code> in general, but it is easier to understand the behavior when <code>f</code> is a monad: the monadic action <code>act(idx, fun, arr)</code> first performs <code>fun(arr.@(idx))</code> to get a value <code>elm</code>, and returns a pure value <code>arr.set(idx, elm)</code>.</p> <p>If you call <code>arr.act(idx, fun)</code> when both of <code>arr</code> and <code>arr.@(idx)</code> are unique, it is assured that <code>fun</code> receives the unique value.</p> <p>If you call <code>act</code> on an array which is shared, this function clones the given array when inserting the result of your action into the array. This means that you don't need to pay cloning cost when your action failed, as expected.</p>"},{"location":"Std/#append","title":"append","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Appends an array to an array.</p> <p>Note: Since <code>a1.append(a2)</code> puts <code>a2</code> after <code>a1</code>, <code>append(lhs, rhs)</code> puts <code>lhs</code> after <code>rhs</code>.</p>"},{"location":"Std/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a</code></p> <p>Creates an empty array with specified capacity.</p>"},{"location":"Std/#fill","title":"fill","text":"<p>Type: <code>Std::I64 -&gt; a -&gt; Std::Array a</code></p> <p>Creates an array of the specified length filled with the initial value.</p> <p>The capacity is set to the same value as the length.</p> <p>Example: <code>fill(n, x) == [x, x, x, ..., x]</code> (of length <code>n</code>).</p>"},{"location":"Std/#find_by","title":"find_by","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::Option Std::I64</code></p> <p>Finds the first index at which the element satisfies a condition.</p>"},{"location":"Std/#from_iter","title":"from_iter","text":"<p>Type: <code>[it : Std::Iterator, Std::Iterator::Item it = a] it -&gt; Std::Array a</code></p> <p>Create an array from an iterator.</p>"},{"location":"Std/#from_map","title":"from_map","text":"<p>Type: <code>Std::I64 -&gt; (Std::I64 -&gt; a) -&gt; Std::Array a</code></p> <p>Creates an array by a mapping function.</p>"},{"location":"Std/#get_capacity","title":"get_capacity","text":"<p>Type: <code>Std::Array a -&gt; Std::I64</code></p> <p>Gets the capacity of an array.</p>"},{"location":"Std/#get_first","title":"get_first","text":"<p>Type: <code>Std::Array a -&gt; Std::Option a</code></p> <p>Gets the first element of an array. Returns none if the array is empty.</p>"},{"location":"Std/#get_last","title":"get_last","text":"<p>Type: <code>Std::Array a -&gt; Std::Option a</code></p> <p>Gets the last element of an array. Returns none if the array is empty.</p>"},{"location":"Std/#get_size","title":"get_size","text":"<p>Type: <code>Std::Array a -&gt; Std::I64</code></p> <p>Gets the length of an array.</p>"},{"location":"Std/#get_sub","title":"get_sub","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p><code>arr.get_sub(s, e)</code> returns an array <code>[ arr.@(i) | i \u2208 [s, e) ]</code>.</p> <p><code>s</code> and <code>e</code> are clamped to the range <code>[0, arr.get_size]</code>.</p>"},{"location":"Std/#is_empty","title":"is_empty","text":"<p>Type: <code>Std::Array a -&gt; Std::Bool</code></p> <p>Returns if the array is empty</p>"},{"location":"Std/#mod","title":"mod","text":"<p>Type: <code>Std::I64 -&gt; (a -&gt; a) -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Updates an array by applying a function to the element at the specified index.</p> <p>This function clones the given array if it is shared.</p> <p>If you call <code>arr.mod(i, f)</code> when both of <code>arr</code> and <code>arr.@(i)</code> are unique, it is assured that <code>f</code> receives the element value which is unique.</p>"},{"location":"Std/#pop_back","title":"pop_back","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a</code></p> <p>Pops an element at the back of an array. If the array is empty, this function does nothing.</p>"},{"location":"Std/#push_back","title":"push_back","text":"<p>Type: <code>a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Pushes an element to the back of an array.</p>"},{"location":"Std/#reserve","title":"reserve","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Reserves the memory region for an array.</p>"},{"location":"Std/#set","title":"set","text":"<p>Type: <code>Std::I64 -&gt; a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Updates an array by setting a value as the element at the specified index.</p> <p>This function clones the given array if it is shared.</p>"},{"location":"Std/#sort_by","title":"sort_by","text":"<p>Type: <code>((a, a) -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Sorts elements in a vector by \"less than\" comparator.</p>"},{"location":"Std/#to_iter","title":"to_iter","text":"<p>Type: <code>Std::Array a -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Converts an array to an iterator.</p>"},{"location":"Std/#truncate","title":"truncate","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Truncates an array, keeping the given number of first elements.</p> <p><code>truncante(len, arr)</code> does nothing if <code>len &gt;= arr.get_size</code>.</p>"},{"location":"Std/#namespace-stdbox","title":"namespace Std::Box","text":""},{"location":"Std/#make","title":"make","text":"<p>Type: <code>a -&gt; Std::Box a</code></p>"},{"location":"Std/#namespace-stddebug","title":"namespace Std::Debug","text":""},{"location":"Std/#_debug_print_to_stream","title":"_debug_print_to_stream","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::String -&gt; ()</code></p> <p>Prints a string to the specified stream and flushes the stream.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#assert","title":"assert","text":"<p>Type: <code>Std::Lazy Std::String -&gt; Std::Bool -&gt; Std::IO ()</code></p> <p>Asserts that a condition (boolean value) is true.</p> <p>If the assertion failed, prints a message to the stderr and aborts the program.</p>"},{"location":"Std/#assert_eq","title":"assert_eq","text":"<p>Type: <code>[a : Std::Eq] Std::Lazy Std::String -&gt; a -&gt; a -&gt; Std::IO ()</code></p> <p>Asserts that two values are equal.</p> <p>If the assertion failed, prints a message to the stderr and aborts the program.</p>"},{"location":"Std/#assert_unique","title":"assert_unique","text":"<p>Type: <code>Std::Lazy Std::String -&gt; a -&gt; a</code></p> <p>Asserts that the given value is unique, and returns the given value. If the assertion failed, prints a message to the stderr and aborts the program.</p> <p>The main use of this function is to check whether a boxed value given as an argument is unique.</p>"},{"location":"Std/#consumed_time_while_io","title":"consumed_time_while_io","text":"<p>Type: <code>Std::IO a -&gt; Std::IO (a, Std::F64)</code></p> <p>Get clocks (cpu time) elapsed while executing an I/O action.</p>"},{"location":"Std/#consumed_time_while_lazy","title":"consumed_time_while_lazy","text":"<p>Type: <code>Std::Lazy a -&gt; (a, Std::F64)</code></p> <p>Get clocks (cpu time) elapsed while evaluating a lazy value.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#debug_eprint","title":"debug_eprint","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string to stderr and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#debug_eprintln","title":"debug_eprintln","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string followed by a newline to stderr and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#debug_print","title":"debug_print","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string to stdout and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#debug_println","title":"debug_println","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string followed by a newline to stdout and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#namespace-stddiv","title":"namespace Std::Div","text":""},{"location":"Std/#div","title":"div","text":"<p>Type: <code>[a : Std::Div] a -&gt; a -&gt; a</code></p> <p>Divides a value by another value. An expression <code>x / y</code> is translated to <code>div(x, y)</code>.</p>"},{"location":"Std/#namespace-stdeq","title":"namespace Std::Eq","text":""},{"location":"Std/#eq","title":"eq","text":"<p>Type: <code>[a : Std::Eq] a -&gt; a -&gt; Std::Bool</code></p> <p>Checks equality of two values. An expression <code>x == y</code> is translated to <code>eq(x, y)</code>.</p>"},{"location":"Std/#namespace-stdf32","title":"namespace Std::F32","text":""},{"location":"Std/#abs","title":"abs","text":"<p>Type: <code>Std::F32 -&gt; Std::F32</code></p>"},{"location":"Std/#infinity","title":"infinity","text":"<p>Type: <code>Std::F32</code></p> <p>The infinity value for the given floating point type.</p>"},{"location":"Std/#quiet_nan","title":"quiet_nan","text":"<p>Type: <code>Std::F32</code></p> <p>A floating number represented by <code>01...1</code> in binary.</p>"},{"location":"Std/#to_cchar","title":"to_CChar","text":"<p>Type: <code>Std::F32 -&gt; Std::I8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble","title":"to_CDouble","text":"<p>Type: <code>Std::F32 -&gt; Std::FFI::CDouble</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat","title":"to_CFloat","text":"<p>Type: <code>Std::F32 -&gt; Std::FFI::CFloat</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint","title":"to_CInt","text":"<p>Type: <code>Std::F32 -&gt; Std::I32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong","title":"to_CLong","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong","title":"to_CLongLong","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort","title":"to_CShort","text":"<p>Type: <code>Std::F32 -&gt; Std::I16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet","title":"to_CSizeT","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::F32 -&gt; Std::U8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::F32 -&gt; Std::U32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::F32 -&gt; Std::U16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32","title":"to_F32","text":"<p>Type: <code>Std::F32 -&gt; Std::F32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64","title":"to_F64","text":"<p>Type: <code>Std::F32 -&gt; Std::F64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16","title":"to_I16","text":"<p>Type: <code>Std::F32 -&gt; Std::I16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32","title":"to_I32","text":"<p>Type: <code>Std::F32 -&gt; Std::I32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64","title":"to_I64","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8","title":"to_I8","text":"<p>Type: <code>Std::F32 -&gt; Std::I8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16","title":"to_U16","text":"<p>Type: <code>Std::F32 -&gt; Std::U16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32","title":"to_U32","text":"<p>Type: <code>Std::F32 -&gt; Std::U32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64","title":"to_U64","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8","title":"to_U8","text":"<p>Type: <code>Std::F32 -&gt; Std::U8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#to_string_exp","title":"to_string_exp","text":"<p>Type: <code>Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form.</p>"},{"location":"Std/#to_string_exp_precision","title":"to_string_exp_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#to_string_precision","title":"to_string_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#namespace-stdf64","title":"namespace Std::F64","text":""},{"location":"Std/#abs_1","title":"abs","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p>"},{"location":"Std/#infinity_1","title":"infinity","text":"<p>Type: <code>Std::F64</code></p> <p>The infinity value for the given floating point type.</p>"},{"location":"Std/#quiet_nan_1","title":"quiet_nan","text":"<p>Type: <code>Std::F64</code></p> <p>A floating number represented by <code>01...1</code> in binary.</p>"},{"location":"Std/#to_cchar_1","title":"to_CChar","text":"<p>Type: <code>Std::F64 -&gt; Std::I8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_1","title":"to_CDouble","text":"<p>Type: <code>Std::F64 -&gt; Std::FFI::CDouble</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_1","title":"to_CFloat","text":"<p>Type: <code>Std::F64 -&gt; Std::FFI::CFloat</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_1","title":"to_CInt","text":"<p>Type: <code>Std::F64 -&gt; Std::I32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_1","title":"to_CLong","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_1","title":"to_CLongLong","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_1","title":"to_CShort","text":"<p>Type: <code>Std::F64 -&gt; Std::I16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_1","title":"to_CSizeT","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_1","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::F64 -&gt; Std::U8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_1","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::F64 -&gt; Std::U32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_1","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_1","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_1","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::F64 -&gt; Std::U16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_1","title":"to_F32","text":"<p>Type: <code>Std::F64 -&gt; Std::F32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_1","title":"to_F64","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_1","title":"to_I16","text":"<p>Type: <code>Std::F64 -&gt; Std::I16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_1","title":"to_I32","text":"<p>Type: <code>Std::F64 -&gt; Std::I32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_1","title":"to_I64","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_1","title":"to_I8","text":"<p>Type: <code>Std::F64 -&gt; Std::I8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_1","title":"to_U16","text":"<p>Type: <code>Std::F64 -&gt; Std::U16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_1","title":"to_U32","text":"<p>Type: <code>Std::F64 -&gt; Std::U32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_1","title":"to_U64","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_1","title":"to_U8","text":"<p>Type: <code>Std::F64 -&gt; Std::U8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#to_string_exp_1","title":"to_string_exp","text":"<p>Type: <code>Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form.</p>"},{"location":"Std/#to_string_exp_precision_1","title":"to_string_exp_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#to_string_precision_1","title":"to_string_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#namespace-stdffi","title":"namespace Std::FFI","text":""},{"location":"Std/#_get_boxed_ptr","title":"_get_boxed_ptr","text":"<p>Type: <code>[a : Std::Boxed] a -&gt; Std::Ptr</code></p> <p>Returns a pointer to the data of a boxed value.</p> <p>The returned pointer points to: - if the value is an <code>Array</code>, the first element of the array, - if the value is a struct, the first field, - if the value is an union, the data field (not the tag field).</p> <p>The difference from <code>boxed_to_retained_ptr</code> is that this function returns a pointer to region where the payload of a boxed value is stored; on the other hand, <code>boxed_to_retained_ptr</code> returns a pointer to the boxed value itself (which currently points to the reference counter of the boxed value).</p> <p>NOTE:  This function is unsafe in that if the call <code>v._get_boxed_ptr</code> is the last usage of <code>v</code>, then this function deallocates <code>v</code> and returns a dangling pointer. To avoid this issue, use <code>borrow_boxed</code>, <code>borrow_boxed_io</code>, <code>mutate_boxed</code>, or <code>mutate_boxed_io</code> instead.</p>"},{"location":"Std/#borrow_boxed","title":"borrow_boxed","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; b) -&gt; a -&gt; b</code></p> <p>Borrows a pointer to the data of a boxed value.</p> <p>For the details of the pointer, see the document of <code>_get_boxed_ptr</code>.</p>"},{"location":"Std/#borrow_boxed_io","title":"borrow_boxed_io","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO b</code></p> <p>Performs an IO action borrowing a pointer to the data of a boxed value.</p> <p>For the details of the pointer, see the document of <code>_get_boxed_ptr</code>.</p>"},{"location":"Std/#boxed_from_retained_ptr","title":"boxed_from_retained_ptr","text":"<p>Type: <code>[a : Std::Boxed] Std::Ptr -&gt; a</code></p> <p>Creates a boxed value from a retained pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>NOTE:  It is the user's responsibility to ensure that the argument is actually a pointer to the type of the return value, and undefined behavior will occur if it is not.</p>"},{"location":"Std/#boxed_to_retained_ptr","title":"boxed_to_retained_ptr","text":"<p>Type: <code>[a : Std::Boxed] a -&gt; Std::Ptr</code></p> <p>Returns a retained pointer to a boxed value. This function is used to share ownership of Fix's boxed values with foreign languages.</p> <p>To get back the boxed value from the retained pointer, use <code>from_retained_ptr</code>. To release / retain the value in a foreign language, call the function pointer obtained by <code>get_funptr_release</code> or <code>get_funptr_retain</code> on the pointer.</p> <p>Note that the returned pointer points to the control block allocated by Fix, and does not necessary points to the data of the boxed value. If you want to get a pointer to the data of the boxed value, use <code>borrow_boxed</code>.</p>"},{"location":"Std/#clear_errno","title":"clear_errno","text":"<p>Type: <code>Std::IO ()</code></p> <p>Sets errno to zero.</p>"},{"location":"Std/#get_errno","title":"get_errno","text":"<p>Type: <code>Std::IO Std::FFI::CInt</code></p> <p>Gets errno which is set by C functions.</p>"},{"location":"Std/#get_funptr_release","title":"get_funptr_release","text":"<p>Type: <code>[a : Std::Boxed] Std::Lazy a -&gt; Std::Ptr</code></p> <p>Returns a pointer to the function of type <code>void (*)(void*)</code> which releases a boxed value of type <code>a</code>. This function is used to release a pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>Note that this function is requires a value of type <code>Lazy a</code>, not of <code>a</code>. So you can get release function for a boxed type <code>T</code> even when you don't have a value of type <code>T</code> -- you can just use <code>|_| undefined(\"\") : T</code>:</p> <pre><code>module Main;\n\ntype VoidType = box struct {};\n// No constructor for `VoidType` is provided.\n\nmain: IO ();\nmain = (\n    let release = (|_| undefined(\"\") : VoidType).get_funptr_release; // Release function of `VoidType`.\n    pure()\n);\n</code></pre>"},{"location":"Std/#get_funptr_retain","title":"get_funptr_retain","text":"<p>Type: <code>[a : Std::Boxed] Std::Lazy a -&gt; Std::Ptr</code></p> <p>Returns a pointer to the function of type <code>void (*)(void*)</code> which retains a boxed value of type <code>a</code>. This function is used to retain a pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>For the reason that this function requires a value of type <code>Lazy a</code>, not of <code>a</code>, see the document for <code>get_funptr_release</code>.</p>"},{"location":"Std/#mutate_boxed","title":"mutate_boxed","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; (a, b)</code></p> <p><code>x.mutate_boxed(io)</code> gets a pointer <code>ptr</code> to the data that <code>x</code> points to, executes <code>io(ptr)</code>, and then returns mutated <code>x</code> paired with the result of <code>io(ptr)</code>.</p> <p>The IO action <code>io(ptr)</code> is expected to modify the value of <code>x</code> through the obtained pointer.  Do not perform any IO operations other than mutating the value of <code>x</code>.</p> <p>For more details on the value of the pointer passed to <code>io</code>, see the document of <code>_get_boxed_ptr</code>.</p> <p>This function first clones the value if <code>x</code> is not unique.</p>"},{"location":"Std/#mutate_boxed_io","title":"mutate_boxed_io","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO (a, b)</code></p> <p><code>x.mutate_boxed_io(io)</code> gets a pointer <code>ptr</code> to the data that <code>x</code> points to, executes <code>io(ptr)</code>, and then returns mutated <code>x</code> paired with the result of <code>io(ptr)</code>.</p> <p>Similar to <code>mutate_boxed</code>, but this function is used when you want to run the IO action in the existing IO context.</p> <p>For more details, see the document of <code>mutate_boxed</code>.</p>"},{"location":"Std/#mutate_boxed_ios","title":"mutate_boxed_ios","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO::IOState -&gt; (Std::IO::IOState, (a, b))</code></p> <p>Internal implementation of the <code>mutate_boxed_io</code> function.</p>"},{"location":"Std/#namespace-stdffidestructor","title":"namespace Std::FFI::Destructor","text":""},{"location":"Std/#borrow","title":"borrow","text":"<p>Type: <code>(a -&gt; b) -&gt; Std::FFI::Destructor a -&gt; b</code></p> <p>Borrow the contained value.</p> <p><code>borrow(worker, dtor)</code> calls <code>worker</code> on the contained value captured by <code>dtor</code>, and returns the value returned by <code>worker</code>.</p> <p>It is guaranteed that the <code>dtor</code> is alive during the call of <code>worker</code>. In other words, the <code>worker</code> receives the contained value for which the destructor is not called yet.</p>"},{"location":"Std/#borrow_io","title":"borrow_io","text":"<p>Type: <code>(a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; Std::IO b</code></p> <p>Performs an IO action borrowing the contained value.</p>"},{"location":"Std/#make_1","title":"make","text":"<p>Type: <code>a -&gt; (a -&gt; Std::IO a) -&gt; Std::FFI::Destructor a</code></p> <p>Make a destructor value.</p>"},{"location":"Std/#mutate_unique","title":"mutate_unique","text":"<p>Type: <code>(a -&gt; Std::IO a) -&gt; (a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; (Std::FFI::Destructor a, b)</code></p> <p>Apply an IO action which mutates the semantics of the value.</p> <p><code>dtor.mutate_unique(ctor, action)</code> applies <code>action</code> to <code>dtor</code> if <code>dtor</code> is unique. If <code>dtor</code> is shared, it creates a new <code>Destructor</code> value using <code>ctor</code> and applies <code>action</code> to the new value.</p> <p>The <code>action</code> is allowed to modify the external resource stored in <code>dtor</code> (e.g., if <code>value</code> is a pointer, it can modify the value pointed by the pointer). Also, <code>ctor</code> should be a \"copy constructor\" (e.g., memcpy) of the external resource stored in <code>dtor</code>.</p>"},{"location":"Std/#mutate_unique_io","title":"mutate_unique_io","text":"<p>Type: <code>(a -&gt; Std::IO a) -&gt; (a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; Std::IO (Std::FFI::Destructor a, b)</code></p> <p>Apply an IO action which mutates the semantics of the value.</p> <p>This is similar to <code>mutate_unique</code>, but the <code>ctor</code> and <code>action</code> is executed in the context of the external <code>IO</code> context.</p>"},{"location":"Std/#namespace-stdfrombytes","title":"namespace Std::FromBytes","text":""},{"location":"Std/#from_bytes","title":"from_bytes","text":"<p>Type: <code>[a : Std::FromBytes] Std::Array Std::U8 -&gt; Std::Result Std::ErrMsg a</code></p>"},{"location":"Std/#namespace-stdfromstring","title":"namespace Std::FromString","text":""},{"location":"Std/#from_string","title":"from_string","text":"<p>Type: <code>[a : Std::FromString] Std::String -&gt; Std::Result Std::ErrMsg a</code></p>"},{"location":"Std/#namespace-stdfunctor","title":"namespace Std::Functor","text":""},{"location":"Std/#forget","title":"forget","text":"<p>Type: <code>[f : Std::Functor] f a -&gt; f ()</code></p>"},{"location":"Std/#map","title":"map","text":"<p>Type: <code>[f : Std::Functor] (a -&gt; b) -&gt; f a -&gt; f b</code></p>"},{"location":"Std/#namespace-stdi16","title":"namespace Std::I16","text":""},{"location":"Std/#abs_2","title":"abs","text":"<p>Type: <code>Std::I16 -&gt; Std::I16</code></p>"},{"location":"Std/#bit_and","title":"bit_and","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or","title":"bit_or","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor","title":"bit_xor","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum","title":"maximum","text":"<p>Type: <code>Std::I16</code></p>"},{"location":"Std/#minimum","title":"minimum","text":"<p>Type: <code>Std::I16</code></p>"},{"location":"Std/#shift_left","title":"shift_left","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right","title":"shift_right","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_2","title":"to_CChar","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_2","title":"to_CDouble","text":"<p>Type: <code>Std::I16 -&gt; Std::F64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_2","title":"to_CFloat","text":"<p>Type: <code>Std::I16 -&gt; Std::F32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_2","title":"to_CInt","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_2","title":"to_CLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_2","title":"to_CLongLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_2","title":"to_CShort","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_2","title":"to_CSizeT","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_2","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_2","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_2","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_2","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_2","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_2","title":"to_F32","text":"<p>Type: <code>Std::I16 -&gt; Std::F32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_2","title":"to_F64","text":"<p>Type: <code>Std::I16 -&gt; Std::F64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_2","title":"to_I16","text":"<p>Type: <code>Std::I16 -&gt; Std::I16</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_2","title":"to_I32","text":"<p>Type: <code>Std::I16 -&gt; Std::I32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_2","title":"to_I64","text":"<p>Type: <code>Std::I16 -&gt; Std::I64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_2","title":"to_I8","text":"<p>Type: <code>Std::I16 -&gt; Std::I8</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_2","title":"to_U16","text":"<p>Type: <code>Std::I16 -&gt; Std::U16</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_2","title":"to_U32","text":"<p>Type: <code>Std::I16 -&gt; Std::U32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_2","title":"to_U64","text":"<p>Type: <code>Std::I16 -&gt; Std::U64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_2","title":"to_U8","text":"<p>Type: <code>Std::I16 -&gt; Std::U8</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi32","title":"namespace Std::I32","text":""},{"location":"Std/#abs_3","title":"abs","text":"<p>Type: <code>Std::I32 -&gt; Std::I32</code></p>"},{"location":"Std/#bit_and_1","title":"bit_and","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_1","title":"bit_or","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_1","title":"bit_xor","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_1","title":"maximum","text":"<p>Type: <code>Std::I32</code></p>"},{"location":"Std/#minimum_1","title":"minimum","text":"<p>Type: <code>Std::I32</code></p>"},{"location":"Std/#shift_left_1","title":"shift_left","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_1","title":"shift_right","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_3","title":"to_CChar","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_3","title":"to_CDouble","text":"<p>Type: <code>Std::I32 -&gt; Std::F64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_3","title":"to_CFloat","text":"<p>Type: <code>Std::I32 -&gt; Std::F32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_3","title":"to_CInt","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_3","title":"to_CLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_3","title":"to_CLongLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_3","title":"to_CShort","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_3","title":"to_CSizeT","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_3","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_3","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_3","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_3","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_3","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_3","title":"to_F32","text":"<p>Type: <code>Std::I32 -&gt; Std::F32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_3","title":"to_F64","text":"<p>Type: <code>Std::I32 -&gt; Std::F64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_3","title":"to_I16","text":"<p>Type: <code>Std::I32 -&gt; Std::I16</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_3","title":"to_I32","text":"<p>Type: <code>Std::I32 -&gt; Std::I32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_3","title":"to_I64","text":"<p>Type: <code>Std::I32 -&gt; Std::I64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_3","title":"to_I8","text":"<p>Type: <code>Std::I32 -&gt; Std::I8</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_3","title":"to_U16","text":"<p>Type: <code>Std::I32 -&gt; Std::U16</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_3","title":"to_U32","text":"<p>Type: <code>Std::I32 -&gt; Std::U32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_3","title":"to_U64","text":"<p>Type: <code>Std::I32 -&gt; Std::U64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_3","title":"to_U8","text":"<p>Type: <code>Std::I32 -&gt; Std::U8</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi64","title":"namespace Std::I64","text":""},{"location":"Std/#abs_4","title":"abs","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p>"},{"location":"Std/#bit_and_2","title":"bit_and","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_2","title":"bit_or","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_2","title":"bit_xor","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_2","title":"maximum","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#minimum_2","title":"minimum","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#shift_left_2","title":"shift_left","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_2","title":"shift_right","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_4","title":"to_CChar","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_4","title":"to_CDouble","text":"<p>Type: <code>Std::I64 -&gt; Std::F64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_4","title":"to_CFloat","text":"<p>Type: <code>Std::I64 -&gt; Std::F32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_4","title":"to_CInt","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_4","title":"to_CLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_4","title":"to_CLongLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_4","title":"to_CShort","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_4","title":"to_CSizeT","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_4","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_4","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_4","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_4","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_4","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_4","title":"to_F32","text":"<p>Type: <code>Std::I64 -&gt; Std::F32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_4","title":"to_F64","text":"<p>Type: <code>Std::I64 -&gt; Std::F64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_4","title":"to_I16","text":"<p>Type: <code>Std::I64 -&gt; Std::I16</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_4","title":"to_I32","text":"<p>Type: <code>Std::I64 -&gt; Std::I32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_4","title":"to_I64","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_4","title":"to_I8","text":"<p>Type: <code>Std::I64 -&gt; Std::I8</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_4","title":"to_U16","text":"<p>Type: <code>Std::I64 -&gt; Std::U16</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_4","title":"to_U32","text":"<p>Type: <code>Std::I64 -&gt; Std::U32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_4","title":"to_U64","text":"<p>Type: <code>Std::I64 -&gt; Std::U64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_4","title":"to_U8","text":"<p>Type: <code>Std::I64 -&gt; Std::U8</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi8","title":"namespace Std::I8","text":""},{"location":"Std/#abs_5","title":"abs","text":"<p>Type: <code>Std::I8 -&gt; Std::I8</code></p>"},{"location":"Std/#bit_and_3","title":"bit_and","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_3","title":"bit_or","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_3","title":"bit_xor","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_3","title":"maximum","text":"<p>Type: <code>Std::I8</code></p>"},{"location":"Std/#minimum_3","title":"minimum","text":"<p>Type: <code>Std::I8</code></p>"},{"location":"Std/#shift_left_3","title":"shift_left","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_3","title":"shift_right","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_5","title":"to_CChar","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_5","title":"to_CDouble","text":"<p>Type: <code>Std::I8 -&gt; Std::F64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_5","title":"to_CFloat","text":"<p>Type: <code>Std::I8 -&gt; Std::F32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_5","title":"to_CInt","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_5","title":"to_CLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_5","title":"to_CLongLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_5","title":"to_CShort","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_5","title":"to_CSizeT","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_5","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_5","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_5","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_5","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_5","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_5","title":"to_F32","text":"<p>Type: <code>Std::I8 -&gt; Std::F32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_5","title":"to_F64","text":"<p>Type: <code>Std::I8 -&gt; Std::F64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_5","title":"to_I16","text":"<p>Type: <code>Std::I8 -&gt; Std::I16</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_5","title":"to_I32","text":"<p>Type: <code>Std::I8 -&gt; Std::I32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_5","title":"to_I64","text":"<p>Type: <code>Std::I8 -&gt; Std::I64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_5","title":"to_I8","text":"<p>Type: <code>Std::I8 -&gt; Std::I8</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_5","title":"to_U16","text":"<p>Type: <code>Std::I8 -&gt; Std::U16</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_5","title":"to_U32","text":"<p>Type: <code>Std::I8 -&gt; Std::U32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_5","title":"to_U64","text":"<p>Type: <code>Std::I8 -&gt; Std::U64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_5","title":"to_U8","text":"<p>Type: <code>Std::I8 -&gt; Std::U8</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdio","title":"namespace Std::IO","text":""},{"location":"Std/#_read_line_inner","title":"_read_line_inner","text":"<p>Type: <code>Std::Bool -&gt; Std::IO::IOHandle -&gt; Std::IO::IOFail Std::String</code></p> <p>Reads characters from an IOHandle.</p> <p>If the first argument <code>upto_newline</code> is true, this function reads a file upto newline or EOF.</p>"},{"location":"Std/#close_file","title":"close_file","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO ()</code></p> <p>Closes a file.</p> <p>Unlike C's <code>fclose</code>, closing an already closed <code>IOHandle</code> is safe and does nothing.</p>"},{"location":"Std/#eprint","title":"eprint","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string to stderr.</p>"},{"location":"Std/#eprintln","title":"eprintln","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string followed by a newline to stderr.</p>"},{"location":"Std/#exit","title":"exit","text":"<p>Type: <code>Std::I64 -&gt; Std::IO a</code></p> <p>Exits the program with an error code.</p>"},{"location":"Std/#exit_with_msg","title":"exit_with_msg","text":"<p>Type: <code>Std::I64 -&gt; Std::String -&gt; Std::IO a</code></p> <p>Exits the program with an error message and an error code.</p> <p>The error message is written to the standard error output.</p>"},{"location":"Std/#from_runner","title":"from_runner","text":"<p>Type: <code>(Std::IO::IOState -&gt; (Std::IO::IOState, a)) -&gt; Std::IO a</code></p> <p>Creates an IO action from a IO runner function, which is a function of type <code>IOState -&gt; (IOState, a)</code>.</p>"},{"location":"Std/#get_arg","title":"get_arg","text":"<p>Type: <code>Std::I64 -&gt; Std::IO (Std::Option Std::String)</code></p> <p><code>get_arg(n)</code> returns the n-th (0-indexed) command line argument.</p> <p>If n is greater than or equal to the number of command line arguments, this function returns none.</p>"},{"location":"Std/#get_arg_count","title":"get_arg_count","text":"<p>Type: <code>Std::IO Std::I64</code></p> <p>Gets the number of command line arguments.</p>"},{"location":"Std/#get_args","title":"get_args","text":"<p>Type: <code>Std::IO (Std::Array Std::String)</code></p> <p>Gets command line arguments.</p>"},{"location":"Std/#input_line","title":"input_line","text":"<p>Type: <code>Std::IO Std::String</code></p> <p>Reads a line from stdin. If some error occurr, this function aborts the program.</p> <p>If you want to handle errors, use <code>read_line(stdin)</code> instead.</p>"},{"location":"Std/#is_eof","title":"is_eof","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO Std::Bool</code></p> <p>Checks if an <code>IOHandle</code> reached to the EOF.</p>"},{"location":"Std/#loop_lines","title":"loop_lines","text":"<p>Type: <code>Std::IO::IOHandle -&gt; s -&gt; (s -&gt; Std::String -&gt; Std::LoopState s s) -&gt; Std::IO::IOFail s</code></p> <p>Loop on lines read from an <code>IOHandle</code>.</p> <p><code>loop_lines(handle, initial_state, worker)</code> calls <code>worker</code> on the pair of current state and a line string read from <code>handle</code>. The function <code>worker</code> should return an updated state as <code>LoopState</code> value, i.e., a value created by <code>continue</code> or <code>break</code>. When the <code>handle</code> reaches to the EOF or <code>worker</code> returns a <code>break</code> value, <code>loop_lines</code> returns the last state value.</p> <p>Note that the line string passed to <code>worker</code> may contain a newline code at the end. To remove it, use <code>String::strip_last_spaces</code>.</p>"},{"location":"Std/#loop_lines_io","title":"loop_lines_io","text":"<p>Type: <code>Std::IO::IOHandle -&gt; s -&gt; (s -&gt; Std::String -&gt; Std::IO::IOFail (Std::LoopState s s)) -&gt; Std::IO::IOFail s</code></p> <p>Loop on lines read from an <code>IOHandle</code>.</p> <p>Similar to <code>loop_lines</code>, but the worker function can perform an IO action.</p>"},{"location":"Std/#open_file","title":"open_file","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; Std::IO::IOFail Std::IO::IOHandle</code></p> <p>Openes a file. The second argument is a mode string for <code>fopen</code> C function.</p>"},{"location":"Std/#print","title":"print","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string to stdout.</p>"},{"location":"Std/#println","title":"println","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string followed by a newline to stdout.</p>"},{"location":"Std/#read_bytes","title":"read_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads all bytes from an IOHandle.</p>"},{"location":"Std/#read_file_bytes","title":"read_file_bytes","text":"<p>Type: <code>Std::Path -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads all bytes from a file.</p>"},{"location":"Std/#read_file_string","title":"read_file_string","text":"<p>Type: <code>Std::Path -&gt; Std::IO::IOFail Std::String</code></p> <p>Raads all characters from a file.</p>"},{"location":"Std/#read_line","title":"read_line","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail Std::String</code></p> <p>Reads characters from a IOHandle upto newline or EOF. The returned string may include newline at its end.</p>"},{"location":"Std/#read_n_bytes","title":"read_n_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::I64 -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads at most n bytes from an IOHandle.</p>"},{"location":"Std/#read_string","title":"read_string","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail Std::String</code></p> <p>Reads all characters from an IOHandle.</p>"},{"location":"Std/#stderr","title":"stderr","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard error.</p>"},{"location":"Std/#stdin","title":"stdin","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard input.</p>"},{"location":"Std/#stdout","title":"stdout","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard output.</p>"},{"location":"Std/#unsafe_perform","title":"unsafe_perform","text":"<p>Type: <code>Std::IO a -&gt; a</code></p>"},{"location":"Std/#with_file","title":"with_file","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; (Std::IO::IOHandle -&gt; Std::IO::IOFail a) -&gt; Std::IO::IOFail a</code></p> <p>Performs a function with a file handle. The second argument is a mode string for <code>fopen</code> C function.</p> <p>The file handle will be closed automatically.</p>"},{"location":"Std/#write_bytes","title":"write_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::Array Std::U8 -&gt; Std::IO::IOFail ()</code></p> <p>Writes a byte array into an IOHandle.</p>"},{"location":"Std/#write_file_bytes","title":"write_file_bytes","text":"<p>Type: <code>Std::Path -&gt; Std::Array Std::U8 -&gt; Std::IO::IOFail ()</code></p> <p>Writes a byte array into a file.</p>"},{"location":"Std/#write_file_string","title":"write_file_string","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p> <p>Writes a string into a file.</p>"},{"location":"Std/#write_string","title":"write_string","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p> <p>Writes a string into an IOHandle.</p>"},{"location":"Std/#namespace-stdioiofail","title":"namespace Std::IO::IOFail","text":""},{"location":"Std/#from_io_result","title":"from_io_result","text":"<p>Type: <code>Std::IO (Std::Result Std::ErrMsg a) -&gt; Std::IO::IOFail a</code></p> <p>Create from IO action of which returns <code>Result ErrMsg a</code>.</p>"},{"location":"Std/#from_result","title":"from_result","text":"<p>Type: <code>Std::Result Std::ErrMsg a -&gt; Std::IO::IOFail a</code></p> <p>Creates an pure <code>IOFail</code> value from a <code>Result</code> value.</p>"},{"location":"Std/#lift","title":"lift","text":"<p>Type: <code>Std::IO a -&gt; Std::IO::IOFail a</code></p> <p>Lifts an <code>IO</code> action to a successful <code>IOFail</code> action.</p>"},{"location":"Std/#throw","title":"throw","text":"<p>Type: <code>Std::ErrMsg -&gt; Std::IO::IOFail a</code></p> <p>Creates an error <code>IOFail</code> action.</p>"},{"location":"Std/#to_result","title":"to_result","text":"<p>Type: <code>Std::IO::IOFail a -&gt; Std::IO (Std::Result Std::ErrMsg a)</code></p> <p>Converts an <code>IOFail</code> to an <code>Result</code> value (wrapped by <code>IO</code>).</p>"},{"location":"Std/#try","title":"try","text":"<p>Type: <code>(Std::ErrMsg -&gt; Std::IO a) -&gt; Std::IO::IOFail a -&gt; Std::IO a</code></p> <p>Converts an <code>IOFail</code> value to an <code>IO</code> value by an error handler (i.e., a <code>catch</code>) function.</p>"},{"location":"Std/#namespace-stdioiohandle","title":"namespace Std::IO::IOHandle","text":""},{"location":"Std/#_file_ptr","title":"_file_ptr","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::Ptr</code></p> <p>Gets pointer to C's <code>FILE</code> value from an <code>IOHandle</code>.</p> <p>If the <code>IOHandle</code> is already closed, the function returns <code>nullptr</code>.</p> <p>NOTE: Do not directly close the file pointer by <code>fclose</code> or other functions. Instead you should close <code>IOHandle</code> by <code>IO::close_file</code>.</p> <p>DEPRECATED: Use <code>get_file_ptr</code> instead. This function is deprecated because it has a pure function interface, but the value of <code>_file_ptr</code> changes by calling <code>IO::close_file</code>.</p>"},{"location":"Std/#from_file_ptr","title":"from_file_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::IO::IOHandle</code></p> <p>Creates an <code>IOHandle</code> from a file pointer (i.e., pointer to C's <code>FILE</code>).</p> <p>Creating two <code>IOHandle</code>s from a single file pointer is forbidden.</p>"},{"location":"Std/#get_file_ptr","title":"get_file_ptr","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO Std::Ptr</code></p> <p>Gets pointer to C's <code>FILE</code> value from an <code>IOHandle</code>.</p> <p>If the <code>IOHandle</code> is already closed, the function returns <code>nullptr</code>.</p> <p>NOTE: Do not directly close the file pointer by <code>fclose</code> or other functions. Instead you should close <code>IOHandle</code> by <code>IO::close_file</code>.</p> <p>NOTE: If <code>IO::close</code> is called while using the <code>Ptr</code> obtained by this function, the <code>Ptr</code> becomes invalid and may cause undefined behavior.</p>"},{"location":"Std/#namespace-stditerator","title":"namespace Std::Iterator","text":""},{"location":"Std/#advance","title":"advance","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option (iter, Std::Iterator::Item iter)</code></p>"},{"location":"Std/#append_1","title":"append","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = a] i2 -&gt; i1 -&gt; Std::Iterator::AppendIterator i1 i2</code></p> <p>Append two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.append(iter2)</code> appends <code>iter2</code> after <code>iter1</code>, <code>append(iter1, iter2)</code> appends iterators in the opposite order.</p>"},{"location":"Std/#bang","title":"bang","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Convert any iterator to an array iterator.</p> <p>All elements of the input iterator are collected into an array. Therefore, this function may consume a lot of memory. On the other hand, iteration may be faster by banging.</p>"},{"location":"Std/#collect_m","title":"collect_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = m a] iter -&gt; m (Std::Array a)</code></p> <p>Executes monadic actions and collects the results into an array.</p>"},{"location":"Std/#count_up","title":"count_up","text":"<p>Type: <code>Std::I64 -&gt; Std::Iterator::CountUpIterator</code></p> <p>Create an iterator that counts up from a number.</p> <p><code>count_up(start)</code> generates an infinite sequence of numbers starting from <code>start</code>.</p>"},{"location":"Std/#empty_1","title":"empty","text":"<p>Type: <code>Std::Iterator::EmptyIterator a</code></p> <p>An iterator that yields no elements.</p> <p>NOTE: When using this iterator, you may need to specify the type of the iterator explicitly, e.g, <code>(empty : EmptyIterator I64)</code>.</p>"},{"location":"Std/#filter","title":"filter","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Bool) -&gt; i -&gt; Std::Iterator::FilterIterator i a</code></p> <p>Filter the elements of an iterator by a predicate.</p> <p><code>iter.filter(pred)</code> returns an iterator that only yields elements of <code>iter</code> for which <code>pred</code> returns <code>true</code>.</p>"},{"location":"Std/#filter_map","title":"filter_map","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Option b) -&gt; i -&gt; Std::Iterator::FilterMapIterator i a b</code></p> <p>Filter and map the elements of an iterator.</p> <p><code>iter.filter_map(f)</code> returns an iterator that applies <code>f</code> to each element of <code>iter</code> and yields the result if it is <code>some</code>.</p>"},{"location":"Std/#flat_map","title":"flat_map","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = b] (a -&gt; i2) -&gt; i1 -&gt; Std::Iterator::FlatMapIterator i1 a i2</code></p>"},{"location":"Std/#flatten","title":"flatten","text":"<p>Type: <code>[i2 : Std::Iterator, i1 : Std::Iterator, Std::Iterator::Item i2 = i1] i2 -&gt; Std::Iterator::FlattenIterator i2 i1</code></p> <p>Flatten an iterator of iterators.</p>"},{"location":"Std/#fold","title":"fold","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; s) -&gt; iter -&gt; s</code></p> <p>Fold the elements of an iterator from left to right.</p> <p>Conceptually, <code>[a0, a1, a2, ...].to_iter.fold(s, op) = s.op(a0).op(a1).op(a2)...</code>.</p>"},{"location":"Std/#fold_m","title":"fold_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; m s) -&gt; iter -&gt; m s</code></p> <p>Fold the elements of an iterator from left to right by monadic action.</p>"},{"location":"Std/#from_array","title":"from_array","text":"<p>Type: <code>Std::Array a -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Create an iterator from an array.</p>"},{"location":"Std/#from_map_1","title":"from_map","text":"<p>Type: <code>(Std::I64 -&gt; a) -&gt; Std::Iterator::MapIterator Std::Iterator::CountUpIterator Std::I64 a</code></p> <p>Create an iterator by a function that returns element at each index.</p>"},{"location":"Std/#generate","title":"generate","text":"<p>Type: <code>s -&gt; (s -&gt; Std::Option (s, a)) -&gt; Std::Iterator::StateIterator s a</code></p> <p>Create an iterator that generates elements by the state transition function.</p>"},{"location":"Std/#get_first_1","title":"get_first","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option (Std::Iterator::Item iter)</code></p> <p>Get the first element of an iterator.</p> <p>If the iterator is empty, this function returns <code>none</code>.</p>"},{"location":"Std/#get_size_1","title":"get_size","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::I64</code></p> <p>Get the number of elements in an iterator.</p>"},{"location":"Std/#get_tail","title":"get_tail","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option iter</code></p> <p>Get the tail of an iterator.</p> <p>If the iterator is empty, this function returns <code>none</code>.</p>"},{"location":"Std/#intersperse","title":"intersperse","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] a -&gt; i -&gt; Std::Iterator::IntersperseIterator i a</code></p> <p>Intersperse an element between elements of an iterator.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", [1, 2, 3].from_array.intersperse(0).to_array, [1, 0, 2, 0, 3]);;\n</code></pre>"},{"location":"Std/#is_empty_1","title":"is_empty","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Bool</code></p> <p>Is an iterator empty?</p>"},{"location":"Std/#is_equal","title":"is_equal","text":"<p>Type: <code>[iter1 : Std::Iterator, iter2 : Std::Iterator, a : Std::Eq, Std::Iterator::Item iter1 = a, Std::Iterator::Item iter2 = a] iter1 -&gt; iter2 -&gt; Std::Bool</code></p> <p>Compare two iterators by their elements.</p>"},{"location":"Std/#loop_iter","title":"loop_iter","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; Std::LoopState s s) -&gt; iter -&gt; s</code></p> <p>Loop over the elements of an iterator.</p> <p>This function is similar to <code>fold</code> but a more general version of it. It allows the user to break out of the loop at any point.</p>"},{"location":"Std/#loop_iter_m","title":"loop_iter_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; m (Std::LoopState s s)) -&gt; iter -&gt; m s</code></p> <p>Loop over the elements of an iterator by monadic action.</p>"},{"location":"Std/#map_1","title":"map","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; b) -&gt; i -&gt; Std::Iterator::MapIterator i a b</code></p> <p>Map a function over an iterator.</p> <p><code>iter.map(f)</code> returns an iterator that applies <code>f</code> to each element of <code>iter</code>.</p>"},{"location":"Std/#pop_first","title":"pop_first","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; iter</code></p> <p>Remove the first element of an iterator.</p> <p>If the iterator is empty, this function does nothing.</p>"},{"location":"Std/#product","title":"product","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = b] i2 -&gt; i1 -&gt; Std::Iterator::ProductIterator i1 i2 a b</code></p> <p>Create an iterator that yields the Cartesian product of two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.product(iter2)</code> yields the Cartesian product, the elements of <code>product(iter2, iter1)</code> are in the opposite order.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", range(1, 4).product(['a', 'b'].from_array).to_array, [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]);;\n</code></pre>"},{"location":"Std/#push_front","title":"push_front","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] a -&gt; i -&gt; Std::Iterator::ConsIterator i a</code></p> <p>Push an element to an iterator.</p>"},{"location":"Std/#range","title":"range","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::RangeIterator</code></p> <p>Create an iterator that generates a range of numbers.</p> <p><code>range(a, b)</code> generates a range of numbers from <code>a</code> to <code>b - 1</code>.</p> <p>If <code>a</code> is greater than or equal to <code>b</code>, the iterator will an infinite sequence of <code>a</code>.</p>"},{"location":"Std/#range_step","title":"range_step","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::RangeStepIterator</code></p> <p>Create an iterator that generates a range of numbers with a step.</p>"},{"location":"Std/#reverse","title":"reverse","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] i -&gt; Std::Iterator::ReverseIterator i a</code></p> <p>Reverses an iterator.</p> <p>NOTE: This function puts all elements of the iterator into an array, so it may consume a lot of memory.</p>"},{"location":"Std/#sum","title":"sum","text":"<p>Type: <code>[iter : Std::Iterator, a : Std::Additive, Std::Iterator::Item iter = a] iter -&gt; a</code></p> <p>Calcculate sum of the elements of an iterator.</p>"},{"location":"Std/#take","title":"take","text":"<p>Type: <code>[i : Std::Iterator] Std::I64 -&gt; i -&gt; Std::Iterator::TakeIterator i</code></p> <p>Take the first <code>n</code> elements of an iterator.</p>"},{"location":"Std/#take_while","title":"take_while","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Bool) -&gt; i -&gt; Std::Iterator::TakeWhileIterator i a</code></p> <p>Take elements from an iterator while a predicate holds.</p>"},{"location":"Std/#to_array","title":"to_array","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Array a</code></p> <p>Convert an iterator to an array.</p>"},{"location":"Std/#to_dyn","title":"to_dyn","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Iterator::DynIterator a</code></p> <p>Convert an iterator into a dynamic iterator.</p>"},{"location":"Std/#zip","title":"zip","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator] i2 -&gt; i1 -&gt; Std::Iterator::ZipIterator i1 i2</code></p> <p>Zip two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.zip(iter2)</code> zips <code>iter1</code> and <code>iter2</code>, the elements of <code>zip(iter2, iter1)</code> are in the opposite order.</p>"},{"location":"Std/#namespace-stditeratordyniterator","title":"namespace Std::Iterator::DynIterator","text":""},{"location":"Std/#empty_2","title":"empty","text":"<p>Type: <code>Std::Iterator::DynIterator a</code></p> <p>Creates an empty dynamic iterator.</p>"},{"location":"Std/#namespace-stdlessthan","title":"namespace Std::LessThan","text":""},{"location":"Std/#less_than","title":"less_than","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt; y</code> is translated to <code>less_than(x, y)</code>.</p>"},{"location":"Std/#max","title":"max","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; a</code></p>"},{"location":"Std/#min","title":"min","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; a</code></p>"},{"location":"Std/#namespace-stdlessthanoreq","title":"namespace Std::LessThanOrEq","text":""},{"location":"Std/#less_than_or_eq","title":"less_than_or_eq","text":"<p>Type: <code>[a : Std::LessThanOrEq] a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt;= y</code> is translated to <code>less_than_or_eq(x, y)</code>.</p>"},{"location":"Std/#namespace-stdloopstate","title":"namespace Std::LoopState","text":""},{"location":"Std/#break_m","title":"break_m","text":"<p>Type: <code>[m : Std::Monad] r -&gt; m (Std::LoopState s r)</code></p> <p>Make a break value wrapped in a monad.</p> <p>This is used with <code>loop_m</code> function.</p>"},{"location":"Std/#continue_m","title":"continue_m","text":"<p>Type: <code>[m : Std::Monad] s -&gt; m (Std::LoopState s r)</code></p> <p>Make a continue value wrapped in a monad.</p> <p>This is used with <code>loop_m</code> function.</p>"},{"location":"Std/#namespace-stdmonad","title":"namespace Std::Monad","text":""},{"location":"Std/#bind","title":"bind","text":"<p>Type: <code>[m : Std::Monad] (a -&gt; m b) -&gt; m a -&gt; m b</code></p>"},{"location":"Std/#flatten_1","title":"flatten","text":"<p>Type: <code>[m : Std::Monad] m (m a) -&gt; m a</code></p> <p>Flattens a nested monadic action.</p>"},{"location":"Std/#pure","title":"pure","text":"<p>Type: <code>[m : Std::Monad] a -&gt; m a</code></p>"},{"location":"Std/#unless","title":"unless","text":"<p>Type: <code>[m : Std::Monad] Std::Bool -&gt; m () -&gt; m ()</code></p> <p><code>unless(cond, act)</code> where <code>act</code> is a monadic value which returns <code>()</code> perfoms <code>act</code> only when <code>cond</code> is false.</p>"},{"location":"Std/#when","title":"when","text":"<p>Type: <code>[m : Std::Monad] Std::Bool -&gt; m () -&gt; m ()</code></p> <p><code>when(cond, act)</code> where <code>act</code> is a monadic value which returns <code>()</code> perfoms <code>act</code> only when <code>cond</code> is true.</p>"},{"location":"Std/#namespace-stdmul","title":"namespace Std::Mul","text":""},{"location":"Std/#mul","title":"mul","text":"<p>Type: <code>[a : Std::Mul] a -&gt; a -&gt; a</code></p> <p>Multiplies a value by another value. An expression <code>x * y</code> is translated to <code>mul(x, y)</code>.</p>"},{"location":"Std/#namespace-stdneg","title":"namespace Std::Neg","text":""},{"location":"Std/#neg","title":"neg","text":"<p>Type: <code>[a : Std::Neg] a -&gt; a</code></p> <p>Negates a value. An expression <code>-x</code> is translated to <code>neg(x)</code>.</p>"},{"location":"Std/#namespace-stdnot","title":"namespace Std::Not","text":""},{"location":"Std/#not","title":"not","text":"<p>Type: <code>[a : Std::Not] a -&gt; a</code></p> <p>Logical NOT of a value. An expression <code>!x</code> is translated to <code>not(x)</code>.</p>"},{"location":"Std/#namespace-stdoption","title":"namespace Std::Option","text":""},{"location":"Std/#as_some_or","title":"as_some_or","text":"<p>Type: <code>a -&gt; Std::Option a -&gt; a</code></p> <p>Unwrap an option value if it is <code>some</code>, or returns given default value if it is <code>none</code>.</p>"},{"location":"Std/#map_or","title":"map_or","text":"<p>Type: <code>b -&gt; (a -&gt; b) -&gt; Std::Option a -&gt; b</code></p> <p>Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.</p>"},{"location":"Std/#to_iter_1","title":"to_iter","text":"<p>Type: <code>Std::Option a -&gt; Std::Option::OptionIterator (Std::Option a)</code></p> <p>Converts an option into an iterator.</p>"},{"location":"Std/#namespace-stdptr","title":"namespace Std::Ptr","text":""},{"location":"Std/#add_offset","title":"add_offset","text":"<p>Type: <code>Std::I64 -&gt; Std::Ptr -&gt; Std::Ptr</code></p> <p>Adds an offset to a pointer.</p>"},{"location":"Std/#subtract_ptr","title":"subtract_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::Ptr -&gt; Std::I64</code></p> <p>Subtracts two pointers.</p> <p>Note that <code>x.subtract_ptr(y)</code> calculates <code>x - y</code>, so <code>subtract_ptr(x, y)</code> calculates <code>y - x</code>.</p>"},{"location":"Std/#namespace-stdpunchedarray","title":"namespace Std::PunchedArray","text":""},{"location":"Std/#plug_in","title":"plug_in","text":"<p>Type: <code>a -&gt; Std::PunchedArray a -&gt; Std::Array a</code></p> <p>Plug in an element to a punched array to get back an array.</p>"},{"location":"Std/#unsafe_punch","title":"unsafe_punch","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; (Std::PunchedArray a, a)</code></p> <p>Creates a punched array by moving out the element at the specified index.</p> <p>NOTE: this function assumes that the given array is unique WITHOUT CHECKING. The uniqueness of the array is ensured in the <code>Array::act</code> function.</p>"},{"location":"Std/#namespace-stdrem","title":"namespace Std::Rem","text":""},{"location":"Std/#rem","title":"rem","text":"<p>Type: <code>[a : Std::Rem] a -&gt; a -&gt; a</code></p> <p>Calculate remainder of a value dividing another value. An expression <code>x % y</code> is translated to <code>rem(x, y)</code>.</p>"},{"location":"Std/#namespace-stdresult","title":"namespace Std::Result","text":""},{"location":"Std/#unwrap","title":"unwrap","text":"<p>Type: <code>Std::Result e o -&gt; o</code></p> <p>Returns the containing value if the value is ok, or otherwise aborts the program.</p>"},{"location":"Std/#namespace-stdstring","title":"namespace Std::String","text":""},{"location":"Std/#_get_c_str","title":"_get_c_str","text":"<p>Type: <code>Std::String -&gt; Std::Ptr</code></p> <p>Get the null-terminated C string.</p> <p>Note that in case the string is not used after call of this function, the returned pointer will be already released.</p>"},{"location":"Std/#_unsafe_from_c_str","title":"_unsafe_from_c_str","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::String</code></p> <p>Create a string from C string (i.e., null-terminated byte array).</p> <p>If the byte array doesn't include <code>\\0</code>, this function causes undefined behavior.</p>"},{"location":"Std/#_unsafe_from_c_str_ptr","title":"_unsafe_from_c_str_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::String</code></p> <p>Create a <code>String</code> from a pointer to null-terminated C string.</p> <p>If <code>ptr</code> is not pointing to a valid null-terminated C string, this function cause undefined behavior.</p>"},{"location":"Std/#borrow_c_str","title":"borrow_c_str","text":"<p>Type: <code>(Std::Ptr -&gt; a) -&gt; Std::String -&gt; a</code></p> <p>Call a function with a null-terminated C string.</p>"},{"location":"Std/#borrow_c_str_io","title":"borrow_c_str_io","text":"<p>Type: <code>(Std::Ptr -&gt; Std::IO a) -&gt; Std::String -&gt; Std::IO a</code></p> <p>Call an IO action with a null-terminated C string.</p>"},{"location":"Std/#concat","title":"concat","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String</code></p> <p>Concatenate two strings.</p> <p>Note: Since <code>s1.concat(s2)</code> puts <code>s2</code> after <code>s1</code>, <code>concat(lhs, rhs)</code> puts <code>lhs</code> after <code>rhs</code>.</p>"},{"location":"Std/#concat_iter","title":"concat_iter","text":"<p>Type: <code>[strs : Std::Iterator, Std::Iterator::Item strs = Std::String] strs -&gt; Std::String</code></p> <p>Concatenate an iterator of strings.</p>"},{"location":"Std/#empty_3","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Std::String</code></p> <p>Create an empty string, which is reserved for a length.</p>"},{"location":"Std/#find","title":"find","text":"<p>Type: <code>Std::String -&gt; Std::I64 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p><code>str.find(token, start_idx)</code> finds the index where <code>token</code> firstly appears in <code>str</code>, starting from <code>start_idx</code>.</p> <p>Note that this function basically returns a number less than or equal to <code>start_idx</code>, but there is an exception: <code>str.find(\"\", start_idx)</code> with <code>start_idx &gt;= str.get_size</code> returns <code>str.get_size</code>, not <code>start_idx</code>.</p>"},{"location":"Std/#from_u8","title":"from_U8","text":"<p>Type: <code>Std::U8 -&gt; Std::String</code></p> <p>Creates a string from a byte.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", String::from_U8('a'), \"a\");;\nassert_eq(|_|\"\", String::from_U8('\\x00'), \"\");;\n</code></pre>"},{"location":"Std/#get_bytes","title":"get_bytes","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::U8</code></p> <p>Gets the byte array of a string, containing null-terminator.</p>"},{"location":"Std/#get_first_byte","title":"get_first_byte","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U8</code></p> <p>Gets the first byte of a string. Returns none if the string is empty.</p>"},{"location":"Std/#get_last_byte","title":"get_last_byte","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U8</code></p> <p>Gets the last byte of a string. Returns none if the string is empty.</p>"},{"location":"Std/#get_size_2","title":"get_size","text":"<p>Type: <code>Std::String -&gt; Std::I64</code></p> <p>Gets the length of a string.</p>"},{"location":"Std/#get_sub_1","title":"get_sub","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::String -&gt; Std::String</code></p> <p><code>String</code> version of <code>Array::get_sub</code>.</p>"},{"location":"Std/#is_empty_2","title":"is_empty","text":"<p>Type: <code>Std::String -&gt; Std::Bool</code></p> <p>Returns if the string is empty or not.</p>"},{"location":"Std/#join","title":"join","text":"<p>Type: <code>[ss : Std::Iterator, Std::Iterator::Item ss = Std::String] Std::String -&gt; ss -&gt; Std::String</code></p> <p>Joins (an iterator of) strings by a separator.</p>"},{"location":"Std/#pop_back_byte","title":"pop_back_byte","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes the last byte.</p> <p>If the string is empty, this function does nothing.</p>"},{"location":"Std/#split","title":"split","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String::StringSplitIterator</code></p> <p><code>str.split(sep)</code> splits <code>str</code> by <code>sep</code> into an iterator.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"Ex. 1\", \"ab,c,\".split(\",\").to_array, [\"ab\", \"c\", \"\"]);;\nassert_eq(|_|\"Ex. 2\", \"abc\".split(\",\").to_array, [\"abc\"]);;\nassert_eq(|_|\"Ex. 3\", \"abc\".split(\"\").to_array, [\"a\", \"b\", \"c\"]);; // Special behavior when the separator is empty.\n</code></pre>"},{"location":"Std/#strip_first_bytes","title":"strip_first_bytes","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; Std::String</code></p> <p>Removes the first byte of a string while it satisifies the specified condition.</p>"},{"location":"Std/#strip_first_spaces","title":"strip_first_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes leading whitespace characters.</p>"},{"location":"Std/#strip_last_bytes","title":"strip_last_bytes","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; Std::String</code></p> <p>Removes the last byte of a string while it satisifies the specified condition.</p>"},{"location":"Std/#strip_last_newlines","title":"strip_last_newlines","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes newlines and carriage returns at the end of the string.</p>"},{"location":"Std/#strip_last_spaces","title":"strip_last_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes trailing whitespace characters.</p>"},{"location":"Std/#strip_spaces","title":"strip_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Strips leading and trailing whitespace characters.</p>"},{"location":"Std/#namespace-stdsub","title":"namespace Std::Sub","text":""},{"location":"Std/#sub","title":"sub","text":"<p>Type: <code>[a : Std::Sub] a -&gt; a -&gt; a</code></p> <p>Subtracts a value from another value. An expression <code>x - y</code> is translated to <code>sub(x, y)</code>.</p>"},{"location":"Std/#namespace-stdtobytes","title":"namespace Std::ToBytes","text":""},{"location":"Std/#to_bytes","title":"to_bytes","text":"<p>Type: <code>[a : Std::ToBytes] a -&gt; Std::Array Std::U8</code></p>"},{"location":"Std/#namespace-stdtostring","title":"namespace Std::ToString","text":""},{"location":"Std/#to_string","title":"to_string","text":"<p>Type: <code>[a : Std::ToString] a -&gt; Std::String</code></p>"},{"location":"Std/#namespace-stdu16","title":"namespace Std::U16","text":""},{"location":"Std/#bit_and_4","title":"bit_and","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_4","title":"bit_or","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_4","title":"bit_xor","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_4","title":"maximum","text":"<p>Type: <code>Std::U16</code></p>"},{"location":"Std/#minimum_4","title":"minimum","text":"<p>Type: <code>Std::U16</code></p>"},{"location":"Std/#shift_left_4","title":"shift_left","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_4","title":"shift_right","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_6","title":"to_CChar","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_6","title":"to_CDouble","text":"<p>Type: <code>Std::U16 -&gt; Std::F64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_6","title":"to_CFloat","text":"<p>Type: <code>Std::U16 -&gt; Std::F32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_6","title":"to_CInt","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_6","title":"to_CLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_6","title":"to_CLongLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_6","title":"to_CShort","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_6","title":"to_CSizeT","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_6","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_6","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_6","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_6","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_6","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_6","title":"to_F32","text":"<p>Type: <code>Std::U16 -&gt; Std::F32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_6","title":"to_F64","text":"<p>Type: <code>Std::U16 -&gt; Std::F64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_6","title":"to_I16","text":"<p>Type: <code>Std::U16 -&gt; Std::I16</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_6","title":"to_I32","text":"<p>Type: <code>Std::U16 -&gt; Std::I32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_6","title":"to_I64","text":"<p>Type: <code>Std::U16 -&gt; Std::I64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_6","title":"to_I8","text":"<p>Type: <code>Std::U16 -&gt; Std::I8</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_6","title":"to_U16","text":"<p>Type: <code>Std::U16 -&gt; Std::U16</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_6","title":"to_U32","text":"<p>Type: <code>Std::U16 -&gt; Std::U32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_6","title":"to_U64","text":"<p>Type: <code>Std::U16 -&gt; Std::U64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_6","title":"to_U8","text":"<p>Type: <code>Std::U16 -&gt; Std::U8</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu32","title":"namespace Std::U32","text":""},{"location":"Std/#bit_and_5","title":"bit_and","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_5","title":"bit_or","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_5","title":"bit_xor","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_5","title":"maximum","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Std/#minimum_5","title":"minimum","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Std/#shift_left_5","title":"shift_left","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_5","title":"shift_right","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_7","title":"to_CChar","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_7","title":"to_CDouble","text":"<p>Type: <code>Std::U32 -&gt; Std::F64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_7","title":"to_CFloat","text":"<p>Type: <code>Std::U32 -&gt; Std::F32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_7","title":"to_CInt","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_7","title":"to_CLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_7","title":"to_CLongLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_7","title":"to_CShort","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_7","title":"to_CSizeT","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_7","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_7","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_7","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_7","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_7","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_7","title":"to_F32","text":"<p>Type: <code>Std::U32 -&gt; Std::F32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_7","title":"to_F64","text":"<p>Type: <code>Std::U32 -&gt; Std::F64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_7","title":"to_I16","text":"<p>Type: <code>Std::U32 -&gt; Std::I16</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_7","title":"to_I32","text":"<p>Type: <code>Std::U32 -&gt; Std::I32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_7","title":"to_I64","text":"<p>Type: <code>Std::U32 -&gt; Std::I64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_7","title":"to_I8","text":"<p>Type: <code>Std::U32 -&gt; Std::I8</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_7","title":"to_U16","text":"<p>Type: <code>Std::U32 -&gt; Std::U16</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_7","title":"to_U32","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_7","title":"to_U64","text":"<p>Type: <code>Std::U32 -&gt; Std::U64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_7","title":"to_U8","text":"<p>Type: <code>Std::U32 -&gt; Std::U8</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu64","title":"namespace Std::U64","text":""},{"location":"Std/#bit_and_6","title":"bit_and","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_6","title":"bit_or","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_6","title":"bit_xor","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_6","title":"maximum","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Std/#minimum_6","title":"minimum","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Std/#shift_left_6","title":"shift_left","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_6","title":"shift_right","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_8","title":"to_CChar","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_8","title":"to_CDouble","text":"<p>Type: <code>Std::U64 -&gt; Std::F64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_8","title":"to_CFloat","text":"<p>Type: <code>Std::U64 -&gt; Std::F32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_8","title":"to_CInt","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_8","title":"to_CLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_8","title":"to_CLongLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_8","title":"to_CShort","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_8","title":"to_CSizeT","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_8","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_8","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_8","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_8","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_8","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_8","title":"to_F32","text":"<p>Type: <code>Std::U64 -&gt; Std::F32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_8","title":"to_F64","text":"<p>Type: <code>Std::U64 -&gt; Std::F64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_8","title":"to_I16","text":"<p>Type: <code>Std::U64 -&gt; Std::I16</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_8","title":"to_I32","text":"<p>Type: <code>Std::U64 -&gt; Std::I32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_8","title":"to_I64","text":"<p>Type: <code>Std::U64 -&gt; Std::I64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_8","title":"to_I8","text":"<p>Type: <code>Std::U64 -&gt; Std::I8</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_8","title":"to_U16","text":"<p>Type: <code>Std::U64 -&gt; Std::U16</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_8","title":"to_U32","text":"<p>Type: <code>Std::U64 -&gt; Std::U32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_8","title":"to_U64","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_8","title":"to_U8","text":"<p>Type: <code>Std::U64 -&gt; Std::U8</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu8","title":"namespace Std::U8","text":""},{"location":"Std/#bit_and_7","title":"bit_and","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#bit_or_7","title":"bit_or","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#bit_xor_7","title":"bit_xor","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#maximum_7","title":"maximum","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Std/#minimum_7","title":"minimum","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Std/#shift_left_7","title":"shift_left","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p><code>v.shift_left(w)</code> shifts <code>v</code> to left by <code>w</code> bits.</p>"},{"location":"Std/#shift_right_7","title":"shift_right","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p><code>v.shift_right(w)</code> shifts <code>v</code> to right by <code>w</code> bits.</p>"},{"location":"Std/#to_cchar_9","title":"to_CChar","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_9","title":"to_CDouble","text":"<p>Type: <code>Std::U8 -&gt; Std::F64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_9","title":"to_CFloat","text":"<p>Type: <code>Std::U8 -&gt; Std::F32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_9","title":"to_CInt","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_9","title":"to_CLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_9","title":"to_CLongLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_9","title":"to_CShort","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_9","title":"to_CSizeT","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_9","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_9","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_9","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_9","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_9","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_9","title":"to_F32","text":"<p>Type: <code>Std::U8 -&gt; Std::F32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_9","title":"to_F64","text":"<p>Type: <code>Std::U8 -&gt; Std::F64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_9","title":"to_I16","text":"<p>Type: <code>Std::U8 -&gt; Std::I16</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_9","title":"to_I32","text":"<p>Type: <code>Std::U8 -&gt; Std::I32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_9","title":"to_I64","text":"<p>Type: <code>Std::U8 -&gt; Std::I64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_9","title":"to_I8","text":"<p>Type: <code>Std::U8 -&gt; Std::I8</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_9","title":"to_U16","text":"<p>Type: <code>Std::U8 -&gt; Std::U16</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_9","title":"to_U32","text":"<p>Type: <code>Std::U8 -&gt; Std::U32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_9","title":"to_U64","text":"<p>Type: <code>Std::U8 -&gt; Std::U64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_9","title":"to_U8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdzero","title":"namespace Std::Zero","text":""},{"location":"Std/#zero","title":"zero","text":"<p>Type: <code>[a : Std::Zero] a</code></p>"},{"location":"Std/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Std/#namespace-std_1","title":"namespace Std","text":""},{"location":"Std/#array","title":"Array","text":"<p>Defined as: <code>type Array a = box { built-in }</code></p> <p>The type of variable length arrays. This is a boxed type.</p>"},{"location":"Std/#arrow","title":"Arrow","text":"<p>Defined as: <code>type Arrow a b = unbox { built-in }</code></p> <p><code>Arrow a b</code> represents the type of a function that takes a value of type <code>a</code> and returns a value of type <code>b</code>. Usually written as <code>a -&gt; b</code>.</p>"},{"location":"Std/#bool","title":"Bool","text":"<p>Defined as: <code>type Bool = unbox { built-in }</code></p> <p>The type of boolean values.</p>"},{"location":"Std/#box","title":"Box","text":"<p>Defined as: <code>type Box a = box struct { ...fields... }</code></p> <p>Boxed wrapper for a type.</p>"},{"location":"Std/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#errmsg","title":"ErrMsg","text":"<p>Defined as: <code>type ErrMsg = Std::String</code></p> <p>A type (alias) for error message.</p>"},{"location":"Std/#f32","title":"F32","text":"<p>Defined as: <code>type F32 = unbox { built-in }</code></p> <p>The type of 32-bit floating point values.</p>"},{"location":"Std/#f64","title":"F64","text":"<p>Defined as: <code>type F64 = unbox { built-in }</code></p> <p>The type of 64-bit floating point values.</p>"},{"location":"Std/#i16","title":"I16","text":"<p>Defined as: <code>type I16 = unbox { built-in }</code></p> <p>The type of 16-bit signed integers.</p>"},{"location":"Std/#i32","title":"I32","text":"<p>Defined as: <code>type I32 = unbox { built-in }</code></p> <p>The type of 32-bit signed integers.</p>"},{"location":"Std/#i64","title":"I64","text":"<p>Defined as: <code>type I64 = unbox { built-in }</code></p> <p>The type of 64-bit signed integers.</p>"},{"location":"Std/#i8","title":"I8","text":"<p>Defined as: <code>type I8 = unbox { built-in }</code></p> <p>The type of 8-bit signed integers.</p>"},{"location":"Std/#io","title":"IO","text":"<p>Defined as: <code>type IO a = unbox struct { ...fields... }</code></p> <p><code>IO a</code> is a type representing I/O actions which return values of type <code>a</code>.</p>"},{"location":"Std/#field-runner","title":"field <code>runner</code>","text":"<p>Type: <code>Std::IO::IOState -&gt; (Std::IO::IOState, a)</code></p>"},{"location":"Std/#lazy","title":"Lazy","text":"<p>Defined as: <code>type Lazy a = () -&gt; a</code></p> <p>The type of lazily generated values.</p> <p>You can create a lazy value by <code>|_| (...an expression to generate the value...)</code>, and you can evaluate a lazy value <code>v</code> by <code>v()</code>.</p>"},{"location":"Std/#loopstate","title":"LoopState","text":"<p>Defined as: <code>type LoopState s r = unbox union { ...variants... }</code></p> <p>A union type with variants <code>continue</code> and <code>break</code>.</p> <p>This type is used to represent the result of a loop body function passed to <code>Std::loop</code> or other similar functions.</p>"},{"location":"Std/#variant-continue","title":"variant <code>continue</code>","text":"<p>Type: <code>s</code></p>"},{"location":"Std/#variant-break","title":"variant <code>break</code>","text":"<p>Type: <code>r</code></p>"},{"location":"Std/#option","title":"Option","text":"<p>Defined as: <code>type Option a = unbox union { ...variants... }</code></p>"},{"location":"Std/#variant-none","title":"variant <code>none</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Std/#variant-some","title":"variant <code>some</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#path","title":"Path","text":"<p>Defined as: <code>type Path = Std::String</code></p> <p>The type for file path.</p>"},{"location":"Std/#ptr","title":"Ptr","text":"<p>Defined as: <code>type Ptr = unbox { built-in }</code></p> <p>The type of pointers.</p>"},{"location":"Std/#punchedarray","title":"PunchedArray","text":"<p>Defined as: <code>type PunchedArray a = unbox struct { ...fields... }</code></p> <p>The type of punched arrays.</p> <p>A punched array is an array from which a certain element has been removed. This is used in the implementation of <code>Array::act</code>.</p>"},{"location":"Std/#field-_arr","title":"field <code>_arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#field-idx","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#result","title":"Result","text":"<p>Defined as: <code>type Result e o = unbox union { ...variants... }</code></p> <p>A type of result value for a computation that may fail.</p>"},{"location":"Std/#variant-ok","title":"variant <code>ok</code>","text":"<p>Type: <code>o</code></p>"},{"location":"Std/#variant-err","title":"variant <code>err</code>","text":"<p>Type: <code>e</code></p>"},{"location":"Std/#string","title":"String","text":"<p>Defined as: <code>type String = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-_data","title":"field <code>_data</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Std/#tuple0","title":"Tuple0","text":"<p>Defined as: <code>type Tuple0 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#tuple2","title":"Tuple2","text":"<p>Defined as: <code>type Tuple2 t0 t1 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-0","title":"field <code>0</code>","text":"<p>Type: <code>t0</code></p>"},{"location":"Std/#field-1","title":"field <code>1</code>","text":"<p>Type: <code>t1</code></p>"},{"location":"Std/#tuple3","title":"Tuple3","text":"<p>Defined as: <code>type Tuple3 t0 t1 t2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-0_1","title":"field <code>0</code>","text":"<p>Type: <code>t0</code></p>"},{"location":"Std/#field-1_1","title":"field <code>1</code>","text":"<p>Type: <code>t1</code></p>"},{"location":"Std/#field-2","title":"field <code>2</code>","text":"<p>Type: <code>t2</code></p>"},{"location":"Std/#u16","title":"U16","text":"<p>Defined as: <code>type U16 = unbox { built-in }</code></p> <p>The type of 16-bit unsigned integers.</p>"},{"location":"Std/#u32","title":"U32","text":"<p>Defined as: <code>type U32 = unbox { built-in }</code></p> <p>The type of 32-bit unsigned integers.</p>"},{"location":"Std/#u64","title":"U64","text":"<p>Defined as: <code>type U64 = unbox { built-in }</code></p> <p>The type of 64-bit unsigned integers.</p>"},{"location":"Std/#u8","title":"U8","text":"<p>Defined as: <code>type U8 = unbox { built-in }</code></p> <p>The type of 8-bit unsinged integers.</p>"},{"location":"Std/#namespace-stdffi_1","title":"namespace Std::FFI","text":""},{"location":"Std/#cchar","title":"CChar","text":"<p>Defined as: <code>type CChar = Std::I8</code></p>"},{"location":"Std/#cdouble","title":"CDouble","text":"<p>Defined as: <code>type CDouble = Std::F64</code></p>"},{"location":"Std/#cfloat","title":"CFloat","text":"<p>Defined as: <code>type CFloat = Std::F32</code></p>"},{"location":"Std/#cint","title":"CInt","text":"<p>Defined as: <code>type CInt = Std::I32</code></p>"},{"location":"Std/#clong","title":"CLong","text":"<p>Defined as: <code>type CLong = Std::I64</code></p>"},{"location":"Std/#clonglong","title":"CLongLong","text":"<p>Defined as: <code>type CLongLong = Std::I64</code></p>"},{"location":"Std/#cshort","title":"CShort","text":"<p>Defined as: <code>type CShort = Std::I16</code></p>"},{"location":"Std/#csizet","title":"CSizeT","text":"<p>Defined as: <code>type CSizeT = Std::U64</code></p>"},{"location":"Std/#cunsignedchar","title":"CUnsignedChar","text":"<p>Defined as: <code>type CUnsignedChar = Std::U8</code></p>"},{"location":"Std/#cunsignedint","title":"CUnsignedInt","text":"<p>Defined as: <code>type CUnsignedInt = Std::U32</code></p>"},{"location":"Std/#cunsignedlong","title":"CUnsignedLong","text":"<p>Defined as: <code>type CUnsignedLong = Std::U64</code></p>"},{"location":"Std/#cunsignedlonglong","title":"CUnsignedLongLong","text":"<p>Defined as: <code>type CUnsignedLongLong = Std::U64</code></p>"},{"location":"Std/#cunsignedshort","title":"CUnsignedShort","text":"<p>Defined as: <code>type CUnsignedShort = Std::U16</code></p>"},{"location":"Std/#destructor","title":"Destructor","text":"<p>Defined as: <code>type Destructor a = box struct { ...fields... }</code></p> <p><code>Destructor a</code> is a wrapper type for <code>a</code>, which can have a destructor function <code>a -&gt; IO a</code>. Just before a value of type <code>Destructor a</code> is dropped, the destructor function is called on the contained value, and the value can be modified by the <code>IO</code> action.</p> <p>This type is used to create a Fix's type that wraps a resource allocated by FFI. In such cases, the destructor release the resource by FFI.</p> <p>NOTE: In the destructor, only IO actions for finalizing the passed value are allowed, and you should not perform other IO actions such as writing standard output.</p> <p>NOTE: Of course, if the value stored in <code>Destructor</code> also exists outside of <code>Destructor</code>, the value still exists in the Fix program even after the destructor function is called, and there is a possibility that the value is used after the destructor function is called.</p>"},{"location":"Std/#field-_value","title":"field <code>_value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>a -&gt; Std::IO a</code></p>"},{"location":"Std/#namespace-stdio_1","title":"namespace Std::IO","text":""},{"location":"Std/#iofail","title":"IOFail","text":"<p>Defined as: <code>type IOFail a = unbox struct { ...fields... }</code></p> <p>The type for I/O actions which may fail.</p>"},{"location":"Std/#field-_data_1","title":"field <code>_data</code>","text":"<p>Type: <code>Std::IO (Std::Result Std::ErrMsg a)</code></p>"},{"location":"Std/#iohandle","title":"IOHandle","text":"<p>Defined as: <code>type IOHandle = unbox struct { ...fields... }</code></p> <p>A handle type for read / write operations on files, stdin, stdout, stderr.</p> <p>You can create <code>IOHandle</code> value by <code>IO::open_file</code>, and close it by <code>IO::close_file</code>. There are also global <code>IO::IOHandle::stdin</code>, <code>IO::IOHandle::stdout</code>, <code>IO::IOHandle::stderr</code>.</p> <p><code>IOHandle</code> is different from C's <code>FILE</code> structure in that it is safe to close it twice. If you try to get a file pointer by <code>file_ptr</code> from a closed <code>IOHandle</code>, you will get <code>nullptr</code>.</p> <p>NOTE: <code>IOHandle</code> is implemented by <code>Destructor</code>, but the destructor function does not close the file pointer. (The destructor function only frees the management memory area.) You should explicitly close the file pointer by <code>IO::close_file</code>.</p>"},{"location":"Std/#field-_data_2","title":"field <code>_data</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::Ptr</code></p>"},{"location":"Std/#iostate","title":"IOState","text":"<p>Defined as: <code>type IOState = unbox { built-in }</code></p> <p>The type of the \"state\"s modified by I/O operations. </p> <p>The type <code>IO a</code> is isomorphic to <code>IOState -&gt; (IOState, a)</code>.</p> <p>Values of type <code>IOState</code> must be used linearly, i.e., each value must be used exactly once and must not be duplicated or discarded.</p> <p>Values of type <code>IOState</code> are generated by the runtime when executing <code>IO</code> actions like <code>main</code> and passed linearly to various places in the program. At some places, <code>IOState</code> values are consumed by <code>FFI_CALL_IOS</code> expressions and new <code>IOState</code> values are generated. When <code>IO</code> actions like <code>main</code> finish, they are consumed by the runtime and disappear.</p> <p>Technically, <code>IOState</code> exists to specify the execution of I/O operations to the optimizer in the compiler.</p>"},{"location":"Std/#namespace-stditerator_1","title":"namespace Std::Iterator","text":""},{"location":"Std/#appenditerator","title":"AppendIterator","text":"<p>Defined as: <code>type AppendIterator i1 i2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1","title":"field <code>iter1</code>","text":"<p>Type: <code>Std::Option i1</code></p>"},{"location":"Std/#field-iter2","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#arrayiterator","title":"ArrayIterator","text":"<p>Defined as: <code>type ArrayIterator a = unbox struct { ...fields... }</code></p> <p>Iterators that yields elements of an array.</p>"},{"location":"Std/#field-arr","title":"field <code>arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#field-idx_1","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#consiterator","title":"ConsIterator","text":"<p>Defined as: <code>type ConsIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-head","title":"field <code>head</code>","text":"<p>Type: <code>Std::Option a</code></p>"},{"location":"Std/#field-tail","title":"field <code>tail</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#countupiterator","title":"CountUpIterator","text":"<p>Defined as: <code>type CountUpIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-next","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#dyniterator","title":"DynIterator","text":"<p>Defined as: <code>type DynIterator a = unbox struct { ...fields... }</code></p> <p>The type of dynamic iterators.</p> <p><code>DynIterator</code> has a field, <code>next</code>, which is a function that returns the next element and the next iterator. Therefore, the process to advance <code>DynIterator</code> can be determined dynamically at runtime, not at compile time.</p> <p>The main advantage of dynamic iterator is that since it has a simple type, <code>DynIterator a</code>, - <code>DynIterator</code> can be instances of traits such as <code>Monad</code>, <code>Eq</code>, etc. - it is possible to return two dynamic iterators with different constructions depending on the branch.</p> <p>However, iterating over <code>DynIterator</code> are much slower than iterating over other iterators provided in this namespace. Therefore, if performance is important, you should avoid using <code>DynIterator</code>. In particular, if you iterate over the same <code>DynIterator</code> multiple times, consider converting it to an <code>ArrayIterator</code> using <code>bang</code> before iterating.</p>"},{"location":"Std/#field-next_1","title":"field <code>next</code>","text":"<p>Type: <code>() -&gt; Std::Option (Std::Iterator::DynIterator a, a)</code></p>"},{"location":"Std/#emptyiterator","title":"EmptyIterator","text":"<p>Defined as: <code>type EmptyIterator a = unbox struct { ...fields... }</code></p> <p>Iterators that yields no elements.</p>"},{"location":"Std/#filteriterator","title":"FilterIterator","text":"<p>Defined as: <code>type FilterIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-pred","title":"field <code>pred</code>","text":"<p>Type: <code>a -&gt; Std::Bool</code></p>"},{"location":"Std/#filtermapiterator","title":"FilterMapIterator","text":"<p>Defined as: <code>type FilterMapIterator i a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_1","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-f","title":"field <code>f</code>","text":"<p>Type: <code>a -&gt; Std::Option b</code></p>"},{"location":"Std/#flatmapiterator","title":"FlatMapIterator","text":"<p>Defined as: <code>type FlatMapIterator i1 a i2 = Std::Iterator::FlattenIterator (Std::Iterator::MapIterator i1 a i2) i2</code></p>"},{"location":"Std/#flatteniterator","title":"FlattenIterator","text":"<p>Defined as: <code>type FlattenIterator i2 i1 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-i2","title":"field <code>i2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#field-i1","title":"field <code>i1</code>","text":"<p>Type: <code>Std::Option i1</code></p>"},{"location":"Std/#intersperseiterator","title":"IntersperseIterator","text":"<p>Defined as: <code>type IntersperseIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_2","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-sep","title":"field <code>sep</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#field-next_is_sep","title":"field <code>next_is_sep</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Std/#mapiterator","title":"MapIterator","text":"<p>Defined as: <code>type MapIterator i a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_3","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-f_1","title":"field <code>f</code>","text":"<p>Type: <code>a -&gt; b</code></p>"},{"location":"Std/#productiterator","title":"ProductIterator","text":"<p>Defined as: <code>type ProductIterator i1 i2 a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1_1","title":"field <code>iter1</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#field-iter2_1","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#field-e2","title":"field <code>e2</code>","text":"<p>Type: <code>Std::Option b</code></p>"},{"location":"Std/#field-iter1_org","title":"field <code>iter1_org</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#rangeiterator","title":"RangeIterator","text":"<p>Defined as: <code>type RangeIterator = unbox struct { ...fields... }</code></p> <p>Iterators that yields reversed elements of an iterator.</p>"},{"location":"Std/#field-next_2","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-end","title":"field <code>end</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#rangestepiterator","title":"RangeStepIterator","text":"<p>Defined as: <code>type RangeStepIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-next_3","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-end_1","title":"field <code>end</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-step","title":"field <code>step</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#reverseiterator","title":"ReverseIterator","text":"<p>Defined as: <code>type ReverseIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-idx_2","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-arr_1","title":"field <code>arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#stateiterator","title":"StateIterator","text":"<p>Defined as: <code>type StateIterator s a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-state","title":"field <code>state</code>","text":"<p>Type: <code>Std::Option s</code></p>"},{"location":"Std/#field-transit","title":"field <code>transit</code>","text":"<p>Type: <code>s -&gt; Std::Option (s, a)</code></p>"},{"location":"Std/#takeiterator","title":"TakeIterator","text":"<p>Defined as: <code>type TakeIterator i = unbox struct { ...fields... }</code></p> <p>Takes at most <code>n</code> elements from an iterator.</p>"},{"location":"Std/#field-iter_4","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-n","title":"field <code>n</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#takewhileiterator","title":"TakeWhileIterator","text":"<p>Defined as: <code>type TakeWhileIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_5","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-pred_1","title":"field <code>pred</code>","text":"<p>Type: <code>a -&gt; Std::Bool</code></p>"},{"location":"Std/#zipiterator","title":"ZipIterator","text":"<p>Defined as: <code>type ZipIterator i1 i2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1_2","title":"field <code>iter1</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#field-iter2_2","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#namespace-stdoption_1","title":"namespace Std::Option","text":""},{"location":"Std/#optioniterator","title":"OptionIterator","text":"<p>Defined as: <code>type OptionIterator opt = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-opt","title":"field <code>opt</code>","text":"<p>Type: <code>opt</code></p>"},{"location":"Std/#namespace-stdstring_1","title":"namespace Std::String","text":""},{"location":"Std/#stringsplititerator","title":"StringSplitIterator","text":"<p>Defined as: <code>type StringSplitIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-idx_3","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-str","title":"field <code>str</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Std/#field-strlen","title":"field <code>strlen</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-sep_1","title":"field <code>sep</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Std/#field-sep_len","title":"field <code>sep_len</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Std/#namespace-std_2","title":"namespace Std","text":""},{"location":"Std/#trait-a-add","title":"trait <code>a : Add</code>","text":"<p>Trait for infix operator <code>+</code>.</p>"},{"location":"Std/#method-add","title":"method <code>add</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Adds two values. An expression <code>x + y</code> is translated to <code>add(x, y)</code>.</p>"},{"location":"Std/#trait-a-boxed","title":"trait <code>a : Boxed</code>","text":"<p>Marker trait for boxed types.</p> <p>This trait is automatically implemented for all boxed types. Implementing this trait manually is not allowed.</p>"},{"location":"Std/#trait-a-div","title":"trait <code>a : Div</code>","text":"<p>Trait for infix operator <code>/</code>.</p>"},{"location":"Std/#method-div","title":"method <code>div</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Divides a value by another value. An expression <code>x / y</code> is translated to <code>div(x, y)</code>.</p>"},{"location":"Std/#trait-a-eq","title":"trait <code>a : Eq</code>","text":"<p>Trait for infix operator <code>==</code>.</p>"},{"location":"Std/#method-eq","title":"method <code>eq</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Checks equality of two values. An expression <code>x == y</code> is translated to <code>eq(x, y)</code>.</p>"},{"location":"Std/#trait-a-frombytes","title":"trait <code>a : FromBytes</code>","text":""},{"location":"Std/#method-from_bytes","title":"method <code>from_bytes</code>","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Result Std::String a</code></p>"},{"location":"Std/#trait-a-fromstring","title":"trait <code>a : FromString</code>","text":""},{"location":"Std/#method-from_string","title":"method <code>from_string</code>","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::String a</code></p>"},{"location":"Std/#trait-f-f-functor","title":"trait <code>[f : *-&gt;*] f : Functor</code>","text":""},{"location":"Std/#method-map","title":"method <code>map</code>","text":"<p>Type: <code>(a -&gt; b) -&gt; f a -&gt; f b</code></p>"},{"location":"Std/#trait-iter-iterator","title":"trait <code>iter : Iterator</code>","text":"<p>The trait of iterators.</p> <p>Iterator is a concept of a sequence of elements that can be iterated. More precisely, an iterator is a type whose data is \"the current state\" and has a method <code>advance</code> which returns the next element and the next state.</p>"},{"location":"Std/#type-item","title":"type <code>Item</code>","text":"<p>Defined as: <code>Item iter</code></p>"},{"location":"Std/#method-advance","title":"method <code>advance</code>","text":"<p>Type: <code>iter -&gt; Std::Option (iter, Std::Iterator::Item iter)</code></p>"},{"location":"Std/#trait-a-lessthan","title":"trait <code>a : LessThan</code>","text":"<p>Trait for infix operator <code>&lt;</code>.</p>"},{"location":"Std/#method-less_than","title":"method <code>less_than</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt; y</code> is translated to <code>less_than(x, y)</code>.</p>"},{"location":"Std/#trait-a-lessthanoreq","title":"trait <code>a : LessThanOrEq</code>","text":"<p>Trait for infix operator <code>&lt;=</code>.</p>"},{"location":"Std/#method-less_than_or_eq","title":"method <code>less_than_or_eq</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt;= y</code> is translated to <code>less_than_or_eq(x, y)</code>.</p>"},{"location":"Std/#trait-m-m-monad","title":"trait <code>[m : *-&gt;*] m : Monad</code>","text":""},{"location":"Std/#method-bind","title":"method <code>bind</code>","text":"<p>Type: <code>(a -&gt; m b) -&gt; m a -&gt; m b</code></p>"},{"location":"Std/#method-pure","title":"method <code>pure</code>","text":"<p>Type: <code>a -&gt; m a</code></p>"},{"location":"Std/#trait-a-mul","title":"trait <code>a : Mul</code>","text":"<p>Trait for infix operator <code>*</code>.</p>"},{"location":"Std/#method-mul","title":"method <code>mul</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Multiplies a value by another value. An expression <code>x * y</code> is translated to <code>mul(x, y)</code>.</p>"},{"location":"Std/#trait-a-neg","title":"trait <code>a : Neg</code>","text":"<p>Trait for prefix operator <code>-</code>.</p>"},{"location":"Std/#method-neg","title":"method <code>neg</code>","text":"<p>Type: <code>a -&gt; a</code></p> <p>Negates a value. An expression <code>-x</code> is translated to <code>neg(x)</code>.</p>"},{"location":"Std/#trait-a-not","title":"trait <code>a : Not</code>","text":"<p>Trait for prefix operator <code>!</code>.</p>"},{"location":"Std/#method-not","title":"method <code>not</code>","text":"<p>Type: <code>a -&gt; a</code></p> <p>Logical NOT of a value. An expression <code>!x</code> is translated to <code>not(x)</code>.</p>"},{"location":"Std/#trait-a-rem","title":"trait <code>a : Rem</code>","text":"<p>Trait for infix operator <code>%</code>.</p>"},{"location":"Std/#method-rem","title":"method <code>rem</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Calculate remainder of a value dividing another value. An expression <code>x % y</code> is translated to <code>rem(x, y)</code>.</p>"},{"location":"Std/#trait-a-sub","title":"trait <code>a : Sub</code>","text":"<p>Trait for infix operator <code>-</code>.</p>"},{"location":"Std/#method-sub","title":"method <code>sub</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Subtracts a value from another value. An expression <code>x - y</code> is translated to <code>sub(x, y)</code>.</p>"},{"location":"Std/#trait-a-tobytes","title":"trait <code>a : ToBytes</code>","text":""},{"location":"Std/#method-to_bytes","title":"method <code>to_bytes</code>","text":"<p>Type: <code>a -&gt; Std::Array Std::U8</code></p>"},{"location":"Std/#trait-a-tostring","title":"trait <code>a : ToString</code>","text":""},{"location":"Std/#method-to_string","title":"method <code>to_string</code>","text":"<p>Type: <code>a -&gt; Std::String</code></p>"},{"location":"Std/#trait-a-zero","title":"trait <code>a : Zero</code>","text":""},{"location":"Std/#method-zero","title":"method <code>zero</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#trait-implementations","title":"Trait implementations","text":""},{"location":"Std/#impl-stdeq","title":"impl <code>() : Std::Eq</code>","text":""},{"location":"Std/#impl-stdtostring","title":"impl <code>() : Std::ToString</code>","text":"<p>Returns \"()\".</p>"},{"location":"Std/#impl-t0-stdeq-t1-stdeq-t0-t1-stdeq","title":"impl <code>[t0 : Std::Eq, t1 : Std::Eq] (t0, t1) : Std::Eq</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthan-t1-stdeq-t1-stdlessthan-t0-t1-stdlessthan","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThan, t1 : Std::Eq, t1 : Std::LessThan] (t0, t1) : Std::LessThan</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthanoreq-t1-stdeq-t1-stdlessthanoreq-t0-t1-stdlessthanoreq","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThanOrEq, t1 : Std::Eq, t1 : Std::LessThanOrEq] (t0, t1) : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-t0-stdtostring-t1-stdtostring-t0-t1-stdtostring","title":"impl <code>[t0 : Std::ToString, t1 : Std::ToString] (t0, t1) : Std::ToString</code>","text":""},{"location":"Std/#impl-t0-stdeq-t1-stdeq-t2-stdeq-t0-t1-t2-stdeq","title":"impl <code>[t0 : Std::Eq, t1 : Std::Eq, t2 : Std::Eq] (t0, t1, t2) : Std::Eq</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthan-t1-stdeq-t1-stdlessthan-t2-stdeq-t2-stdlessthan-t0-t1-t2-stdlessthan","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThan, t1 : Std::Eq, t1 : Std::LessThan, t2 : Std::Eq, t2 : Std::LessThan] (t0, t1, t2) : Std::LessThan</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthanoreq-t1-stdeq-t1-stdlessthanoreq-t2-stdeq-t2-stdlessthanoreq-t0-t1-t2-stdlessthanoreq","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThanOrEq, t1 : Std::Eq, t1 : Std::LessThanOrEq, t2 : Std::Eq, t2 : Std::LessThanOrEq] (t0, t1, t2) : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-t0-stdtostring-t1-stdtostring-t2-stdtostring-t0-t1-t2-stdtostring","title":"impl <code>[t0 : Std::ToString, t1 : Std::ToString, t2 : Std::ToString] (t0, t1, t2) : Std::ToString</code>","text":""},{"location":"Std/#impl-stdarray-stdfunctor","title":"impl <code>Std::Array : Std::Functor</code>","text":""},{"location":"Std/#impl-stdarray-stdmonad","title":"impl <code>Std::Array : Std::Monad</code>","text":""},{"location":"Std/#impl-stdarray-a-stdadd","title":"impl <code>Std::Array a : Std::Add</code>","text":"<p>Concatenates two arrays.</p>"},{"location":"Std/#impl-stdarray-a-stdboxed","title":"impl <code>Std::Array a : Std::Boxed</code>","text":""},{"location":"Std/#impl-a-stdeq-stdarray-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Array a : Std::Eq</code>","text":""},{"location":"Std/#impl-a-stdeq-a-stdlessthan-stdarray-a-stdlessthan","title":"impl <code>[a : Std::Eq, a : Std::LessThan] Std::Array a : Std::LessThan</code>","text":"<p><code>LessThan</code> implementation for <code>Array a</code>.</p> <p>Compares two arrays by lexicographic order.</p>"},{"location":"Std/#impl-a-stdeq-a-stdlessthanoreq-stdarray-a-stdlessthanoreq","title":"impl <code>[a : Std::Eq, a : Std::LessThanOrEq] Std::Array a : Std::LessThanOrEq</code>","text":"<p><code>LessThanOrEq</code> implementation for <code>Array a</code>.</p> <p>Compares two arrays by lexicographic order.</p>"},{"location":"Std/#impl-a-stdtostring-stdarray-a-stdtostring","title":"impl <code>[a : Std::ToString] Std::Array a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdarray-a-stdzero","title":"impl <code>Std::Array a : Std::Zero</code>","text":"<p>The empty array with zero capacity.</p>"},{"location":"Std/#impl-stdarrow-a-stdfunctor","title":"impl <code>Std::Arrow a : Std::Functor</code>","text":""},{"location":"Std/#impl-stdarrow-a-stdmonad","title":"impl <code>Std::Arrow a : Std::Monad</code>","text":""},{"location":"Std/#impl-stdbool-stdeq","title":"impl <code>Std::Bool : Std::Eq</code>","text":""},{"location":"Std/#impl-stdbool-stdnot","title":"impl <code>Std::Bool : Std::Not</code>","text":""},{"location":"Std/#impl-stdbool-stdtostring","title":"impl <code>Std::Bool : Std::ToString</code>","text":""},{"location":"Std/#impl-stdbox-a-stdboxed","title":"impl <code>Std::Box a : Std::Boxed</code>","text":""},{"location":"Std/#impl-stdf32-stdadd","title":"impl <code>Std::F32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdf32-stddiv","title":"impl <code>Std::F32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdf32-stdeq","title":"impl <code>Std::F32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdf32-stdfrombytes","title":"impl <code>Std::F32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdf32-stdfromstring","title":"impl <code>Std::F32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdf32-stdlessthan","title":"impl <code>Std::F32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdf32-stdlessthanoreq","title":"impl <code>Std::F32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdf32-stdmul","title":"impl <code>Std::F32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdf32-stdneg","title":"impl <code>Std::F32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdf32-stdsub","title":"impl <code>Std::F32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdf32-stdtobytes","title":"impl <code>Std::F32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdf32-stdtostring","title":"impl <code>Std::F32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdf32-stdzero","title":"impl <code>Std::F32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdf64-stdadd","title":"impl <code>Std::F64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdf64-stddiv","title":"impl <code>Std::F64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdf64-stdeq","title":"impl <code>Std::F64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdf64-stdfrombytes","title":"impl <code>Std::F64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdf64-stdfromstring","title":"impl <code>Std::F64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdf64-stdlessthan","title":"impl <code>Std::F64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdf64-stdlessthanoreq","title":"impl <code>Std::F64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdf64-stdmul","title":"impl <code>Std::F64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdf64-stdneg","title":"impl <code>Std::F64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdf64-stdsub","title":"impl <code>Std::F64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdf64-stdtobytes","title":"impl <code>Std::F64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdf64-stdtostring","title":"impl <code>Std::F64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdf64-stdzero","title":"impl <code>Std::F64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdffidestructor-a-stdboxed","title":"impl <code>Std::FFI::Destructor a : Std::Boxed</code>","text":""},{"location":"Std/#impl-stdi16-stdadd","title":"impl <code>Std::I16 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi16-stddiv","title":"impl <code>Std::I16 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi16-stdeq","title":"impl <code>Std::I16 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi16-stdfrombytes","title":"impl <code>Std::I16 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi16-stdfromstring","title":"impl <code>Std::I16 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi16-stdlessthan","title":"impl <code>Std::I16 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi16-stdlessthanoreq","title":"impl <code>Std::I16 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi16-stdmul","title":"impl <code>Std::I16 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi16-stdneg","title":"impl <code>Std::I16 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi16-stdrem","title":"impl <code>Std::I16 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi16-stdsub","title":"impl <code>Std::I16 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi16-stdtobytes","title":"impl <code>Std::I16 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi16-stdtostring","title":"impl <code>Std::I16 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi16-stdzero","title":"impl <code>Std::I16 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi32-stdadd","title":"impl <code>Std::I32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi32-stddiv","title":"impl <code>Std::I32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi32-stdeq","title":"impl <code>Std::I32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi32-stdfrombytes","title":"impl <code>Std::I32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi32-stdfromstring","title":"impl <code>Std::I32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi32-stdlessthan","title":"impl <code>Std::I32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi32-stdlessthanoreq","title":"impl <code>Std::I32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi32-stdmul","title":"impl <code>Std::I32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi32-stdneg","title":"impl <code>Std::I32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi32-stdrem","title":"impl <code>Std::I32 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi32-stdsub","title":"impl <code>Std::I32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi32-stdtobytes","title":"impl <code>Std::I32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi32-stdtostring","title":"impl <code>Std::I32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi32-stdzero","title":"impl <code>Std::I32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi64-stdadd","title":"impl <code>Std::I64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi64-stddiv","title":"impl <code>Std::I64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi64-stdeq","title":"impl <code>Std::I64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi64-stdfrombytes","title":"impl <code>Std::I64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi64-stdfromstring","title":"impl <code>Std::I64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi64-stdlessthan","title":"impl <code>Std::I64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi64-stdlessthanoreq","title":"impl <code>Std::I64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi64-stdmul","title":"impl <code>Std::I64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi64-stdneg","title":"impl <code>Std::I64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi64-stdrem","title":"impl <code>Std::I64 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi64-stdsub","title":"impl <code>Std::I64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi64-stdtobytes","title":"impl <code>Std::I64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi64-stdtostring","title":"impl <code>Std::I64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi64-stdzero","title":"impl <code>Std::I64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi8-stdadd","title":"impl <code>Std::I8 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi8-stddiv","title":"impl <code>Std::I8 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi8-stdeq","title":"impl <code>Std::I8 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi8-stdfrombytes","title":"impl <code>Std::I8 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi8-stdfromstring","title":"impl <code>Std::I8 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi8-stdlessthan","title":"impl <code>Std::I8 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi8-stdlessthanoreq","title":"impl <code>Std::I8 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi8-stdmul","title":"impl <code>Std::I8 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi8-stdneg","title":"impl <code>Std::I8 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi8-stdrem","title":"impl <code>Std::I8 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi8-stdsub","title":"impl <code>Std::I8 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi8-stdtobytes","title":"impl <code>Std::I8 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi8-stdtostring","title":"impl <code>Std::I8 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi8-stdzero","title":"impl <code>Std::I8 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdio-stdfunctor","title":"impl <code>Std::IO : Std::Functor</code>","text":""},{"location":"Std/#impl-stdio-stdmonad","title":"impl <code>Std::IO : Std::Monad</code>","text":""},{"location":"Std/#impl-stdioiofail-stdfunctor","title":"impl <code>Std::IO::IOFail : Std::Functor</code>","text":""},{"location":"Std/#impl-stdioiofail-stdmonad","title":"impl <code>Std::IO::IOFail : Std::Monad</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorappenditerator-i1-i2-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::AppendIterator i1 i2 : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorarrayiterator-a-stditerator","title":"impl <code>Std::Iterator::ArrayIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorconsiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::ConsIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorcountupiterator-stditerator","title":"impl <code>Std::Iterator::CountUpIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-stdfunctor","title":"impl <code>Std::Iterator::DynIterator : Std::Functor</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-stdmonad","title":"impl <code>Std::Iterator::DynIterator : Std::Monad</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stdadd","title":"impl <code>Std::Iterator::DynIterator a : Std::Add</code>","text":"<p>Concatenates two dynamic iterators.</p>"},{"location":"Std/#impl-a-stdeq-stditeratordyniterator-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Iterator::DynIterator a : Std::Eq</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stditerator","title":"impl <code>Std::Iterator::DynIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stdzero","title":"impl <code>Std::Iterator::DynIterator a : Std::Zero</code>","text":"<p>Creates an empty dynamic iterator.</p>"},{"location":"Std/#impl-stditeratoremptyiterator-a-stditerator","title":"impl <code>Std::Iterator::EmptyIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorfilteriterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::FilterIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorfiltermapiterator-i-a-b-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::FilterMapIterator i a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-i2-stditerator-i1-stditerator-stditeratorflatteniterator-i2-i1-stditerator","title":"impl <code>[i2 : Std::Iterator, i1 : Std::Iterator] Std::Iterator::FlattenIterator i2 i1 : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorintersperseiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::IntersperseIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratormapiterator-i-a-b-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::MapIterator i a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorproductiterator-i1-i2-a-b-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::ProductIterator i1 i2 a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorrangeiterator-stditerator","title":"impl <code>Std::Iterator::RangeIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorrangestepiterator-stditerator","title":"impl <code>Std::Iterator::RangeStepIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorreverseiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::ReverseIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorstateiterator-s-a-stditerator","title":"impl <code>Std::Iterator::StateIterator s a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratortakeiterator-i-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::TakeIterator i : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratortakewhileiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::TakeWhileIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorzipiterator-i1-i2-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::ZipIterator i1 i2 : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdoption-stdfunctor","title":"impl <code>Std::Option : Std::Functor</code>","text":""},{"location":"Std/#impl-stdoption-stdmonad","title":"impl <code>Std::Option : Std::Monad</code>","text":""},{"location":"Std/#impl-a-stdeq-stdoption-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Option a : Std::Eq</code>","text":""},{"location":"Std/#impl-a-stdtostring-stdoption-a-stdtostring","title":"impl <code>[a : Std::ToString] Std::Option a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdoptionoptioniterator-stdoption-a-stditerator","title":"impl <code>Std::Option::OptionIterator (Std::Option a) : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdptr-stdeq","title":"impl <code>Std::Ptr : Std::Eq</code>","text":""},{"location":"Std/#impl-stdptr-stdtostring","title":"impl <code>Std::Ptr : Std::ToString</code>","text":""},{"location":"Std/#impl-stdresult-e-stdfunctor","title":"impl <code>Std::Result e : Std::Functor</code>","text":""},{"location":"Std/#impl-stdresult-e-stdmonad","title":"impl <code>Std::Result e : Std::Monad</code>","text":""},{"location":"Std/#impl-e-stdeq-a-stdeq-stdresult-e-a-stdeq","title":"impl <code>[e : Std::Eq, a : Std::Eq] Std::Result e a : Std::Eq</code>","text":""},{"location":"Std/#impl-e-stdtostring-a-stdtostring-stdresult-e-a-stdtostring","title":"impl <code>[e : Std::ToString, a : Std::ToString] Std::Result e a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdstring-stdadd","title":"impl <code>Std::String : Std::Add</code>","text":"<p>Concatenates two strings.</p>"},{"location":"Std/#impl-stdstring-stdeq","title":"impl <code>Std::String : Std::Eq</code>","text":""},{"location":"Std/#impl-stdstring-stdlessthan","title":"impl <code>Std::String : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdstring-stdlessthanoreq","title":"impl <code>Std::String : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdstring-stdtostring","title":"impl <code>Std::String : Std::ToString</code>","text":""},{"location":"Std/#impl-stdstring-stdzero","title":"impl <code>Std::String : Std::Zero</code>","text":"<p>The empty string.</p>"},{"location":"Std/#impl-stdstringstringsplititerator-stditerator","title":"impl <code>Std::String::StringSplitIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdtuple2-t0-stdfunctor","title":"impl <code>Std::Tuple2 t0 : Std::Functor</code>","text":""},{"location":"Std/#impl-stdtuple3-t0-t1-stdfunctor","title":"impl <code>Std::Tuple3 t0 t1 : Std::Functor</code>","text":""},{"location":"Std/#impl-stdu16-stdadd","title":"impl <code>Std::U16 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu16-stddiv","title":"impl <code>Std::U16 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu16-stdeq","title":"impl <code>Std::U16 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu16-stdfrombytes","title":"impl <code>Std::U16 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu16-stdfromstring","title":"impl <code>Std::U16 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu16-stdlessthan","title":"impl <code>Std::U16 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu16-stdlessthanoreq","title":"impl <code>Std::U16 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu16-stdmul","title":"impl <code>Std::U16 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu16-stdneg","title":"impl <code>Std::U16 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu16-stdrem","title":"impl <code>Std::U16 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu16-stdsub","title":"impl <code>Std::U16 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu16-stdtobytes","title":"impl <code>Std::U16 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu16-stdtostring","title":"impl <code>Std::U16 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu16-stdzero","title":"impl <code>Std::U16 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu32-stdadd","title":"impl <code>Std::U32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu32-stddiv","title":"impl <code>Std::U32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu32-stdeq","title":"impl <code>Std::U32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu32-stdfrombytes","title":"impl <code>Std::U32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu32-stdfromstring","title":"impl <code>Std::U32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu32-stdlessthan","title":"impl <code>Std::U32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu32-stdlessthanoreq","title":"impl <code>Std::U32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu32-stdmul","title":"impl <code>Std::U32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu32-stdneg","title":"impl <code>Std::U32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu32-stdrem","title":"impl <code>Std::U32 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu32-stdsub","title":"impl <code>Std::U32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu32-stdtobytes","title":"impl <code>Std::U32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu32-stdtostring","title":"impl <code>Std::U32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu32-stdzero","title":"impl <code>Std::U32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu64-stdadd","title":"impl <code>Std::U64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu64-stddiv","title":"impl <code>Std::U64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu64-stdeq","title":"impl <code>Std::U64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu64-stdfrombytes","title":"impl <code>Std::U64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu64-stdfromstring","title":"impl <code>Std::U64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu64-stdlessthan","title":"impl <code>Std::U64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu64-stdlessthanoreq","title":"impl <code>Std::U64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu64-stdmul","title":"impl <code>Std::U64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu64-stdneg","title":"impl <code>Std::U64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu64-stdrem","title":"impl <code>Std::U64 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu64-stdsub","title":"impl <code>Std::U64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu64-stdtobytes","title":"impl <code>Std::U64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu64-stdtostring","title":"impl <code>Std::U64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu64-stdzero","title":"impl <code>Std::U64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu8-stdadd","title":"impl <code>Std::U8 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu8-stddiv","title":"impl <code>Std::U8 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu8-stdeq","title":"impl <code>Std::U8 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu8-stdfrombytes","title":"impl <code>Std::U8 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu8-stdfromstring","title":"impl <code>Std::U8 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu8-stdlessthan","title":"impl <code>Std::U8 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu8-stdlessthanoreq","title":"impl <code>Std::U8 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu8-stdmul","title":"impl <code>Std::U8 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu8-stdneg","title":"impl <code>Std::U8 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu8-stdrem","title":"impl <code>Std::U8 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu8-stdsub","title":"impl <code>Std::U8 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu8-stdtobytes","title":"impl <code>Std::U8 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu8-stdtostring","title":"impl <code>Std::U8 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu8-stdzero","title":"impl <code>Std::U8 : Std::Zero</code>","text":""},{"location":"Subprocess/","title":"Subprocess","text":"<p>Defined in subprocess@1.0.4</p>"},{"location":"Subprocess/#values","title":"Values","text":""},{"location":"Subprocess/#namespace-subprocess","title":"namespace Subprocess","text":""},{"location":"Subprocess/#run_string","title":"run_string","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::String -&gt; Std::String -&gt; Std::IO::IOFail ((Std::String, Std::String), Subprocess::ExitStatus)</code></p> <p><code>run_string(com, args, input)</code> executes a command specified by <code>com</code> with arguments <code>args</code>, and writes <code>input</code> to the standard input of the running command.</p> <p>The result is the pair of standard output and standard error, and an <code>ExitStatus</code> value.</p>"},{"location":"Subprocess/#run_with_stream","title":"run_with_stream","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::String -&gt; ((Std::IO::IOHandle, Std::IO::IOHandle, Std::IO::IOHandle) -&gt; Std::IO::IOFail a) -&gt; Std::IO::IOFail (a, Subprocess::ExitStatus)</code></p> <p><code>run_with_stream(com, args, worker)</code> executes a command specified by <code>com</code> with arguments <code>args</code>.</p> <p>The function <code>worker</code> receives three <code>IOHandle</code>s which are piped to the stdin, stdout and stderr of the running command.</p> <p>The result is the value returned by <code>worker</code> paired with an <code>ExitStatus</code> value. - <code>com : String</code>: The path to the program to run. - <code>args: Array String</code>: The arguments to be passed to <code>com</code>. - <code>worker : (IOHandle, IOHandle, IOHandle) -&gt; IOFail a</code>: Receives three <code>IOHandle</code>s which are piped to stdin, stdout and stderr of the running command.</p>"},{"location":"Subprocess/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Subprocess/#namespace-subprocess_1","title":"namespace Subprocess","text":""},{"location":"Subprocess/#exitstatus","title":"ExitStatus","text":"<p>Defined as: <code>type ExitStatus = box union { ...variants... }</code></p> <p>This type represents the exit status of a subprocess.</p> <p>This type is the union of following variants:</p> <ul> <li><code>exit : U8</code> - Means that the subprocess successfully exited (i.e., the main function returned or <code>exit()</code> was called) and stores the exit status code.</li> <li><code>signaled : U8</code> - Means that the subprocess was terminated by a signal and stores the signal number which caused the termination.</li> <li><code>wait_failed : ()</code> - Means that the <code>run*</code> function failed to wait the subprocess to exit.</li> </ul>"},{"location":"Subprocess/#variant-exit","title":"variant <code>exit</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#variant-signaled","title":"variant <code>signaled</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#variant-wait_failed","title":"variant <code>wait_failed</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Subprocess/#waitresult","title":"WaitResult","text":"<p>Defined as: <code>type WaitResult = box struct { ...fields... }</code></p> <p>Result of <code>fixsubprocess_wait_subprocess</code>.</p> <p>This struct is used in the internal implementation.</p>"},{"location":"Subprocess/#field-is_timeout","title":"field <code>is_timeout</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#field-wait_failed","title":"field <code>wait_failed</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#field-exit_status","title":"field <code>exit_status</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#field-exit_status_available","title":"field <code>exit_status_available</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#field-stop_signal","title":"field <code>stop_signal</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#field-stop_signal_available","title":"field <code>stop_signal_available</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Subprocess/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Subprocess/#trait-implementations","title":"Trait implementations","text":""},{"location":"Time/","title":"Time","text":"<p>Defined in time@1.0.1</p>"},{"location":"Time/#values","title":"Values","text":""},{"location":"Time/#namespace-time","title":"namespace Time","text":""},{"location":"Time/#_datetime_to_time_inner","title":"_datetime_to_time_inner","text":"<p>Type: <code>Std::Bool -&gt; Time::DateTime -&gt; Std::Result Std::ErrMsg Time::Time</code></p> <p>Convert datetime to time. <code>_datetime_to_time_inner(false)</code> treats the argument as UTC datetime, and <code>_datetime_to_time_inner(true)</code> treats the argument as local datetime. Note that \"local time\" depends on timezone, so this function is violating purity.</p>"},{"location":"Time/#_time_to_datetime_inner","title":"_time_to_datetime_inner","text":"<p>Type: <code>Std::Bool -&gt; Time::Time -&gt; Std::Result Std::ErrMsg Time::DateTime</code></p> <p>Convert time to datetime. <code>_time_to_datetime_inner(false)</code> returns utc datetime, and <code>_time_to_datetime_inner(true)</code> returns local datetime. Note that \"local time\" depends on timezone, so this function is violating purity.</p>"},{"location":"Time/#from_local","title":"from_local","text":"<p>Type: <code>Time::DateTime -&gt; Std::IO::IOFail Time::Time</code></p> <p>Convert local datetime to time. This function depends on timezone, so it returns <code>IOFail</code> value.</p>"},{"location":"Time/#from_utc","title":"from_utc","text":"<p>Type: <code>Time::DateTime -&gt; Std::Result Std::ErrMsg Time::Time</code></p> <p>Convert UTC datetime to time.</p>"},{"location":"Time/#get_now","title":"get_now","text":"<p>Type: <code>Std::IO Time::Time</code></p> <p>Get current time.</p>"},{"location":"Time/#get_now_monotonic","title":"get_now_monotonic","text":"<p>Type: <code>Std::IO Time::Time</code></p> <p>Get current time using CLOCK_MONOTONIC.</p>"},{"location":"Time/#to_f64","title":"to_F64","text":"<p>Type: <code>Time::Time -&gt; Std::F64</code></p> <p>Convert time to 64-bit floating value.</p>"},{"location":"Time/#to_local","title":"to_local","text":"<p>Type: <code>Time::Time -&gt; Std::IO::IOFail Time::DateTime</code></p> <p>Convert time to local time. This function depends on timezone, so it returns <code>IOFail</code> value.</p>"},{"location":"Time/#to_utc","title":"to_utc","text":"<p>Type: <code>Time::Time -&gt; Std::Result Std::ErrMsg Time::DateTime</code></p> <p>Convert time to UTC datetime.</p>"},{"location":"Time/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Time/#namespace-time_1","title":"namespace Time","text":""},{"location":"Time/#datetime","title":"DateTime","text":"<p>Defined as: <code>type DateTime = unbox struct { ...fields... }</code></p> <p>The type to represent date and time.</p>"},{"location":"Time/#field-nanosec","title":"field <code>nanosec</code>","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Time/#field-sec","title":"field <code>sec</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-min","title":"field <code>min</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-hour","title":"field <code>hour</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-day_in_month","title":"field <code>day_in_month</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-month","title":"field <code>month</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-day_in_week","title":"field <code>day_in_week</code>","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Time/#field-day_in_year","title":"field <code>day_in_year</code>","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Time/#field-year","title":"field <code>year</code>","text":"<p>Type: <code>Std::I32</code></p>"},{"location":"Time/#field-is_dst","title":"field <code>is_dst</code>","text":"<p>Type: <code>Std::Option Std::Bool</code></p>"},{"location":"Time/#time_1","title":"Time","text":"<p>Defined as: <code>type Time = unbox struct { ...fields... }</code></p> <p>The type that represents time by the number of seconds and micro seconds elapsed since the unix epoch. This struct has two fields, <code>sec: I64</code> and <code>nanosec: U32</code>.</p>"},{"location":"Time/#field-sec_1","title":"field <code>sec</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Time/#field-nanosec_1","title":"field <code>nanosec</code>","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Time/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Time/#trait-implementations","title":"Trait implementations","text":""}]}