{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>This page contains the documentation of the following projects and modules (and \"Std\"): </p> <p>This page was generated by fixlang-docpage-generator.</p>"},{"location":"Std/","title":"Std","text":"<p>Defined in std-doc@1.1.0</p> <p>Module <code>Std</code> provides basic types, traits and values.</p> <p>This module is special in the sense that:</p> <ul> <li>It is always imported implicitly. If you don't want to import some or all of entities in this module, you should write <code>import Std {...entities...}</code> explicitly.</li> <li>It contains built-in types or values which are defined or implemented directly by Fix compiler, not by Fix source code.</li> </ul> <p>NOTE on tuples: The tuple types <code>Std::TupleN</code> are defined on demand, i.e., if the user uses N-tuple in the source code, the compiler generates definition <code>TupleN</code> and related functions / trait implementations. The document for <code>Std</code> module describes about them up to N=3, but you can use larger tuples in the same way.</p>"},{"location":"Std/#values","title":"Values","text":""},{"location":"Std/#namespace-std","title":"namespace Std","text":""},{"location":"Std/#compose","title":"compose","text":"<p>Type: <code>(a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</code></p> <p>Composes two functions. Composition operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> is translated to use of <code>compose</code>.</p>"},{"location":"Std/#parameters","title":"Parameters","text":"<ul> <li><code>first</code> - The first function to be composed.</li> <li><code>second</code> - The second function to be composed.</li> </ul>"},{"location":"Std/#fix","title":"fix","text":"<p>Type: <code>((a -&gt; b) -&gt; a -&gt; b) -&gt; a -&gt; b</code></p> <p><code>fix</code> enables you to make a recursive function locally.</p> <p>The idiom is <code>fix $ |loop, arg| -&gt; {loop_body}</code>. In <code>{loop_body}</code>, you can call <code>loop</code> to make a recursion.</p> <p>Example:</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    let fact = fix $ |loop, n| if n == 0 { 1 } else { n * loop (n-1) };\n    println $ fact(5).to_string // evaluates to 5 * 4 * 3 * 2 * 1 = 120\n);\n</code></pre>"},{"location":"Std/#loop","title":"loop","text":"<p>Type: <code>s -&gt; (s -&gt; Std::LoopState s r) -&gt; r</code></p> <p><code>loop</code> enables you to make a loop. <code>LoopState</code> is a union type defined as follows:</p> <pre><code>type LoopState s r = unbox union { continue : s, break : r };\n</code></pre> <p><code>loop</code> takes two arguments: the initial state of the loop <code>s0</code> and the loop body function <code>body</code>. It first calls <code>body</code> on <code>s0</code>. If <code>body</code> returns <code>break(r)</code>, then the loop ends and returns <code>r</code> as the result. If <code>body</code> returns <code>continue(s)</code>, then the loop calls again <code>body</code> on <code>s</code>.</p> <p>Example:</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    let sum = loop((0, 0), |(i, sum)|\n        if i == 100 { break $ sum };\n        continue $ (i + 1, sum + i)\n    );\n    println $ sum.to_string\n); // evaluates to 0 + 1 + ... + 99\n</code></pre>"},{"location":"Std/#parameters_1","title":"Parameters","text":"<ul> <li><code>s0</code> - The initial state of the loop.</li> <li><code>body</code> - The loop body function. It takes the current state of the loop and returns either <code>continue(s)</code> or <code>break(r)</code>.</li> </ul>"},{"location":"Std/#loop_m","title":"loop_m","text":"<p>Type: <code>[m : Std::Monad] s -&gt; (s -&gt; m (Std::LoopState s r)) -&gt; m r</code></p> <p>Monadic loop function. This is similar to <code>loop</code> but can be used to perform monadic action at each loop.</p> <p>It is convenient to use <code>continue_m</code> and <code>break_m</code> to create monadic loop body function.</p> <p>The following program prints \"Hello World! (i)\" for i = 0, 1, 2.</p> <pre><code>module Main;\n\nmain : IO ();\nmain = (\n    loop_m(0, |i| (\n        if i == 3 { break_m $ () };\n        println(\"Hello World! (\" + i.to_string + \")\");;\n        continue_m $ i + 1\n    ))\n);\n</code></pre>"},{"location":"Std/#parameters_2","title":"Parameters","text":"<ul> <li><code>s0</code> - The initial state of the loop.</li> <li><code>body</code> - The body of the loop. It takes the current state and returns a monadic action that produces a new state or a break value.</li> </ul>"},{"location":"Std/#mark_threaded","title":"mark_threaded","text":"<p>Type: <code>a -&gt; a</code></p> <p>Traverses all values reachable from the given value, and changes the reference counters of them into multi-threaded mode.</p>"},{"location":"Std/#parameters_3","title":"Parameters","text":"<ul> <li><code>value</code> - The value to make multi-threaded.</li> </ul>"},{"location":"Std/#undefined","title":"undefined","text":"<p>Type: <code>Std::String -&gt; a</code></p> <p>Generates an undefined value.</p> <p>Calling this function prints <code>msg</code> to the stderr, flush stderr, and aborts the program (calls <code>abort</code> in libc). Since <code>undefined(msg)</code> has generic type <code>a</code>, you can put it anywhere and it will be type-checked.</p> <p>This is useful when you want to write a placeholder that will be implemented later:</p> <pre><code>truth : I64;\ntruth = undefined(\"I will implement the truth later.\");\n</code></pre> <p>Another use case is aborting the program when a certain branch of the code should not be reached:</p> <pre><code>if condition {\n    // Do something.\n} else {\n    undefined(\"This branch should not be reached.\");\n}\n</code></pre>"},{"location":"Std/#parameters_4","title":"Parameters","text":"<ul> <li><code>msg</code> - The message to print to the stderr when the undefined value is reached.</li> </ul>"},{"location":"Std/#unsafe_is_unique","title":"unsafe_is_unique","text":"<p>Type: <code>a -&gt; (Std::Bool, a)</code></p> <p>This function checks if a value is uniquely referenced by a name, and returns the result paired with the given value itself. An unboxed value is always considered unique.</p> <p>NOTE: Changing outputs of your function depending on uniqueness breaks the referential transparency of the function. If you want to assert that a value is unique, consider using <code>Debug::assert_unique</code> instead.</p> <p>Example: </p> <pre><code>module Main;\n\n\nmain : IO ();\nmain = (\n    // For unboxed value, it returns true even if the value is used later.\n    let int_val = 42;\n    let (unique, _) = int_val.unsafe_is_unique;\n    let use = int_val + 1;\n    assert_eq(|_|\"fail: int_val is shared\", unique, true);;\n\n    // For boxed value, it returns true if the value isn't used later.\n    let arr = Array::fill(10, 10);\n    let (unique, arr) = arr.unsafe_is_unique;\n    let use = arr.@(0); // This `arr` is not the one passed to `is_unique`, but the one returned by `is_unique`.\n    assert_eq(|_|\"fail: arr is shared\", unique, true);;\n\n    // Fox boxed value, it returns false if the value will be used later.\n    let arr = Array::fill(10, 10);\n    let (unique, _) = arr.unsafe_is_unique;\n    let use = arr.@(0);\n    assert_eq(|_|\"fail: arr is unique\", unique, false);;\n\n    pure()\n);\n</code></pre>"},{"location":"Std/#parameters_5","title":"Parameters","text":"<ul> <li><code>value</code> - The value to check for uniqueness.</li> </ul>"},{"location":"Std/#with_retained","title":"with_retained","text":"<p>Type: <code>(a -&gt; b) -&gt; a -&gt; b</code></p> <p><code>x.with_retained(f)</code> runs <code>f</code> with retained <code>x</code>.  It is guaranteed that <code>x</code> is keep alive until <code>with_retained</code> is finished, even after <code>f</code> has finished using <code>x</code> in it. </p> <p>A typical use case of this function is the implementation of <code>Std::Array::borrow_ptr</code>.</p>"},{"location":"Std/#parameters_6","title":"Parameters","text":"<ul> <li><code>f</code> - The function to run with the retained value.</li> <li><code>x</code> - The value to retain.</li> </ul>"},{"location":"Std/#namespace-stdadd","title":"namespace Std::Add","text":""},{"location":"Std/#add","title":"add","text":"<p>Type: <code>[a : Std::Add] a -&gt; a -&gt; a</code></p> <p>Adds two values. An expression <code>x + y</code> is translated to <code>add(x, y)</code>.</p>"},{"location":"Std/#parameters_7","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdarray","title":"namespace Std::Array","text":""},{"location":"Std/#_1","title":"@","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; a</code></p> <p>Gets an element of an array at the specified index.</p>"},{"location":"Std/#parameters_8","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the element to get.</li> <li><code>array</code> - The array to get the element from.</li> </ul>"},{"location":"Std/#act","title":"act","text":"<p>Type: <code>[f : Std::Functor] Std::I64 -&gt; (a -&gt; f a) -&gt; Std::Array a -&gt; f (Std::Array a)</code></p> <p>Modifies an array by a functorial action.</p> <p>Semantically, <code>arr.act(idx, fun)</code> is equivalent to <code>fun(arr.@(idx)).map(|elm| arr.set(idx, elm))</code>.</p> <p>This function can be defined for any functor <code>f</code> in general, but it is easier to understand the behavior when <code>f</code> is a monad: the monadic action <code>act(idx, fun, arr)</code> first performs <code>fun(arr.@(idx))</code> to get a value <code>elm</code>, and returns a pure value <code>arr.set(idx, elm)</code>.</p> <p>If you call <code>arr.act(idx, fun)</code> when both of <code>arr</code> and <code>arr.@(idx)</code> are unique, it is assured that <code>fun</code> receives the unique value.</p> <p>If you call <code>act</code> on an array which is shared, this function clones the given array when inserting the result of your action into the array. This means that you don't need to pay cloning cost when your action failed, as expected.</p>"},{"location":"Std/#parameters_9","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the element to be acted on.</li> <li><code>action</code> - The functorial action to be performed on the element at index <code>idx</code>.</li> <li><code>array</code> - The array.</li> </ul>"},{"location":"Std/#append","title":"append","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Appends an array to an array.</p> <p>Note: Since <code>a1.append(a2)</code> puts <code>a2</code> after <code>a1</code>, <code>append(lhs, rhs)</code> puts <code>lhs</code> after <code>rhs</code>.</p>"},{"location":"Std/#parameters_10","title":"Parameters","text":"<ul> <li><code>second</code> - The array to be appended.</li> <li><code>first</code> - The array to which <code>second</code> is appended.</li> </ul>"},{"location":"Std/#empty","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a</code></p> <p>Creates an empty array with specified capacity.</p>"},{"location":"Std/#parameters_11","title":"Parameters","text":"<ul> <li><code>capacity</code> - The number of elements the array can hold without allocating more space. The array is created with this capacity but is empty.</li> </ul>"},{"location":"Std/#fill","title":"fill","text":"<p>Type: <code>Std::I64 -&gt; a -&gt; Std::Array a</code></p> <p>Creates an array of the specified length filled with the initial value.</p> <p>The capacity is set to the same value as the length.</p> <p>Example: <code>fill(n, x) == [x, x, x, ..., x]</code> (of length <code>n</code>).</p>"},{"location":"Std/#parameters_12","title":"Parameters","text":"<ul> <li><code>length</code> - The number of elements in the array.</li> <li><code>value</code> - The value to fill the array with.</li> </ul>"},{"location":"Std/#find_by","title":"find_by","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::Option Std::I64</code></p> <p>Finds the first index at which the element satisfies a condition.</p>"},{"location":"Std/#parameters_13","title":"Parameters","text":"<ul> <li><code>cond</code> - The condition to be satisfied.</li> <li><code>array</code> - The array to be searched.</li> </ul>"},{"location":"Std/#from_iter","title":"from_iter","text":"<p>Type: <code>[it : Std::Iterator, Std::Iterator::Item it = a] it -&gt; Std::Array a</code></p> <p>Create an array from an iterator.</p>"},{"location":"Std/#parameters_14","title":"Parameters","text":"<ul> <li><code>it</code> - The iterator to be converted to an array.</li> </ul>"},{"location":"Std/#from_map","title":"from_map","text":"<p>Type: <code>Std::I64 -&gt; (Std::I64 -&gt; a) -&gt; Std::Array a</code></p> <p>Creates an array by a mapping function.</p>"},{"location":"Std/#parameters_15","title":"Parameters","text":"<ul> <li><code>size</code> - The size of the array to be created.</li> <li><code>map</code> - The mapping function. It takes an index and returns the value at that index.</li> </ul>"},{"location":"Std/#get_capacity","title":"get_capacity","text":"<p>Type: <code>Std::Array a -&gt; Std::I64</code></p> <p>Gets the capacity of an array.</p>"},{"location":"Std/#parameters_16","title":"Parameters","text":"<ul> <li><code>array</code> - The array to get the capacity of.</li> </ul>"},{"location":"Std/#get_first","title":"get_first","text":"<p>Type: <code>Std::Array a -&gt; Std::Option a</code></p> <p>Gets the first element of an array. Returns none if the array is empty.</p>"},{"location":"Std/#parameters_17","title":"Parameters","text":"<ul> <li><code>arr</code> - The array.</li> </ul>"},{"location":"Std/#get_last","title":"get_last","text":"<p>Type: <code>Std::Array a -&gt; Std::Option a</code></p> <p>Gets the last element of an array. Returns none if the array is empty.</p>"},{"location":"Std/#parameters_18","title":"Parameters","text":"<ul> <li><code>arr</code> - The array.</li> </ul>"},{"location":"Std/#get_size","title":"get_size","text":"<p>Type: <code>Std::Array a -&gt; Std::I64</code></p> <p>Gets the length of an array.</p>"},{"location":"Std/#parameters_19","title":"Parameters","text":"<ul> <li><code>array</code> - The array to get the length of.</li> </ul>"},{"location":"Std/#get_sub","title":"get_sub","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p><code>arr.get_sub(s, e)</code> returns an array <code>[ arr.@(i) | i \u2208 [s, e) ]</code>.</p> <p><code>s</code> and <code>e</code> are clamped to the range <code>[0, arr.get_size]</code>.</p>"},{"location":"Std/#parameters_20","title":"Parameters","text":"<ul> <li><code>start</code> - The start index of the subarray.</li> <li><code>end</code> - The end index of the subarray.</li> <li><code>array</code> - The array to be sliced.</li> </ul>"},{"location":"Std/#is_empty","title":"is_empty","text":"<p>Type: <code>Std::Array a -&gt; Std::Bool</code></p> <p>Gets whether the array is empty.</p>"},{"location":"Std/#parameters_21","title":"Parameters","text":"<ul> <li><code>array</code> - The array to be checked.</li> </ul>"},{"location":"Std/#mod","title":"mod","text":"<p>Type: <code>Std::I64 -&gt; (a -&gt; a) -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Updates an array by applying a function to the element at the specified index.</p> <p>This function clones the given array if it is shared.</p> <p>If you call <code>arr.mod(i, f)</code> when both of <code>arr</code> and <code>arr.@(i)</code> are unique, it is assured that <code>f</code> receives the element value which is unique. </p>"},{"location":"Std/#parameters_22","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the element to modify.</li> <li><code>modifier</code> - The function to apply to the element.</li> <li><code>array</code> - The array to modify.</li> </ul>"},{"location":"Std/#pop_back","title":"pop_back","text":"<p>Type: <code>Std::Array a -&gt; Std::Array a</code></p> <p>Pops an element at the back of an array. If the array is empty, this function does nothing.</p>"},{"location":"Std/#parameters_23","title":"Parameters","text":"<ul> <li><code>array</code> - The array to be popped.</li> </ul>"},{"location":"Std/#push_back","title":"push_back","text":"<p>Type: <code>a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Pushes an element to the back of an array.</p>"},{"location":"Std/#parameters_24","title":"Parameters","text":"<ul> <li><code>element</code> - The element to be pushed.</li> <li><code>array</code> - The array to which the element is pushed.</li> </ul>"},{"location":"Std/#reserve","title":"reserve","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Reserves the memory region for an array.</p>"},{"location":"Std/#parameters_25","title":"Parameters","text":"<ul> <li><code>capacity</code> - The capacity to be reserved.</li> <li><code>array</code> - The array to be reserved.</li> </ul>"},{"location":"Std/#search_partition_point","title":"search_partition_point","text":"<p>Type: <code>(a -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::I64</code></p> <p><code>arr.search_partition_point(pred)</code> returns an index x such that <code>pred</code> is true on [0, x) and false on [x, n) by binary search.</p> <p>When we put an order on <code>Bool</code> as <code>false &lt; true</code>, <code>pred</code> must be monotonically decreasing on <code>arr</code>.</p> <p>The returned value x satisfies 0 &lt;= x &lt;= <code>arr.get_size</code>. If <code>arr</code> is empty, it returns 0.</p> <p>Added in v1.1.0.</p>"},{"location":"Std/#parameters_26","title":"Parameters","text":"<ul> <li><code>predicate</code> - The predicate function.</li> <li><code>array</code> - The array to be searched.</li> </ul>"},{"location":"Std/#set","title":"set","text":"<p>Type: <code>Std::I64 -&gt; a -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Updates an array by setting a value as the element at the specified index.</p> <p>This function clones the given array if it is shared.</p>"},{"location":"Std/#parameters_27","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the element to set.</li> <li><code>value</code> - The value to set the element to.</li> <li><code>array</code> - The array to modify.</li> </ul>"},{"location":"Std/#sort_by","title":"sort_by","text":"<p>Type: <code>((a, a) -&gt; Std::Bool) -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Sorts elements in a vector by \"less than\" comparator.</p>"},{"location":"Std/#parameters_28","title":"Parameters","text":"<ul> <li><code>less_than</code> - The comparator function.</li> <li><code>array</code> - The array to be sorted.</li> </ul>"},{"location":"Std/#to_iter","title":"to_iter","text":"<p>Type: <code>Std::Array a -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Converts an array to an iterator.</p>"},{"location":"Std/#parameters_29","title":"Parameters","text":"<ul> <li><code>array</code> - The array to be converted.</li> </ul>"},{"location":"Std/#truncate","title":"truncate","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; Std::Array a</code></p> <p>Truncates an array, keeping the given number of first elements.</p> <p><code>truncante(len, arr)</code> does nothing if <code>len &gt;= arr.get_size</code>.</p>"},{"location":"Std/#parameters_30","title":"Parameters","text":"<ul> <li><code>new_length</code> - The number of elements to be kept.</li> <li><code>array</code> - The array to be truncated.</li> </ul>"},{"location":"Std/#namespace-stdbox","title":"namespace Std::Box","text":""},{"location":"Std/#make","title":"make","text":"<p>Type: <code>a -&gt; Std::Box a</code></p>"},{"location":"Std/#namespace-stddebug","title":"namespace Std::Debug","text":""},{"location":"Std/#assert","title":"assert","text":"<p>Type: <code>Std::Lazy Std::String -&gt; Std::Bool -&gt; Std::IO ()</code></p> <p>Asserts that a condition (boolean value) is true.</p> <p>If the assertion failed, prints a message to the stderr and aborts the program.</p>"},{"location":"Std/#parameters_31","title":"Parameters","text":"<ul> <li><code>lazy_msg</code></li> <li><code>condition</code></li> </ul>"},{"location":"Std/#assert_eq","title":"assert_eq","text":"<p>Type: <code>[a : Std::Eq] Std::Lazy Std::String -&gt; a -&gt; a -&gt; Std::IO ()</code></p> <p>Asserts that two values are equal.</p> <p>If the assertion failed, prints a message to the stderr and aborts the program.</p>"},{"location":"Std/#parameters_32","title":"Parameters","text":"<ul> <li><code>lazy_msg</code></li> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#assert_unique","title":"assert_unique","text":"<p>Type: <code>Std::Lazy Std::String -&gt; a -&gt; a</code></p> <p>Asserts that the given value is unique, and returns the given value. If the assertion failed, prints a message to the stderr and aborts the program.</p> <p>The main use of this function is to check whether a boxed value given as an argument is unique.</p>"},{"location":"Std/#parameters_33","title":"Parameters","text":"<ul> <li><code>lazy_msg</code></li> <li><code>value</code></li> </ul>"},{"location":"Std/#consumed_time_while_io","title":"consumed_time_while_io","text":"<p>Type: <code>Std::IO a -&gt; Std::IO (a, Std::F64)</code></p> <p>Get clocks (cpu time) elapsed while executing an I/O action.</p>"},{"location":"Std/#parameters_34","title":"Parameters","text":"<ul> <li><code>action</code></li> </ul>"},{"location":"Std/#consumed_time_while_lazy","title":"consumed_time_while_lazy","text":"<p>Type: <code>Std::Lazy a -&gt; (a, Std::F64)</code></p> <p>Get clocks (cpu time) elapsed while evaluating a lazy value.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#parameters_35","title":"Parameters","text":"<ul> <li><code>lazy_value</code></li> </ul>"},{"location":"Std/#debug_eprint","title":"debug_eprint","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string to stderr and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#parameters_36","title":"Parameters","text":"<ul> <li><code>msg</code></li> </ul>"},{"location":"Std/#debug_eprintln","title":"debug_eprintln","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string followed by a newline to stderr and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#parameters_37","title":"Parameters","text":"<ul> <li><code>msg</code></li> </ul>"},{"location":"Std/#debug_print","title":"debug_print","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string to stdout and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#parameters_38","title":"Parameters","text":"<ul> <li><code>msg</code></li> </ul>"},{"location":"Std/#debug_println","title":"debug_println","text":"<p>Type: <code>Std::String -&gt; ()</code></p> <p>Prints a string followed by a newline to stdout and flushes.</p> <p>NOTE: This function is not pure and should only be used for temporary debugging purposes.</p>"},{"location":"Std/#parameters_39","title":"Parameters","text":"<ul> <li><code>msg</code></li> </ul>"},{"location":"Std/#namespace-stddiv","title":"namespace Std::Div","text":""},{"location":"Std/#div","title":"div","text":"<p>Type: <code>[a : Std::Div] a -&gt; a -&gt; a</code></p> <p>Divides a value by another value. An expression <code>x / y</code> is translated to <code>div(x, y)</code>.</p>"},{"location":"Std/#parameters_40","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdeq","title":"namespace Std::Eq","text":""},{"location":"Std/#eq","title":"eq","text":"<p>Type: <code>[a : Std::Eq] a -&gt; a -&gt; Std::Bool</code></p> <p>Checks equality of two values. An expression <code>x == y</code> is translated to <code>eq(x, y)</code>.</p>"},{"location":"Std/#parameters_41","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdf32","title":"namespace Std::F32","text":""},{"location":"Std/#abs","title":"abs","text":"<p>Type: <code>Std::F32 -&gt; Std::F32</code></p>"},{"location":"Std/#infinity","title":"infinity","text":"<p>Type: <code>Std::F32</code></p> <p>The infinity value for the given floating point type.</p>"},{"location":"Std/#quiet_nan","title":"quiet_nan","text":"<p>Type: <code>Std::F32</code></p> <p>A floating number represented by <code>01...1</code> in binary.</p>"},{"location":"Std/#to_cchar","title":"to_CChar","text":"<p>Type: <code>Std::F32 -&gt; Std::I8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble","title":"to_CDouble","text":"<p>Type: <code>Std::F32 -&gt; Std::FFI::CDouble</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat","title":"to_CFloat","text":"<p>Type: <code>Std::F32 -&gt; Std::FFI::CFloat</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint","title":"to_CInt","text":"<p>Type: <code>Std::F32 -&gt; Std::I32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong","title":"to_CLong","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong","title":"to_CLongLong","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort","title":"to_CShort","text":"<p>Type: <code>Std::F32 -&gt; Std::I16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet","title":"to_CSizeT","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::F32 -&gt; Std::U8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::F32 -&gt; Std::U32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::F32 -&gt; Std::U16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32","title":"to_F32","text":"<p>Type: <code>Std::F32 -&gt; Std::F32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64","title":"to_F64","text":"<p>Type: <code>Std::F32 -&gt; Std::F64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16","title":"to_I16","text":"<p>Type: <code>Std::F32 -&gt; Std::I16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32","title":"to_I32","text":"<p>Type: <code>Std::F32 -&gt; Std::I32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64","title":"to_I64","text":"<p>Type: <code>Std::F32 -&gt; Std::I64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8","title":"to_I8","text":"<p>Type: <code>Std::F32 -&gt; Std::I8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16","title":"to_U16","text":"<p>Type: <code>Std::F32 -&gt; Std::U16</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32","title":"to_U32","text":"<p>Type: <code>Std::F32 -&gt; Std::U32</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64","title":"to_U64","text":"<p>Type: <code>Std::F32 -&gt; Std::U64</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8","title":"to_U8","text":"<p>Type: <code>Std::F32 -&gt; Std::U8</code></p> <p>Casts a value of <code>F32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#to_string_exp","title":"to_string_exp","text":"<p>Type: <code>Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form.</p>"},{"location":"Std/#to_string_exp_precision","title":"to_string_exp_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#to_string_precision","title":"to_string_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F32 -&gt; Std::String</code></p> <p>Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#namespace-stdf64","title":"namespace Std::F64","text":""},{"location":"Std/#abs_1","title":"abs","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p>"},{"location":"Std/#infinity_1","title":"infinity","text":"<p>Type: <code>Std::F64</code></p> <p>The infinity value for the given floating point type.</p>"},{"location":"Std/#quiet_nan_1","title":"quiet_nan","text":"<p>Type: <code>Std::F64</code></p> <p>A floating number represented by <code>01...1</code> in binary.</p>"},{"location":"Std/#to_cchar_1","title":"to_CChar","text":"<p>Type: <code>Std::F64 -&gt; Std::I8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_1","title":"to_CDouble","text":"<p>Type: <code>Std::F64 -&gt; Std::FFI::CDouble</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_1","title":"to_CFloat","text":"<p>Type: <code>Std::F64 -&gt; Std::FFI::CFloat</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_1","title":"to_CInt","text":"<p>Type: <code>Std::F64 -&gt; Std::I32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_1","title":"to_CLong","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_1","title":"to_CLongLong","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_1","title":"to_CShort","text":"<p>Type: <code>Std::F64 -&gt; Std::I16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_1","title":"to_CSizeT","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_1","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::F64 -&gt; Std::U8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_1","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::F64 -&gt; Std::U32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_1","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_1","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_1","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::F64 -&gt; Std::U16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_1","title":"to_F32","text":"<p>Type: <code>Std::F64 -&gt; Std::F32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_1","title":"to_F64","text":"<p>Type: <code>Std::F64 -&gt; Std::F64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_1","title":"to_I16","text":"<p>Type: <code>Std::F64 -&gt; Std::I16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_1","title":"to_I32","text":"<p>Type: <code>Std::F64 -&gt; Std::I32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_1","title":"to_I64","text":"<p>Type: <code>Std::F64 -&gt; Std::I64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_1","title":"to_I8","text":"<p>Type: <code>Std::F64 -&gt; Std::I8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_1","title":"to_U16","text":"<p>Type: <code>Std::F64 -&gt; Std::U16</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_1","title":"to_U32","text":"<p>Type: <code>Std::F64 -&gt; Std::U32</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_1","title":"to_U64","text":"<p>Type: <code>Std::F64 -&gt; Std::U64</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_1","title":"to_U8","text":"<p>Type: <code>Std::F64 -&gt; Std::U8</code></p> <p>Casts a value of <code>F64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#to_string_exp_1","title":"to_string_exp","text":"<p>Type: <code>Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form.</p>"},{"location":"Std/#to_string_exp_precision_1","title":"to_string_exp_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string of exponential form with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#to_string_precision_1","title":"to_string_precision","text":"<p>Type: <code>Std::U8 -&gt; Std::F64 -&gt; Std::String</code></p> <p>Converts a floating number to a string with specified precision (i.e., number of digits after the decimal point).</p>"},{"location":"Std/#namespace-stdffi","title":"namespace Std::FFI","text":""},{"location":"Std/#borrow_boxed","title":"borrow_boxed","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; b) -&gt; a -&gt; b</code></p> <p>Borrows a pointer to the data of a boxed value.</p> <p>The returned pointer points to:</p> <ul> <li>if the value is an <code>Array</code>, the first element of the array,</li> <li>if the value is a struct, the first field,</li> <li>if the value is an union, the data field (not the tag field).</li> </ul> <p>The difference from <code>boxed_to_retained_ptr</code> is that this function returns a pointer to region where the payload of a boxed value is stored; on the other hand, <code>boxed_to_retained_ptr</code> returns a pointer to the boxed value itself (which currently points to the reference counter of the boxed value).</p> <p>It is not allowed to mutate a boxed value through the borrowed pointer. If you want to do so, use <code>mutate_boxed</code>.</p> <p>See also: <code>borrow_boxed_io</code>, <code>mutate_boxed</code>, <code>mutate_boxed_io</code>.</p>"},{"location":"Std/#parameters_42","title":"Parameters","text":"<ul> <li><code>borrower</code> - The action to be performed on the pointer.</li> <li><code>value</code> - The boxed value to be borrowed.</li> </ul>"},{"location":"Std/#borrow_boxed_io","title":"borrow_boxed_io","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO b</code></p> <p>Performs an IO action borrowing a pointer to the data of a boxed value.</p> <p>For the details of the pointer, see the document of <code>borrow_boxed</code>.</p> <p>It is not allowed to mutate a boxed value through the borrowed pointer. If you want to do so, use <code>mutate_boxed</code>.</p> <p>See also: <code>borrow_boxed</code>, <code>mutate_boxed</code>, <code>mutate_boxed_io</code>.</p>"},{"location":"Std/#parameters_43","title":"Parameters","text":"<ul> <li><code>action</code> - The IO action to be performed on the pointer.</li> <li><code>value</code> - The boxed value to be borrowed.</li> </ul>"},{"location":"Std/#boxed_from_retained_ptr","title":"boxed_from_retained_ptr","text":"<p>Type: <code>[a : Std::Boxed] Std::Ptr -&gt; a</code></p> <p>Creates a boxed value from a retained pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>NOTE:  It is the user's responsibility to ensure that the argument is actually a pointer to the type of the return value, and undefined behavior will occur if it is not.</p>"},{"location":"Std/#parameters_44","title":"Parameters","text":"<ul> <li><code>retained_ptr</code> - The pointer to the value.</li> </ul>"},{"location":"Std/#boxed_to_retained_ptr","title":"boxed_to_retained_ptr","text":"<p>Type: <code>[a : Std::Boxed] a -&gt; Std::Ptr</code></p> <p>Gets a retained pointer to a boxed value. This function is used to share ownership of Fix's boxed values with foreign languages.</p> <p>To get back the boxed value from the retained pointer, use <code>from_retained_ptr</code>. To release / retain the value in a foreign language, call the function pointer obtained by <code>get_funptr_release</code> or <code>get_funptr_retain</code> on the pointer.</p> <p>Note that the returned pointer points to the control block allocated by Fix, and does not necessary points to the data of the boxed value. If you want to get a pointer to the data of the boxed value, use <code>borrow_boxed</code>.</p>"},{"location":"Std/#parameters_45","title":"Parameters","text":"<ul> <li><code>value</code> - The boxed value to get the pointer to.</li> </ul>"},{"location":"Std/#clear_errno","title":"clear_errno","text":"<p>Type: <code>Std::IO ()</code></p> <p>Sets errno to zero.</p>"},{"location":"Std/#get_errno","title":"get_errno","text":"<p>Type: <code>Std::IO Std::FFI::CInt</code></p> <p>Gets errno which is set by C functions.</p>"},{"location":"Std/#get_funptr_release","title":"get_funptr_release","text":"<p>Type: <code>[a : Std::Boxed] Std::Lazy a -&gt; Std::Ptr</code></p> <p>Returns a pointer to the function of type <code>void (*)(void*)</code> which releases a boxed value of type <code>a</code>. This function is used to release a pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>Note that this function is requires a value of type <code>Lazy a</code>, not of <code>a</code>. So you can get release function for a boxed type <code>T</code> even when you don't have a value of type <code>T</code> -- you can just use <code>|_| undefined(\"\") : T</code>:</p> <pre><code>module Main;\n\ntype VoidType = box struct {};\n// No constructor for `VoidType` is provided.\n\nmain: IO ();\nmain = (\n    let release = (|_| undefined(\"\") : VoidType).get_funptr_release; // Release function of `VoidType`.\n    pure()\n);\n</code></pre>"},{"location":"Std/#parameters_46","title":"Parameters","text":"<ul> <li><code>lazy_value</code> - The lazy boxed value to indicate the type of the boxed value to be released.</li> </ul>"},{"location":"Std/#get_funptr_retain","title":"get_funptr_retain","text":"<p>Type: <code>[a : Std::Boxed] Std::Lazy a -&gt; Std::Ptr</code></p> <p>Returns a pointer to the function of type <code>void (*)(void*)</code> which retains a boxed value of type <code>a</code>. This function is used to retain a pointer obtained by <code>boxed_to_retained_ptr</code>.</p> <p>For the reason that this function requires a value of type <code>Lazy a</code>, not of <code>a</code>, see the document for <code>get_funptr_release</code>.</p>"},{"location":"Std/#parameters_47","title":"Parameters","text":"<ul> <li><code>lazy_value</code> - The lazy boxed value to indicate the type of the boxed value to be retained.</li> </ul>"},{"location":"Std/#mutate_boxed","title":"mutate_boxed","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; (a, b)</code></p> <p><code>x.mutate_boxed(io)</code> gets a pointer <code>ptr</code> to the data that <code>x</code> points to, executes <code>io(ptr)</code>, and then returns mutated <code>x</code> paired with the result of <code>io(ptr)</code>.</p> <p>The IO action <code>io(ptr)</code> is expected to modify the value of <code>x</code> through the obtained pointer.  Do not perform any IO operations other than mutating the value of <code>x</code>.</p> <p>For more details on the pointer passed to <code>io</code>, see the document of <code>borrow_boxed</code>.</p> <p>This function first clones the value if <code>x</code> is not unique.</p> <p>See also: <code>borrow_boxed</code>, <code>mutate_boxed_io</code>, <code>mutate_boxed</code>.</p>"},{"location":"Std/#parameters_48","title":"Parameters","text":"<ul> <li><code>act</code> - The action to perform on the pointer to the boxed value.</li> <li><code>value</code> - The boxed value to mutate.</li> </ul>"},{"location":"Std/#mutate_boxed_io","title":"mutate_boxed_io","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO (a, b)</code></p> <p><code>x.mutate_boxed_io(io)</code> gets a pointer <code>ptr</code> to the data that <code>x</code> points to, executes <code>io(ptr)</code>, and then returns mutated <code>x</code> paired with the result of <code>io(ptr)</code>.</p> <p>Similar to <code>mutate_boxed</code>, but this function is used when you want to run the IO action in the existing IO context.</p> <p>For more details on the pointer passed to <code>io</code>, see the document of <code>borrow_boxed</code>.</p> <p>For more details, see the document of <code>mutate_boxed</code>.</p> <p>See also: <code>borrow_boxed</code>, <code>borrow_boxed_io</code>, <code>mutate_boxed</code>.</p>"},{"location":"Std/#parameters_49","title":"Parameters","text":"<ul> <li><code>action</code> - The IO action to be performed on the pointer.</li> <li><code>value</code> - The boxed value to be mutated.</li> </ul>"},{"location":"Std/#mutate_boxed_ios","title":"mutate_boxed_ios","text":"<p>Type: <code>[a : Std::Boxed] (Std::Ptr -&gt; Std::IO b) -&gt; a -&gt; Std::IO::IOState -&gt; (Std::IO::IOState, (a, b))</code></p> <p>Internal implementation of the <code>mutate_boxed_io</code> function.</p>"},{"location":"Std/#parameters_50","title":"Parameters","text":"<ul> <li><code>act</code> - The action to perform on the pointer to the boxed value.</li> <li><code>value</code> - The boxed value to mutate.</li> <li><code>ios</code> - The <code>IOState</code> to use for the action.</li> </ul>"},{"location":"Std/#namespace-stdffidestructor","title":"namespace Std::FFI::Destructor","text":""},{"location":"Std/#borrow","title":"borrow","text":"<p>Type: <code>(a -&gt; b) -&gt; Std::FFI::Destructor a -&gt; b</code></p> <p>Borrow the contained value.</p> <p><code>borrow(worker, dtor)</code> calls <code>worker</code> on the contained value captured by <code>dtor</code>, and returns the value returned by <code>worker</code>.</p> <p>It is guaranteed that the <code>dtor</code> is alive during the call of <code>worker</code>. In other words, the <code>worker</code> receives the contained value for which the destructor is not called yet.</p>"},{"location":"Std/#parameters_51","title":"Parameters","text":"<ul> <li><code>borrower</code> - The function to be called on the contained value.</li> <li><code>dtor</code> - The destructor value.</li> </ul>"},{"location":"Std/#borrow_io","title":"borrow_io","text":"<p>Type: <code>(a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; Std::IO b</code></p> <p>Performs an IO action borrowing the contained value.</p>"},{"location":"Std/#parameters_52","title":"Parameters","text":"<ul> <li><code>action</code> - The IO action to be performed on the contained value.</li> <li><code>dtor</code> - The destructor value.</li> </ul>"},{"location":"Std/#make_1","title":"make","text":"<p>Type: <code>a -&gt; (a -&gt; Std::IO a) -&gt; Std::FFI::Destructor a</code></p> <p>Make a destructor value.</p>"},{"location":"Std/#parameters_53","title":"Parameters","text":"<ul> <li><code>value</code> - The value to be wrapped.</li> <li><code>dtor</code> - The destructor function to be called on the value.</li> </ul>"},{"location":"Std/#mutate_unique","title":"mutate_unique","text":"<p>Type: <code>(a -&gt; Std::IO a) -&gt; (a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; (Std::FFI::Destructor a, b)</code></p> <p>Apply an IO action which mutates the semantics of the value.</p> <p><code>dtor.mutate_unique(ctor, action)</code> applies <code>action</code> to <code>dtor</code> if <code>dtor</code> is unique. If <code>dtor</code> is shared, it creates a new <code>Destructor</code> value using <code>ctor</code> and applies <code>action</code> to the new value.</p> <p>The <code>action</code> is allowed to modify the external resource stored in <code>dtor</code> (e.g., if <code>value</code> is a pointer, it can modify the value pointed by the pointer). Also, <code>ctor</code> should be a \"copy constructor\" (e.g., memcpy) of the external resource stored in <code>dtor</code>.</p>"},{"location":"Std/#parameters_54","title":"Parameters","text":"<ul> <li><code>clone</code> - The constructor function of the contained value.</li> <li><code>action</code> - The action to be performed on the contained value.</li> <li><code>dtor</code> - The destructor value.</li> </ul>"},{"location":"Std/#mutate_unique_io","title":"mutate_unique_io","text":"<p>Type: <code>(a -&gt; Std::IO a) -&gt; (a -&gt; Std::IO b) -&gt; Std::FFI::Destructor a -&gt; Std::IO (Std::FFI::Destructor a, b)</code></p> <p>Apply an IO action which mutates the semantics of the value.</p> <p>This is similar to <code>mutate_unique</code>, but the <code>ctor</code> and <code>action</code> is executed in the context of the external <code>IO</code> context.</p>"},{"location":"Std/#parameters_55","title":"Parameters","text":"<ul> <li><code>clone</code> - The constructor function of the contained value.</li> <li><code>action</code> - The action to be performed on the contained value.</li> <li><code>dtor</code> - The destructor value.</li> </ul>"},{"location":"Std/#namespace-stdfrombytes","title":"namespace Std::FromBytes","text":""},{"location":"Std/#from_bytes","title":"from_bytes","text":"<p>Type: <code>[a : Std::FromBytes] Std::Array Std::U8 -&gt; Std::Result Std::ErrMsg a</code></p> <p>Converts a byte array into a value by parsing it.</p>"},{"location":"Std/#parameters_56","title":"Parameters","text":"<ul> <li><code>byte_array</code> - The byte array to be converted.</li> </ul>"},{"location":"Std/#namespace-stdfromstring","title":"namespace Std::FromString","text":""},{"location":"Std/#from_string","title":"from_string","text":"<p>Type: <code>[a : Std::FromString] Std::String -&gt; Std::Result Std::ErrMsg a</code></p> <p>Converts a string into a value by parsing it.</p>"},{"location":"Std/#parameters_57","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#namespace-stdfunctor","title":"namespace Std::Functor","text":""},{"location":"Std/#forget","title":"forget","text":"<p>Type: <code>[f : Std::Functor] f a -&gt; f ()</code></p> <p>Discards the value inside the functor and returns a functor containing <code>()</code>.</p>"},{"location":"Std/#parameters_58","title":"Parameters","text":"<ul> <li><code>value</code> - The functor value.</li> </ul>"},{"location":"Std/#map","title":"map","text":"<p>Type: <code>[f : Std::Functor] (a -&gt; b) -&gt; f a -&gt; f b</code></p> <p>Applies a function to the value inside the functor.</p>"},{"location":"Std/#parameters_59","title":"Parameters","text":"<ul> <li><code>f</code> - The function to be applied.</li> <li><code>value</code> - The functor value to be transformed.</li> </ul>"},{"location":"Std/#namespace-stdi16","title":"namespace Std::I16","text":""},{"location":"Std/#abs_2","title":"abs","text":"<p>Type: <code>Std::I16 -&gt; Std::I16</code></p>"},{"location":"Std/#bit_and","title":"bit_and","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_60","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or","title":"bit_or","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_61","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor","title":"bit_xor","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_62","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum","title":"maximum","text":"<p>Type: <code>Std::I16</code></p>"},{"location":"Std/#minimum","title":"minimum","text":"<p>Type: <code>Std::I16</code></p>"},{"location":"Std/#shift_left","title":"shift_left","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_63","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right","title":"shift_right","text":"<p>Type: <code>Std::I16 -&gt; Std::I16 -&gt; Std::I16</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_64","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_2","title":"to_CChar","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_2","title":"to_CDouble","text":"<p>Type: <code>Std::I16 -&gt; Std::F64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_2","title":"to_CFloat","text":"<p>Type: <code>Std::I16 -&gt; Std::F32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_2","title":"to_CInt","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_2","title":"to_CLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_2","title":"to_CLongLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_2","title":"to_CShort","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_2","title":"to_CSizeT","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_2","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_2","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_2","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_2","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_2","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I16 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I16</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_2","title":"to_F32","text":"<p>Type: <code>Std::I16 -&gt; Std::F32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_2","title":"to_F64","text":"<p>Type: <code>Std::I16 -&gt; Std::F64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_2","title":"to_I16","text":"<p>Type: <code>Std::I16 -&gt; Std::I16</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_2","title":"to_I32","text":"<p>Type: <code>Std::I16 -&gt; Std::I32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_2","title":"to_I64","text":"<p>Type: <code>Std::I16 -&gt; Std::I64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_2","title":"to_I8","text":"<p>Type: <code>Std::I16 -&gt; Std::I8</code></p> <p>Casts a value of <code>I16</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_2","title":"to_U16","text":"<p>Type: <code>Std::I16 -&gt; Std::U16</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_2","title":"to_U32","text":"<p>Type: <code>Std::I16 -&gt; Std::U32</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_2","title":"to_U64","text":"<p>Type: <code>Std::I16 -&gt; Std::U64</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_2","title":"to_U8","text":"<p>Type: <code>Std::I16 -&gt; Std::U8</code></p> <p>Casts a value of <code>I16</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi32","title":"namespace Std::I32","text":""},{"location":"Std/#abs_3","title":"abs","text":"<p>Type: <code>Std::I32 -&gt; Std::I32</code></p>"},{"location":"Std/#bit_and_1","title":"bit_and","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_65","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_1","title":"bit_or","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_66","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_1","title":"bit_xor","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_67","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_1","title":"maximum","text":"<p>Type: <code>Std::I32</code></p>"},{"location":"Std/#minimum_1","title":"minimum","text":"<p>Type: <code>Std::I32</code></p>"},{"location":"Std/#shift_left_1","title":"shift_left","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_68","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_1","title":"shift_right","text":"<p>Type: <code>Std::I32 -&gt; Std::I32 -&gt; Std::I32</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_69","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_3","title":"to_CChar","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_3","title":"to_CDouble","text":"<p>Type: <code>Std::I32 -&gt; Std::F64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_3","title":"to_CFloat","text":"<p>Type: <code>Std::I32 -&gt; Std::F32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_3","title":"to_CInt","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_3","title":"to_CLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_3","title":"to_CLongLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_3","title":"to_CShort","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_3","title":"to_CSizeT","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_3","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_3","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_3","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_3","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_3","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I32 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_3","title":"to_F32","text":"<p>Type: <code>Std::I32 -&gt; Std::F32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_3","title":"to_F64","text":"<p>Type: <code>Std::I32 -&gt; Std::F64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_3","title":"to_I16","text":"<p>Type: <code>Std::I32 -&gt; Std::I16</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_3","title":"to_I32","text":"<p>Type: <code>Std::I32 -&gt; Std::I32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_3","title":"to_I64","text":"<p>Type: <code>Std::I32 -&gt; Std::I64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_3","title":"to_I8","text":"<p>Type: <code>Std::I32 -&gt; Std::I8</code></p> <p>Casts a value of <code>I32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_3","title":"to_U16","text":"<p>Type: <code>Std::I32 -&gt; Std::U16</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_3","title":"to_U32","text":"<p>Type: <code>Std::I32 -&gt; Std::U32</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_3","title":"to_U64","text":"<p>Type: <code>Std::I32 -&gt; Std::U64</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_3","title":"to_U8","text":"<p>Type: <code>Std::I32 -&gt; Std::U8</code></p> <p>Casts a value of <code>I32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi64","title":"namespace Std::I64","text":""},{"location":"Std/#abs_4","title":"abs","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p>"},{"location":"Std/#bit_and_2","title":"bit_and","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_70","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_2","title":"bit_or","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_71","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_2","title":"bit_xor","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_72","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_2","title":"maximum","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#minimum_2","title":"minimum","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#shift_left_2","title":"shift_left","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_73","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_2","title":"shift_right","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_74","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_4","title":"to_CChar","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_4","title":"to_CDouble","text":"<p>Type: <code>Std::I64 -&gt; Std::F64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_4","title":"to_CFloat","text":"<p>Type: <code>Std::I64 -&gt; Std::F32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_4","title":"to_CInt","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_4","title":"to_CLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_4","title":"to_CLongLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_4","title":"to_CShort","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_4","title":"to_CSizeT","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_4","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_4","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_4","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_4","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_4","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I64 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_4","title":"to_F32","text":"<p>Type: <code>Std::I64 -&gt; Std::F32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_4","title":"to_F64","text":"<p>Type: <code>Std::I64 -&gt; Std::F64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_4","title":"to_I16","text":"<p>Type: <code>Std::I64 -&gt; Std::I16</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_4","title":"to_I32","text":"<p>Type: <code>Std::I64 -&gt; Std::I32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_4","title":"to_I64","text":"<p>Type: <code>Std::I64 -&gt; Std::I64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_4","title":"to_I8","text":"<p>Type: <code>Std::I64 -&gt; Std::I8</code></p> <p>Casts a value of <code>I64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_4","title":"to_U16","text":"<p>Type: <code>Std::I64 -&gt; Std::U16</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_4","title":"to_U32","text":"<p>Type: <code>Std::I64 -&gt; Std::U32</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_4","title":"to_U64","text":"<p>Type: <code>Std::I64 -&gt; Std::U64</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_4","title":"to_U8","text":"<p>Type: <code>Std::I64 -&gt; Std::U8</code></p> <p>Casts a value of <code>I64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdi8","title":"namespace Std::I8","text":""},{"location":"Std/#abs_5","title":"abs","text":"<p>Type: <code>Std::I8 -&gt; Std::I8</code></p>"},{"location":"Std/#bit_and_3","title":"bit_and","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_75","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_3","title":"bit_or","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_76","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_3","title":"bit_xor","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_77","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_3","title":"maximum","text":"<p>Type: <code>Std::I8</code></p>"},{"location":"Std/#minimum_3","title":"minimum","text":"<p>Type: <code>Std::I8</code></p>"},{"location":"Std/#shift_left_3","title":"shift_left","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_78","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_3","title":"shift_right","text":"<p>Type: <code>Std::I8 -&gt; Std::I8 -&gt; Std::I8</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_79","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_5","title":"to_CChar","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_5","title":"to_CDouble","text":"<p>Type: <code>Std::I8 -&gt; Std::F64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_5","title":"to_CFloat","text":"<p>Type: <code>Std::I8 -&gt; Std::F32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_5","title":"to_CInt","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_5","title":"to_CLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_5","title":"to_CLongLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_5","title":"to_CShort","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_5","title":"to_CSizeT","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_5","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_5","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_5","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_5","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_5","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::I8 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>I8</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_5","title":"to_F32","text":"<p>Type: <code>Std::I8 -&gt; Std::F32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_5","title":"to_F64","text":"<p>Type: <code>Std::I8 -&gt; Std::F64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_5","title":"to_I16","text":"<p>Type: <code>Std::I8 -&gt; Std::I16</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_5","title":"to_I32","text":"<p>Type: <code>Std::I8 -&gt; Std::I32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_5","title":"to_I64","text":"<p>Type: <code>Std::I8 -&gt; Std::I64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_5","title":"to_I8","text":"<p>Type: <code>Std::I8 -&gt; Std::I8</code></p> <p>Casts a value of <code>I8</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_5","title":"to_U16","text":"<p>Type: <code>Std::I8 -&gt; Std::U16</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_5","title":"to_U32","text":"<p>Type: <code>Std::I8 -&gt; Std::U32</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_5","title":"to_U64","text":"<p>Type: <code>Std::I8 -&gt; Std::U64</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_5","title":"to_U8","text":"<p>Type: <code>Std::I8 -&gt; Std::U8</code></p> <p>Casts a value of <code>I8</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdio","title":"namespace Std::IO","text":""},{"location":"Std/#close_file","title":"close_file","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO ()</code></p> <p>Closes a file.</p> <p>Unlike C's <code>fclose</code>, closing an already closed <code>IOHandle</code> is safe and does nothing.</p>"},{"location":"Std/#parameters_80","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be closed.</li> </ul>"},{"location":"Std/#eprint","title":"eprint","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string to stderr.</p>"},{"location":"Std/#parameters_81","title":"Parameters","text":"<ul> <li><code>msg</code> - The string to be printed.</li> </ul>"},{"location":"Std/#eprintln","title":"eprintln","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string followed by a newline to stderr.</p>"},{"location":"Std/#parameters_82","title":"Parameters","text":"<ul> <li><code>msg</code> - The string to be printed.</li> </ul>"},{"location":"Std/#exit","title":"exit","text":"<p>Type: <code>Std::I64 -&gt; Std::IO a</code></p> <p>Exits the program with an error code.</p>"},{"location":"Std/#parameters_83","title":"Parameters","text":"<ul> <li><code>code</code> - The error code to be returned.</li> </ul>"},{"location":"Std/#exit_with_msg","title":"exit_with_msg","text":"<p>Type: <code>Std::I64 -&gt; Std::String -&gt; Std::IO a</code></p> <p>Exits the program with an error message and an error code.</p> <p>The error message is written to the standard error output.</p>"},{"location":"Std/#parameters_84","title":"Parameters","text":"<ul> <li><code>code</code> - The error code to be returned.</li> <li><code>msg</code> - The error message to be printed.</li> </ul>"},{"location":"Std/#from_runner","title":"from_runner","text":"<p>Type: <code>(Std::IO::IOState -&gt; (Std::IO::IOState, a)) -&gt; Std::IO a</code></p> <p>Creates an IO action from a IO runner function, which is a function of type <code>IOState -&gt; (IOState, a)</code>.</p>"},{"location":"Std/#parameters_85","title":"Parameters","text":"<ul> <li><code>io_runner</code> - The IO runner function.</li> </ul>"},{"location":"Std/#get_arg","title":"get_arg","text":"<p>Type: <code>Std::I64 -&gt; Std::IO (Std::Option Std::String)</code></p> <p><code>get_arg(i)</code> returns the i-th (0-indexed) command line argument.</p> <p>If i is greater than or equal to the number of command line arguments, this function returns none.</p>"},{"location":"Std/#parameters_86","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the command line argument.</li> </ul>"},{"location":"Std/#get_arg_count","title":"get_arg_count","text":"<p>Type: <code>Std::IO Std::I64</code></p> <p>Gets the number of command line arguments.</p>"},{"location":"Std/#get_args","title":"get_args","text":"<p>Type: <code>Std::IO (Std::Array Std::String)</code></p> <p>Gets command line arguments.</p>"},{"location":"Std/#input_line","title":"input_line","text":"<p>Type: <code>Std::IO Std::String</code></p> <p>Reads a line from stdin. If some error occurr, this function aborts the program.</p> <p>If you want to handle errors, use <code>read_line(stdin)</code> instead.</p>"},{"location":"Std/#is_eof","title":"is_eof","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO Std::Bool</code></p> <p>Checks if an <code>IOHandle</code> reached to the EOF.</p>"},{"location":"Std/#parameters_87","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be checked.</li> </ul>"},{"location":"Std/#loop_lines","title":"loop_lines","text":"<p>Type: <code>Std::IO::IOHandle -&gt; s -&gt; (s -&gt; Std::String -&gt; Std::LoopState s s) -&gt; Std::IO::IOFail s</code></p> <p>Loop on lines read from an <code>IOHandle</code>.</p> <p><code>loop_lines(handle, initial_state, worker)</code> calls <code>worker</code> on the pair of current state and a line string read from <code>handle</code>. The function <code>worker</code> should return an updated state as <code>LoopState</code> value, i.e., a value created by <code>continue</code> or <code>break</code>. When the <code>handle</code> reaches to the EOF or <code>worker</code> returns a <code>break</code> value, <code>loop_lines</code> returns the last state value.</p> <p>Note that the line string passed to <code>worker</code> may contain a newline code at the end. To remove it, use <code>String::strip_last_spaces</code>.</p>"},{"location":"Std/#parameters_88","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> <li><code>s0</code> - The initial state.</li> <li><code>work</code> - The function to be called on the pair of current state and a line string read from <code>handle</code>.</li> </ul>"},{"location":"Std/#loop_lines_io","title":"loop_lines_io","text":"<p>Type: <code>Std::IO::IOHandle -&gt; s -&gt; (s -&gt; Std::String -&gt; Std::IO::IOFail (Std::LoopState s s)) -&gt; Std::IO::IOFail s</code></p> <p>Loop on lines read from an <code>IOHandle</code>.</p> <p>Similar to <code>loop_lines</code>, but the worker function can perform an IO action.</p>"},{"location":"Std/#parameters_89","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> <li><code>s0</code> - The initial state.</li> <li><code>work</code> - The function to be called on the pair of current state and a line string read from <code>handle</code>.</li> </ul>"},{"location":"Std/#open_file","title":"open_file","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; Std::IO::IOFail Std::IO::IOHandle</code></p> <p>Openes a file. The second argument is a mode string for <code>fopen</code> C function.</p>"},{"location":"Std/#parameters_90","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be opened.</li> <li><code>mode</code> - The mode string for <code>fopen</code> C function.</li> </ul>"},{"location":"Std/#print","title":"print","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string to stdout.</p>"},{"location":"Std/#parameters_91","title":"Parameters","text":"<ul> <li><code>msg</code> - The string to be printed.</li> </ul>"},{"location":"Std/#println","title":"println","text":"<p>Type: <code>Std::String -&gt; Std::IO ()</code></p> <p>Prints a string followed by a newline to stdout.</p>"},{"location":"Std/#parameters_92","title":"Parameters","text":"<ul> <li><code>msg</code> - The string to be printed.</li> </ul>"},{"location":"Std/#read_bytes","title":"read_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads all bytes from an IOHandle.</p>"},{"location":"Std/#parameters_93","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> </ul>"},{"location":"Std/#read_file_bytes","title":"read_file_bytes","text":"<p>Type: <code>Std::Path -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads all bytes from a file.</p>"},{"location":"Std/#parameters_94","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be read.</li> </ul>"},{"location":"Std/#read_file_string","title":"read_file_string","text":"<p>Type: <code>Std::Path -&gt; Std::IO::IOFail Std::String</code></p> <p>Raads all characters from a file.</p>"},{"location":"Std/#parameters_95","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be read.</li> </ul>"},{"location":"Std/#read_line","title":"read_line","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail Std::String</code></p> <p>Reads characters from a IOHandle upto newline or EOF. The returned string may include newline at its end.</p>"},{"location":"Std/#parameters_96","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> </ul>"},{"location":"Std/#read_n_bytes","title":"read_n_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::I64 -&gt; Std::IO::IOFail (Std::Array Std::U8)</code></p> <p>Reads at most n bytes from an IOHandle.</p>"},{"location":"Std/#parameters_97","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> <li><code>num_bytes</code> - The number of bytes to be read.</li> </ul>"},{"location":"Std/#read_string","title":"read_string","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO::IOFail Std::String</code></p> <p>Reads all characters from an IOHandle.</p>"},{"location":"Std/#parameters_98","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be read.</li> </ul>"},{"location":"Std/#stderr","title":"stderr","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard error.</p>"},{"location":"Std/#stdin","title":"stdin","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard input.</p>"},{"location":"Std/#stdout","title":"stdout","text":"<p>Type: <code>Std::IO::IOHandle</code></p> <p>The handle for standard output.</p>"},{"location":"Std/#unsafe_perform","title":"unsafe_perform","text":"<p>Type: <code>Std::IO a -&gt; a</code></p>"},{"location":"Std/#with_file","title":"with_file","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; (Std::IO::IOHandle -&gt; Std::IO::IOFail a) -&gt; Std::IO::IOFail a</code></p> <p>Performs a function with a file handle. The second argument is a mode string for <code>fopen</code> C function.</p> <p>The file handle will be closed automatically.</p>"},{"location":"Std/#parameters_99","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be opened.</li> <li><code>mode</code> - The mode string for <code>fopen</code> C function.</li> <li><code>work</code> - The function to be called on the opened file handle.</li> </ul>"},{"location":"Std/#write_bytes","title":"write_bytes","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::Array Std::U8 -&gt; Std::IO::IOFail ()</code></p> <p>Writes a byte array into an IOHandle.</p>"},{"location":"Std/#parameters_100","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be written.</li> <li><code>array</code> - The byte array to be written.</li> </ul>"},{"location":"Std/#write_file_bytes","title":"write_file_bytes","text":"<p>Type: <code>Std::Path -&gt; Std::Array Std::U8 -&gt; Std::IO::IOFail ()</code></p> <p>Writes a byte array into a file.</p>"},{"location":"Std/#parameters_101","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be written.</li> <li><code>content</code> - The byte array to be written.</li> </ul>"},{"location":"Std/#write_file_string","title":"write_file_string","text":"<p>Type: <code>Std::Path -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p> <p>Writes a string into a file.</p>"},{"location":"Std/#parameters_102","title":"Parameters","text":"<ul> <li><code>path</code> - The path to the file to be written.</li> <li><code>content</code> - The string to be written.</li> </ul>"},{"location":"Std/#write_string","title":"write_string","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::String -&gt; Std::IO::IOFail ()</code></p> <p>Writes a string into an IOHandle.</p>"},{"location":"Std/#parameters_103","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to be written.</li> <li><code>content</code> - The string to be written.</li> </ul>"},{"location":"Std/#namespace-stdioiofail","title":"namespace Std::IO::IOFail","text":""},{"location":"Std/#from_io_result","title":"from_io_result","text":"<p>Type: <code>Std::IO (Std::Result Std::ErrMsg a) -&gt; Std::IO::IOFail a</code></p> <p>Create from IO action of which returns <code>Result ErrMsg a</code>.</p>"},{"location":"Std/#parameters_104","title":"Parameters","text":"<ul> <li><code>io_res</code> - The IO action to be converted.</li> </ul>"},{"location":"Std/#from_result","title":"from_result","text":"<p>Type: <code>Std::Result Std::ErrMsg a -&gt; Std::IO::IOFail a</code></p> <p>Creates an pure <code>IOFail</code> value from a <code>Result</code> value.</p>"},{"location":"Std/#parameters_105","title":"Parameters","text":"<ul> <li><code>res</code> - The result value to be converted.</li> </ul>"},{"location":"Std/#lift","title":"lift","text":"<p>Type: <code>Std::IO a -&gt; Std::IO::IOFail a</code></p> <p>Lifts an <code>IO</code> action to a successful <code>IOFail</code> action.</p>"},{"location":"Std/#parameters_106","title":"Parameters","text":"<ul> <li><code>io</code> - The IO action to be lifted.</li> </ul>"},{"location":"Std/#throw","title":"throw","text":"<p>Type: <code>Std::ErrMsg -&gt; Std::IO::IOFail a</code></p> <p>Creates an error <code>IOFail</code> action.</p>"},{"location":"Std/#parameters_107","title":"Parameters","text":"<ul> <li><code>err_msg</code> - The error message to be thrown.</li> </ul>"},{"location":"Std/#to_result","title":"to_result","text":"<p>Type: <code>Std::IO::IOFail a -&gt; Std::IO (Std::Result Std::ErrMsg a)</code></p> <p>Converts an <code>IOFail</code> to an <code>Result</code> value (wrapped by <code>IO</code>).</p>"},{"location":"Std/#parameters_108","title":"Parameters","text":"<ul> <li><code>io_fail</code> - The <code>IOFail</code> value to be converted.</li> </ul>"},{"location":"Std/#try","title":"try","text":"<p>Type: <code>(Std::ErrMsg -&gt; Std::IO a) -&gt; Std::IO::IOFail a -&gt; Std::IO a</code></p> <p>Converts an <code>IOFail</code> value to an <code>IO</code> value by an error handler (i.e., a <code>catch</code>) function.</p>"},{"location":"Std/#parameters_109","title":"Parameters","text":"<ul> <li><code>catch</code> - The error handler function to be called on the error.</li> <li><code>io_fail</code> - The <code>IOFail</code> value to be run.</li> </ul>"},{"location":"Std/#namespace-stdioiohandle","title":"namespace Std::IO::IOHandle","text":""},{"location":"Std/#from_file_ptr","title":"from_file_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::IO::IOHandle</code></p> <p>Creates an <code>IOHandle</code> from a file pointer (i.e., pointer to C's <code>FILE</code>).</p> <p>Creating two <code>IOHandle</code>s from a single file pointer is forbidden.</p>"},{"location":"Std/#parameters_110","title":"Parameters","text":"<ul> <li><code>file_ptr</code> - The file pointer to be wrapped.</li> </ul>"},{"location":"Std/#get_file_ptr","title":"get_file_ptr","text":"<p>Type: <code>Std::IO::IOHandle -&gt; Std::IO Std::Ptr</code></p> <p>Gets pointer to C's <code>FILE</code> value from an <code>IOHandle</code>.</p> <p>If the <code>IOHandle</code> is already closed, the function returns <code>nullptr</code>.</p> <p>NOTE: Do not directly close the file pointer by <code>fclose</code> or other functions. Instead you should close <code>IOHandle</code> by <code>IO::close_file</code>.</p> <p>NOTE: If <code>IO::close</code> is called while using the <code>Ptr</code> obtained by this function, the <code>Ptr</code> becomes invalid and may cause undefined behavior.</p>"},{"location":"Std/#parameters_111","title":"Parameters","text":"<ul> <li><code>handle</code> - The IOHandle to get the file pointer from.</li> </ul>"},{"location":"Std/#namespace-stditerator","title":"namespace Std::Iterator","text":""},{"location":"Std/#advance","title":"advance","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option (iter, Std::Iterator::Item iter)</code></p>"},{"location":"Std/#append_1","title":"append","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = a] i2 -&gt; i1 -&gt; Std::Iterator::AppendIterator i1 i2</code></p> <p>Append two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.append(iter2)</code> appends <code>iter2</code> after <code>iter1</code>, <code>append(iter1, iter2)</code> appends iterators in the opposite order.</p>"},{"location":"Std/#parameters_112","title":"Parameters","text":"<ul> <li><code>second</code> - The second iterator.</li> <li><code>first</code> - The first iterator.</li> </ul>"},{"location":"Std/#bang","title":"bang","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Convert any iterator to an array iterator.</p> <p>All elements of the input iterator are collected into an array. Therefore, this function may consume a lot of memory. On the other hand, iteration may be faster by banging.</p>"},{"location":"Std/#parameters_113","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#collect_m","title":"collect_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = m a] iter -&gt; m (Std::Array a)</code></p> <p>Executes monadic actions and collects the results into an array.</p>"},{"location":"Std/#parameters_114","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be collected.</li> </ul>"},{"location":"Std/#count_up","title":"count_up","text":"<p>Type: <code>Std::I64 -&gt; Std::Iterator::CountUpIterator</code></p> <p>Create an iterator that counts up from a number.</p> <p><code>count_up(start)</code> generates an infinite sequence of numbers starting from <code>start</code>.</p>"},{"location":"Std/#parameters_115","title":"Parameters","text":"<ul> <li><code>start</code> - The start of the count.</li> </ul>"},{"location":"Std/#empty_1","title":"empty","text":"<p>Type: <code>Std::Iterator::EmptyIterator a</code></p> <p>An iterator that yields no elements.</p> <p>NOTE: When using this iterator, you may need to specify the type of the iterator explicitly, e.g, <code>(empty : EmptyIterator I64)</code>.</p>"},{"location":"Std/#filter","title":"filter","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Bool) -&gt; i -&gt; Std::Iterator::FilterIterator i a</code></p> <p>Filter the elements of an iterator by a predicate.</p> <p><code>iter.filter(pred)</code> returns an iterator that only yields elements of <code>iter</code> for which <code>pred</code> returns <code>true</code>.</p>"},{"location":"Std/#parameters_116","title":"Parameters","text":"<ul> <li><code>predicate</code> - The predicate function to be applied to each element of the iterator.</li> <li><code>iter</code> - The iterator to be filtered.</li> </ul>"},{"location":"Std/#filter_map","title":"filter_map","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Option b) -&gt; i -&gt; Std::Iterator::FilterMapIterator i a b</code></p> <p>Filter and map the elements of an iterator.</p> <p><code>iter.filter_map(f)</code> returns an iterator that applies <code>f</code> to each element of <code>iter</code> and yields the result if it is <code>some</code>.</p>"},{"location":"Std/#parameters_117","title":"Parameters","text":"<ul> <li><code>f</code> - The function to be applied to each element of the iterator.</li> <li><code>iter</code> - The iterator to be filtered and mapped.</li> </ul>"},{"location":"Std/#flat_map","title":"flat_map","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = b] (a -&gt; i2) -&gt; i1 -&gt; Std::Iterator::FlatMapIterator i1 a i2</code></p> <p>Apply a function to each element of an iterator and flatten the result.</p>"},{"location":"Std/#parameters_118","title":"Parameters","text":"<ul> <li><code>f</code> - The function to be applied to each element of the iterator.</li> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#flatten","title":"flatten","text":"<p>Type: <code>[i2 : Std::Iterator, i1 : Std::Iterator, Std::Iterator::Item i2 = i1] i2 -&gt; Std::Iterator::FlattenIterator i2 i1</code></p> <p>Flatten an iterator of iterators.</p>"},{"location":"Std/#parameters_119","title":"Parameters","text":"<ul> <li><code>iter_iter</code> - The iterator of iterators.</li> </ul>"},{"location":"Std/#fold","title":"fold","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; s) -&gt; iter -&gt; s</code></p> <p>Fold the elements of an iterator from left to right.</p> <p>Conceptually, <code>[a0, a1, a2, ...].to_iter.fold(s, op) = s.op(a0).op(a1).op(a2)...</code>.</p>"},{"location":"Std/#parameters_120","title":"Parameters","text":"<ul> <li><code>s</code> - The initial state.</li> <li><code>body</code> - The function to be called on the pair of an element and the current state.</li> <li><code>iter</code> - The iterator to be folded.</li> </ul>"},{"location":"Std/#fold_m","title":"fold_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; m s) -&gt; iter -&gt; m s</code></p> <p>Fold the elements of an iterator from left to right by monadic action.</p>"},{"location":"Std/#parameters_121","title":"Parameters","text":"<ul> <li><code>s</code> - The initial state.</li> <li><code>body</code> - The function to be called on the pair of an element and the current state.</li> <li><code>iter</code> - The iterator to be folded.</li> </ul>"},{"location":"Std/#from_array","title":"from_array","text":"<p>Type: <code>Std::Array a -&gt; Std::Iterator::ArrayIterator a</code></p> <p>Create an iterator from an array.</p>"},{"location":"Std/#parameters_122","title":"Parameters","text":"<ul> <li><code>array</code> - The array to be converted to an iterator.</li> </ul>"},{"location":"Std/#from_map_1","title":"from_map","text":"<p>Type: <code>(Std::I64 -&gt; a) -&gt; Std::Iterator::MapIterator Std::Iterator::CountUpIterator Std::I64 a</code></p> <p>Create an iterator by a function that returns element at each index.</p>"},{"location":"Std/#parameters_123","title":"Parameters","text":"<ul> <li><code>map</code> - The function that takes an index and returns the element at that index.</li> </ul>"},{"location":"Std/#generate","title":"generate","text":"<p>Type: <code>s -&gt; (s -&gt; Std::Option (s, a)) -&gt; Std::Iterator::StateIterator s a</code></p> <p>Create an iterator that generates elements by the state transition function.</p>"},{"location":"Std/#parameters_124","title":"Parameters","text":"<ul> <li><code>state</code> - The initial state.</li> <li><code>transition</code> - The state transition function that takes the current state and returns the next state and the next element.</li> </ul>"},{"location":"Std/#get_first_1","title":"get_first","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option (Std::Iterator::Item iter)</code></p> <p>Get the first element of an iterator.</p> <p>If the iterator is empty, this function returns <code>none</code>.</p>"},{"location":"Std/#parameters_125","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#get_size_1","title":"get_size","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::I64</code></p> <p>Get the number of elements in an iterator.</p>"},{"location":"Std/#parameters_126","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be counted.</li> </ul>"},{"location":"Std/#get_tail","title":"get_tail","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Option iter</code></p> <p>Get the tail of an iterator.</p> <p>If the iterator is empty, this function returns <code>none</code>.</p>"},{"location":"Std/#parameters_127","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#intersperse","title":"intersperse","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] a -&gt; i -&gt; Std::Iterator::IntersperseIterator i a</code></p> <p>Intersperse an element between elements of an iterator.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", [1, 2, 3].from_array.intersperse(0).to_array, [1, 0, 2, 0, 3]);;\n</code></pre>"},{"location":"Std/#parameters_128","title":"Parameters","text":"<ul> <li><code>sep</code> - The element to be interspersed.</li> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#is_empty_1","title":"is_empty","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; Std::Bool</code></p> <p>Is an iterator empty?</p>"},{"location":"Std/#parameters_129","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#is_equal","title":"is_equal","text":"<p>Type: <code>[iter1 : Std::Iterator, iter2 : Std::Iterator, a : Std::Eq, Std::Iterator::Item iter1 = a, Std::Iterator::Item iter2 = a] iter1 -&gt; iter2 -&gt; Std::Bool</code></p> <p>Compare two iterators by their elements.</p>"},{"location":"Std/#parameters_130","title":"Parameters","text":"<ul> <li><code>iter1</code> - The first iterator to be compared.</li> <li><code>iter2</code> - The second iterator to be compared.</li> </ul>"},{"location":"Std/#loop_iter","title":"loop_iter","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; Std::LoopState s s) -&gt; iter -&gt; s</code></p> <p>Loop over the elements of an iterator.</p> <p>This function is similar to <code>fold</code> but a more general version of it. It allows the user to break out of the loop at any point.</p>"},{"location":"Std/#parameters_131","title":"Parameters","text":"<ul> <li><code>s</code> - The initial state.</li> <li><code>body</code> - The function to be called on the pair of an element and the current state.</li> <li><code>iter</code> - The iterator to be looped.</li> </ul>"},{"location":"Std/#loop_iter_m","title":"loop_iter_m","text":"<p>Type: <code>[m : Std::Monad, iter : Std::Iterator, Std::Iterator::Item iter = a] s -&gt; (a -&gt; s -&gt; m (Std::LoopState s s)) -&gt; iter -&gt; m s</code></p> <p>Loop over the elements of an iterator by monadic action.</p>"},{"location":"Std/#parameters_132","title":"Parameters","text":"<ul> <li><code>s</code> - The initial state.</li> <li><code>body</code> - The function to be called on the pair of an element and the current state.</li> <li><code>iter</code> - The iterator to be looped.</li> </ul>"},{"location":"Std/#map_1","title":"map","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; b) -&gt; i -&gt; Std::Iterator::MapIterator i a b</code></p> <p>Map a function over an iterator.</p> <p><code>iter.map(f)</code> returns an iterator that applies <code>f</code> to each element of <code>iter</code>.</p>"},{"location":"Std/#parameters_133","title":"Parameters","text":"<ul> <li><code>f</code> - The function to be applied to each element of the iterator.</li> <li><code>iter</code> - The iterator to be mapped.</li> </ul>"},{"location":"Std/#pop_first","title":"pop_first","text":"<p>Type: <code>[iter : Std::Iterator] iter -&gt; iter</code></p> <p>Remove the first element of an iterator.</p> <p>If the iterator is empty, this function does nothing.</p>"},{"location":"Std/#parameters_134","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator.</li> </ul>"},{"location":"Std/#product","title":"product","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator, Std::Iterator::Item i1 = a, Std::Iterator::Item i2 = b] i2 -&gt; i1 -&gt; Std::Iterator::ProductIterator i1 i2 a b</code></p> <p>Create an iterator that yields the Cartesian product of two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.product(iter2)</code> yields the Cartesian product, the elements of <code>product(iter2, iter1)</code> are in the opposite order.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", range(1, 4).product(['a', 'b'].from_array).to_array, [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]);;\n</code></pre>"},{"location":"Std/#parameters_135","title":"Parameters","text":"<ul> <li><code>second</code> - The second iterator.</li> <li><code>first</code> - The first iterator.</li> </ul>"},{"location":"Std/#push_front","title":"push_front","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] a -&gt; i -&gt; Std::Iterator::ConsIterator i a</code></p> <p>Push an element to the front of an iterator.</p>"},{"location":"Std/#parameters_136","title":"Parameters","text":"<ul> <li><code>head</code> - The element to be pushed.</li> <li><code>tail</code> - The iterator to be pushed to.</li> </ul>"},{"location":"Std/#range","title":"range","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::RangeIterator</code></p> <p>Create an iterator that generates a range of numbers.</p> <p><code>range(a, b)</code> generates a range of numbers from <code>a</code> to <code>b - 1</code>.</p> <p>If <code>a</code> is greater than or equal to <code>b</code>, the iterator will an infinite sequence of <code>a</code>.</p>"},{"location":"Std/#parameters_137","title":"Parameters","text":"<ul> <li><code>start</code> - The start of the range.</li> <li><code>end</code> - The end of the range.</li> </ul>"},{"location":"Std/#range_step","title":"range_step","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::I64 -&gt; Std::Iterator::RangeStepIterator</code></p> <p>Create an iterator that generates a range of numbers with a step.</p>"},{"location":"Std/#parameters_138","title":"Parameters","text":"<ul> <li><code>start</code> - The start of the range.</li> <li><code>end</code> - The end of the range.</li> <li><code>step</code> - The step of the range.</li> </ul>"},{"location":"Std/#reverse","title":"reverse","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] i -&gt; Std::Iterator::ReverseIterator i a</code></p> <p>Reverses an iterator.</p> <p>NOTE: This function puts all elements of the iterator into an array, so it may consume a lot of memory.</p>"},{"location":"Std/#parameters_139","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be reversed.</li> </ul>"},{"location":"Std/#sum","title":"sum","text":"<p>Type: <code>[iter : Std::Iterator, a : Std::Additive, Std::Iterator::Item iter = a] iter -&gt; a</code></p> <p>Calcculate sum of the elements of an iterator.</p>"},{"location":"Std/#parameters_140","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be summed.</li> </ul>"},{"location":"Std/#take","title":"take","text":"<p>Type: <code>[i : Std::Iterator] Std::I64 -&gt; i -&gt; Std::Iterator::TakeIterator i</code></p> <p>Take the first <code>n</code> elements of an iterator.</p>"},{"location":"Std/#parameters_141","title":"Parameters","text":"<ul> <li><code>n</code> - The number of elements to be taken.</li> <li><code>iter</code> - The iterator to be taken from.</li> </ul>"},{"location":"Std/#take_while","title":"take_while","text":"<p>Type: <code>[i : Std::Iterator, Std::Iterator::Item i = a] (a -&gt; Std::Bool) -&gt; i -&gt; Std::Iterator::TakeWhileIterator i a</code></p> <p>Take elements from an iterator while a predicate holds.</p>"},{"location":"Std/#parameters_142","title":"Parameters","text":"<ul> <li><code>predicate</code> - The predicate function to be applied to each element of the iterator.</li> <li><code>iter</code> - The iterator to be taken from.</li> </ul>"},{"location":"Std/#to_array","title":"to_array","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Array a</code></p> <p>Convert an iterator to an array.</p>"},{"location":"Std/#parameters_143","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be converted.</li> </ul>"},{"location":"Std/#to_dyn","title":"to_dyn","text":"<p>Type: <code>[iter : Std::Iterator, Std::Iterator::Item iter = a] iter -&gt; Std::Iterator::DynIterator a</code></p> <p>Convert an iterator into a dynamic iterator.</p>"},{"location":"Std/#parameters_144","title":"Parameters","text":"<ul> <li><code>iter</code> - The iterator to be converted.</li> </ul>"},{"location":"Std/#zip","title":"zip","text":"<p>Type: <code>[i1 : Std::Iterator, i2 : Std::Iterator] i2 -&gt; i1 -&gt; Std::Iterator::ZipIterator i1 i2</code></p> <p>Zip two iterators.</p> <p>NOTE: Since this function is designed so that <code>iter1.zip(iter2)</code> zips <code>iter1</code> and <code>iter2</code>, the elements of <code>zip(iter2, iter1)</code> are in the opposite order.</p>"},{"location":"Std/#parameters_145","title":"Parameters","text":"<ul> <li><code>second</code> - The second iterator.</li> <li><code>first</code> - The first iterator.</li> </ul>"},{"location":"Std/#namespace-stditeratordyniterator","title":"namespace Std::Iterator::DynIterator","text":""},{"location":"Std/#empty_2","title":"empty","text":"<p>Type: <code>Std::Iterator::DynIterator a</code></p> <p>Creates an empty dynamic iterator.</p>"},{"location":"Std/#namespace-stdlessthan","title":"namespace Std::LessThan","text":""},{"location":"Std/#less_than","title":"less_than","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt; y</code> is translated to <code>less_than(x, y)</code>.</p>"},{"location":"Std/#parameters_146","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#max","title":"max","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; a</code></p> <p>The maximum of two values.</p>"},{"location":"Std/#parameters_147","title":"Parameters","text":"<ul> <li><code>lhs</code> - The first value.</li> <li><code>rhs</code> - The second value.</li> </ul>"},{"location":"Std/#min","title":"min","text":"<p>Type: <code>[a : Std::LessThan] a -&gt; a -&gt; a</code></p> <p>The minimum of two values.</p>"},{"location":"Std/#parameters_148","title":"Parameters","text":"<ul> <li><code>lhs</code> - The first value.</li> <li><code>rhs</code> - The second value.</li> </ul>"},{"location":"Std/#namespace-stdlessthanoreq","title":"namespace Std::LessThanOrEq","text":""},{"location":"Std/#less_than_or_eq","title":"less_than_or_eq","text":"<p>Type: <code>[a : Std::LessThanOrEq] a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt;= y</code> is translated to <code>less_than_or_eq(x, y)</code>.</p>"},{"location":"Std/#parameters_149","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdloopstate","title":"namespace Std::LoopState","text":""},{"location":"Std/#break_m","title":"break_m","text":"<p>Type: <code>[m : Std::Monad] r -&gt; m (Std::LoopState s r)</code></p> <p>Make a break value wrapped in a monad.</p> <p>This is used with <code>loop_m</code> function.</p>"},{"location":"Std/#continue_m","title":"continue_m","text":"<p>Type: <code>[m : Std::Monad] s -&gt; m (Std::LoopState s r)</code></p> <p>Make a continue value wrapped in a monad.</p> <p>This is used with <code>loop_m</code> function.</p>"},{"location":"Std/#namespace-stdmonad","title":"namespace Std::Monad","text":""},{"location":"Std/#bind","title":"bind","text":"<p>Type: <code>[m : Std::Monad] (a -&gt; m b) -&gt; m a -&gt; m b</code></p> <p>Evaluate a monadic action, and pass the result to the next action.</p>"},{"location":"Std/#parameters_150","title":"Parameters","text":"<ul> <li><code>continuation</code> - The following action.</li> <li><code>action</code> - The first action.</li> </ul>"},{"location":"Std/#flatten_1","title":"flatten","text":"<p>Type: <code>[m : Std::Monad] m (m a) -&gt; m a</code></p> <p>Flattens a nested monadic action.</p>"},{"location":"Std/#parameters_151","title":"Parameters","text":"<ul> <li><code>nested_monad</code></li> </ul>"},{"location":"Std/#pure","title":"pure","text":"<p>Type: <code>[m : Std::Monad] a -&gt; m a</code></p> <p>Creates a pure monadic action which just returns a specified value.</p>"},{"location":"Std/#parameters_152","title":"Parameters","text":"<ul> <li><code>value</code></li> </ul>"},{"location":"Std/#unless","title":"unless","text":"<p>Type: <code>[m : Std::Monad] Std::Bool -&gt; m () -&gt; m ()</code></p> <p><code>unless(cond, act)</code> where <code>act</code> is a monadic value which returns <code>()</code> perfoms <code>act</code> only when <code>cond</code> is false.</p>"},{"location":"Std/#parameters_153","title":"Parameters","text":"<ul> <li><code>condition</code></li> <li><code>action</code></li> </ul>"},{"location":"Std/#when","title":"when","text":"<p>Type: <code>[m : Std::Monad] Std::Bool -&gt; m () -&gt; m ()</code></p> <p><code>when(cond, act)</code> where <code>act</code> is a monadic value which returns <code>()</code> perfoms <code>act</code> only when <code>cond</code> is true.</p>"},{"location":"Std/#parameters_154","title":"Parameters","text":"<ul> <li><code>condition</code></li> <li><code>action</code></li> </ul>"},{"location":"Std/#namespace-stdmul","title":"namespace Std::Mul","text":""},{"location":"Std/#mul","title":"mul","text":"<p>Type: <code>[a : Std::Mul] a -&gt; a -&gt; a</code></p> <p>Multiplies a value by another value. An expression <code>x * y</code> is translated to <code>mul(x, y)</code>.</p>"},{"location":"Std/#parameters_155","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdneg","title":"namespace Std::Neg","text":""},{"location":"Std/#neg","title":"neg","text":"<p>Type: <code>[a : Std::Neg] a -&gt; a</code></p> <p>Negates a value. An expression <code>-x</code> is translated to <code>neg(x)</code>.</p>"},{"location":"Std/#namespace-stdnot","title":"namespace Std::Not","text":""},{"location":"Std/#not","title":"not","text":"<p>Type: <code>[a : Std::Not] a -&gt; a</code></p> <p>Logical NOT of a value. An expression <code>!x</code> is translated to <code>not(x)</code>.</p>"},{"location":"Std/#namespace-stdoption","title":"namespace Std::Option","text":""},{"location":"Std/#as_some_or","title":"as_some_or","text":"<p>Type: <code>a -&gt; Std::Option a -&gt; a</code></p> <p>Unwrap an option value if it is <code>some</code>, or returns given default value if it is <code>none</code>.</p>"},{"location":"Std/#parameters_156","title":"Parameters","text":"<ul> <li><code>default</code> - The default value to be returned if the option is <code>none</code>.</li> <li><code>opt</code> - The option value to be unwrapped.</li> </ul>"},{"location":"Std/#map_or","title":"map_or","text":"<p>Type: <code>b -&gt; (a -&gt; b) -&gt; Std::Option a -&gt; b</code></p> <p>Returns the provided default value if the option is none, or applies a function to the contained value if the option is some.</p>"},{"location":"Std/#parameters_157","title":"Parameters","text":"<ul> <li><code>default</code> - The default value to be returned if the option is <code>none</code>.</li> <li><code>f</code> - The function to be applied to the contained value if the option is <code>some</code>.</li> </ul>"},{"location":"Std/#to_iter_1","title":"to_iter","text":"<p>Type: <code>Std::Option a -&gt; Std::Option::OptionIterator (Std::Option a)</code></p> <p>Converts an option into an iterator.</p>"},{"location":"Std/#namespace-stdptr","title":"namespace Std::Ptr","text":""},{"location":"Std/#add_offset","title":"add_offset","text":"<p>Type: <code>Std::I64 -&gt; Std::Ptr -&gt; Std::Ptr</code></p> <p>Adds an offset to a pointer.</p>"},{"location":"Std/#parameters_158","title":"Parameters","text":"<ul> <li><code>offset</code></li> <li><code>ptr</code></li> </ul>"},{"location":"Std/#subtract_ptr","title":"subtract_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::Ptr -&gt; Std::I64</code></p> <p>Subtracts two pointers.</p> <p>Note that <code>x.subtract_ptr(y)</code> calculates <code>x - y</code>, so <code>subtract_ptr(x, y)</code> calculates <code>y - x</code>.</p>"},{"location":"Std/#parameters_159","title":"Parameters","text":"<ul> <li><code>rhs</code></li> <li><code>lhs</code></li> </ul>"},{"location":"Std/#namespace-stdpunchedarray","title":"namespace Std::PunchedArray","text":""},{"location":"Std/#plug_in","title":"plug_in","text":"<p>Type: <code>a -&gt; Std::PunchedArray a -&gt; Std::Array a</code></p> <p>Plug in an element to a punched array to get back an array.</p>"},{"location":"Std/#parameters_160","title":"Parameters","text":"<ul> <li><code>element</code> - The element to be plugged in.</li> <li><code>parray</code> - The punched array to be plugged in.</li> </ul>"},{"location":"Std/#unsafe_punch","title":"unsafe_punch","text":"<p>Type: <code>Std::I64 -&gt; Std::Array a -&gt; (Std::PunchedArray a, a)</code></p> <p>Creates a punched array by moving out the element at the specified index.</p> <p>NOTE: this function assumes that the given array is unique WITHOUT CHECKING. The uniqueness of the array is ensured in the <code>Array::act</code> function.</p>"},{"location":"Std/#parameters_161","title":"Parameters","text":"<ul> <li><code>i</code> - The index of the element to be punched.</li> <li><code>array</code> - The array to be punched.</li> </ul>"},{"location":"Std/#namespace-stdrem","title":"namespace Std::Rem","text":""},{"location":"Std/#rem","title":"rem","text":"<p>Type: <code>[a : Std::Rem] a -&gt; a -&gt; a</code></p> <p>Calculate remainder of a value dividing another value. An expression <code>x % y</code> is translated to <code>rem(x, y)</code>.</p>"},{"location":"Std/#parameters_162","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdresult","title":"namespace Std::Result","text":""},{"location":"Std/#unwrap","title":"unwrap","text":"<p>Type: <code>Std::Result e o -&gt; o</code></p> <p>Returns the containing value if the value is ok, or otherwise aborts the program.</p>"},{"location":"Std/#parameters_163","title":"Parameters","text":"<ul> <li><code>res</code> - The result value to be unwrapped.</li> </ul>"},{"location":"Std/#namespace-stdstring","title":"namespace Std::String","text":""},{"location":"Std/#borrow_c_str","title":"borrow_c_str","text":"<p>Type: <code>(Std::Ptr -&gt; a) -&gt; Std::String -&gt; a</code></p> <p>Call a function with a null-terminated C string.</p>"},{"location":"Std/#parameters_164","title":"Parameters","text":"<ul> <li><code>borrower</code> - The function to be called with the C string.</li> <li><code>str</code> - The string.</li> </ul>"},{"location":"Std/#borrow_c_str_io","title":"borrow_c_str_io","text":"<p>Type: <code>(Std::Ptr -&gt; Std::IO a) -&gt; Std::String -&gt; Std::IO a</code></p> <p>Call an IO action with a null-terminated C string.</p>"},{"location":"Std/#parameters_165","title":"Parameters","text":"<ul> <li><code>borrower</code> - The IO action to be called with the C string.</li> <li><code>str</code> - The string.</li> </ul>"},{"location":"Std/#concat","title":"concat","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String</code></p> <p>Concatenate two strings.</p> <p>Note: Since <code>s1.concat(s2)</code> puts <code>s2</code> after <code>s1</code>, <code>concat(lhs, rhs)</code> puts <code>lhs</code> after <code>rhs</code>.</p>"},{"location":"Std/#parameters_166","title":"Parameters","text":"<ul> <li><code>first</code> - The first string.</li> <li><code>second</code> - The second string.</li> </ul>"},{"location":"Std/#concat_iter","title":"concat_iter","text":"<p>Type: <code>[strs : Std::Iterator, Std::Iterator::Item strs = Std::String] strs -&gt; Std::String</code></p> <p>Concatenate an iterator of strings.</p>"},{"location":"Std/#parameters_167","title":"Parameters","text":"<ul> <li><code>iter_strs</code> - The iterator of strings.</li> </ul>"},{"location":"Std/#empty_3","title":"empty","text":"<p>Type: <code>Std::I64 -&gt; Std::String</code></p> <p>Create an empty string with a given capacity.</p>"},{"location":"Std/#parameters_168","title":"Parameters","text":"<ul> <li><code>capacity</code> - The capacity of the string to be created.</li> </ul>"},{"location":"Std/#find","title":"find","text":"<p>Type: <code>Std::String -&gt; Std::I64 -&gt; Std::String -&gt; Std::Option Std::I64</code></p> <p><code>str.find(token, start_idx)</code> finds the index where <code>token</code> firstly appears in <code>str</code>, starting from <code>start_idx</code>.</p> <p>Note that this function basically returns a number less than or equal to <code>start_idx</code>, but there is an exception: <code>str.find(\"\", start_idx)</code> with <code>start_idx &gt;= str.get_size</code> returns <code>str.get_size</code>, not <code>start_idx</code>.</p>"},{"location":"Std/#parameters_169","title":"Parameters","text":"<ul> <li><code>token</code> - The token to be searched.</li> <li><code>start_idx</code> - The index to start searching from.</li> <li><code>str</code> - The string to be searched.</li> </ul>"},{"location":"Std/#from_u8","title":"from_U8","text":"<p>Type: <code>Std::U8 -&gt; Std::String</code></p> <p>Creates a string from a byte.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"\", String::from_U8('a'), \"a\");;\nassert_eq(|_|\"\", String::from_U8('\\x00'), \"\");;\n</code></pre>"},{"location":"Std/#parameters_170","title":"Parameters","text":"<ul> <li><code>byte</code> - The byte to be converted.</li> </ul>"},{"location":"Std/#get_bytes","title":"get_bytes","text":"<p>Type: <code>Std::String -&gt; Std::Array Std::U8</code></p> <p>Gets the byte array of a string, containing null-terminator.</p>"},{"location":"Std/#parameters_171","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#get_first_byte","title":"get_first_byte","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U8</code></p> <p>Gets the first byte of a string. Returns none if the string is empty.</p>"},{"location":"Std/#parameters_172","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#get_last_byte","title":"get_last_byte","text":"<p>Type: <code>Std::String -&gt; Std::Option Std::U8</code></p> <p>Gets the last byte of a string. Returns none if the string is empty.</p>"},{"location":"Std/#parameters_173","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#get_size_2","title":"get_size","text":"<p>Type: <code>Std::String -&gt; Std::I64</code></p> <p>Gets the length of a string.</p>"},{"location":"Std/#parameters_174","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#get_sub_1","title":"get_sub","text":"<p>Type: <code>Std::I64 -&gt; Std::I64 -&gt; Std::String -&gt; Std::String</code></p> <p><code>String</code> version of <code>Array::get_sub</code>.</p>"},{"location":"Std/#parameters_175","title":"Parameters","text":"<ul> <li><code>start</code> - The start index of the substring.</li> <li><code>end</code> - The end index of the substring.</li> </ul>"},{"location":"Std/#is_empty_2","title":"is_empty","text":"<p>Type: <code>Std::String -&gt; Std::Bool</code></p> <p>Returns if the string is empty or not.</p>"},{"location":"Std/#parameters_176","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be checked.</li> </ul>"},{"location":"Std/#join","title":"join","text":"<p>Type: <code>[ss : Std::Iterator, Std::Iterator::Item ss = Std::String] Std::String -&gt; ss -&gt; Std::String</code></p> <p>Joins (an iterator of) strings by a separator.</p>"},{"location":"Std/#parameters_177","title":"Parameters","text":"<ul> <li><code>sep</code> - The separator to be used for joining.</li> <li><code>iter_strs</code> - The iterator of strings to be joined.</li> </ul>"},{"location":"Std/#pop_back_byte","title":"pop_back_byte","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes the last byte.</p> <p>If the string is empty, this function does nothing.</p>"},{"location":"Std/#parameters_178","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#split","title":"split","text":"<p>Type: <code>Std::String -&gt; Std::String -&gt; Std::String::StringSplitIterator</code></p> <p><code>str.split(sep)</code> splits <code>str</code> by <code>sep</code> into an iterator.</p> <p>Example:</p> <pre><code>assert_eq(|_|\"Ex. 1\", \"ab,c,\".split(\",\").to_array, [\"ab\", \"c\", \"\"]);;\nassert_eq(|_|\"Ex. 2\", \"abc\".split(\",\").to_array, [\"abc\"]);;\nassert_eq(|_|\"Ex. 3\", \"abc\".split(\"\").to_array, [\"a\", \"b\", \"c\"]);; // Special behavior when the separator is empty.\n</code></pre>"},{"location":"Std/#parameters_179","title":"Parameters","text":"<ul> <li><code>sep</code> - The separator to be used for splitting.</li> <li><code>str</code> - The string to be split.</li> </ul>"},{"location":"Std/#strip_first_bytes","title":"strip_first_bytes","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; Std::String</code></p> <p>Removes the first byte of a string while it satisifies the specified condition.</p>"},{"location":"Std/#parameters_180","title":"Parameters","text":"<ul> <li><code>cond</code> - The condition for the byte to be removed.</li> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#strip_first_spaces","title":"strip_first_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes leading whitespace characters.</p>"},{"location":"Std/#parameters_181","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#strip_last_bytes","title":"strip_last_bytes","text":"<p>Type: <code>(Std::U8 -&gt; Std::Bool) -&gt; Std::String -&gt; Std::String</code></p> <p>Removes the last byte of a string while it satisifies the specified condition.</p>"},{"location":"Std/#parameters_182","title":"Parameters","text":"<ul> <li><code>cond</code> - The condition for the byte to be removed.</li> </ul>"},{"location":"Std/#strip_last_newlines","title":"strip_last_newlines","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes newlines and carriage returns at the end of the string.</p>"},{"location":"Std/#parameters_183","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#strip_last_spaces","title":"strip_last_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Removes trailing whitespace characters.</p>"},{"location":"Std/#parameters_184","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#strip_spaces","title":"strip_spaces","text":"<p>Type: <code>Std::String -&gt; Std::String</code></p> <p>Strips leading and trailing whitespace characters.</p>"},{"location":"Std/#parameters_185","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be modified.</li> </ul>"},{"location":"Std/#unsafe_from_c_str_ptr","title":"unsafe_from_c_str_ptr","text":"<p>Type: <code>Std::Ptr -&gt; Std::String</code></p> <p>Create a <code>String</code> from a pointer to a null-terminated C string.</p> <p>If the pointer is not pointing to a valid null-terminated C string, this function cause undefined behavior.</p>"},{"location":"Std/#parameters_186","title":"Parameters","text":"<ul> <li><code>ptr</code> - The pointer to a null-terminated C string.</li> </ul>"},{"location":"Std/#namespace-stdsub","title":"namespace Std::Sub","text":""},{"location":"Std/#sub","title":"sub","text":"<p>Type: <code>[a : Std::Sub] a -&gt; a -&gt; a</code></p> <p>Subtracts a value from another value. An expression <code>x - y</code> is translated to <code>sub(x, y)</code>.</p>"},{"location":"Std/#parameters_187","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#namespace-stdtobytes","title":"namespace Std::ToBytes","text":""},{"location":"Std/#to_bytes","title":"to_bytes","text":"<p>Type: <code>[a : Std::ToBytes] a -&gt; Std::Array Std::U8</code></p>"},{"location":"Std/#namespace-stdtostring","title":"namespace Std::ToString","text":""},{"location":"Std/#to_string","title":"to_string","text":"<p>Type: <code>[a : Std::ToString] a -&gt; Std::String</code></p>"},{"location":"Std/#namespace-stdu16","title":"namespace Std::U16","text":""},{"location":"Std/#bit_and_4","title":"bit_and","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_188","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_4","title":"bit_or","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_189","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_4","title":"bit_xor","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_190","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_4","title":"maximum","text":"<p>Type: <code>Std::U16</code></p>"},{"location":"Std/#minimum_4","title":"minimum","text":"<p>Type: <code>Std::U16</code></p>"},{"location":"Std/#shift_left_4","title":"shift_left","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_191","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_4","title":"shift_right","text":"<p>Type: <code>Std::U16 -&gt; Std::U16 -&gt; Std::U16</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_192","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_6","title":"to_CChar","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_6","title":"to_CDouble","text":"<p>Type: <code>Std::U16 -&gt; Std::F64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_6","title":"to_CFloat","text":"<p>Type: <code>Std::U16 -&gt; Std::F32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_6","title":"to_CInt","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_6","title":"to_CLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_6","title":"to_CLongLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_6","title":"to_CShort","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_6","title":"to_CSizeT","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_6","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_6","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_6","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_6","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_6","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U16 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U16</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_6","title":"to_F32","text":"<p>Type: <code>Std::U16 -&gt; Std::F32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_6","title":"to_F64","text":"<p>Type: <code>Std::U16 -&gt; Std::F64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_6","title":"to_I16","text":"<p>Type: <code>Std::U16 -&gt; Std::I16</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_6","title":"to_I32","text":"<p>Type: <code>Std::U16 -&gt; Std::I32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_6","title":"to_I64","text":"<p>Type: <code>Std::U16 -&gt; Std::I64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_6","title":"to_I8","text":"<p>Type: <code>Std::U16 -&gt; Std::I8</code></p> <p>Casts a value of <code>U16</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_6","title":"to_U16","text":"<p>Type: <code>Std::U16 -&gt; Std::U16</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_6","title":"to_U32","text":"<p>Type: <code>Std::U16 -&gt; Std::U32</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_6","title":"to_U64","text":"<p>Type: <code>Std::U16 -&gt; Std::U64</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_6","title":"to_U8","text":"<p>Type: <code>Std::U16 -&gt; Std::U8</code></p> <p>Casts a value of <code>U16</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu32","title":"namespace Std::U32","text":""},{"location":"Std/#bit_and_5","title":"bit_and","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_193","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_5","title":"bit_or","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_194","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_5","title":"bit_xor","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_195","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_5","title":"maximum","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Std/#minimum_5","title":"minimum","text":"<p>Type: <code>Std::U32</code></p>"},{"location":"Std/#shift_left_5","title":"shift_left","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_196","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_5","title":"shift_right","text":"<p>Type: <code>Std::U32 -&gt; Std::U32 -&gt; Std::U32</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_197","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_7","title":"to_CChar","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_7","title":"to_CDouble","text":"<p>Type: <code>Std::U32 -&gt; Std::F64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_7","title":"to_CFloat","text":"<p>Type: <code>Std::U32 -&gt; Std::F32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_7","title":"to_CInt","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_7","title":"to_CLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_7","title":"to_CLongLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_7","title":"to_CShort","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_7","title":"to_CSizeT","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_7","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_7","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_7","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_7","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_7","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U32 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U32</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_7","title":"to_F32","text":"<p>Type: <code>Std::U32 -&gt; Std::F32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_7","title":"to_F64","text":"<p>Type: <code>Std::U32 -&gt; Std::F64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_7","title":"to_I16","text":"<p>Type: <code>Std::U32 -&gt; Std::I16</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_7","title":"to_I32","text":"<p>Type: <code>Std::U32 -&gt; Std::I32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_7","title":"to_I64","text":"<p>Type: <code>Std::U32 -&gt; Std::I64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_7","title":"to_I8","text":"<p>Type: <code>Std::U32 -&gt; Std::I8</code></p> <p>Casts a value of <code>U32</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_7","title":"to_U16","text":"<p>Type: <code>Std::U32 -&gt; Std::U16</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_7","title":"to_U32","text":"<p>Type: <code>Std::U32 -&gt; Std::U32</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_7","title":"to_U64","text":"<p>Type: <code>Std::U32 -&gt; Std::U64</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_7","title":"to_U8","text":"<p>Type: <code>Std::U32 -&gt; Std::U8</code></p> <p>Casts a value of <code>U32</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu64","title":"namespace Std::U64","text":""},{"location":"Std/#bit_and_6","title":"bit_and","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_198","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_6","title":"bit_or","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_199","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_6","title":"bit_xor","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_200","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_6","title":"maximum","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Std/#minimum_6","title":"minimum","text":"<p>Type: <code>Std::U64</code></p>"},{"location":"Std/#shift_left_6","title":"shift_left","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_201","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_6","title":"shift_right","text":"<p>Type: <code>Std::U64 -&gt; Std::U64 -&gt; Std::U64</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_202","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_8","title":"to_CChar","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_8","title":"to_CDouble","text":"<p>Type: <code>Std::U64 -&gt; Std::F64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_8","title":"to_CFloat","text":"<p>Type: <code>Std::U64 -&gt; Std::F32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_8","title":"to_CInt","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_8","title":"to_CLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_8","title":"to_CLongLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_8","title":"to_CShort","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_8","title":"to_CSizeT","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_8","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_8","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_8","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_8","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_8","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U64 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U64</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_8","title":"to_F32","text":"<p>Type: <code>Std::U64 -&gt; Std::F32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_8","title":"to_F64","text":"<p>Type: <code>Std::U64 -&gt; Std::F64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_8","title":"to_I16","text":"<p>Type: <code>Std::U64 -&gt; Std::I16</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_8","title":"to_I32","text":"<p>Type: <code>Std::U64 -&gt; Std::I32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_8","title":"to_I64","text":"<p>Type: <code>Std::U64 -&gt; Std::I64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_8","title":"to_I8","text":"<p>Type: <code>Std::U64 -&gt; Std::I8</code></p> <p>Casts a value of <code>U64</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_8","title":"to_U16","text":"<p>Type: <code>Std::U64 -&gt; Std::U16</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_8","title":"to_U32","text":"<p>Type: <code>Std::U64 -&gt; Std::U32</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_8","title":"to_U64","text":"<p>Type: <code>Std::U64 -&gt; Std::U64</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_8","title":"to_U8","text":"<p>Type: <code>Std::U64 -&gt; Std::U8</code></p> <p>Casts a value of <code>U64</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdu8","title":"namespace Std::U8","text":""},{"location":"Std/#bit_and_7","title":"bit_and","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise AND of two values.</p>"},{"location":"Std/#parameters_203","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_or_7","title":"bit_or","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise OR of two values.</p>"},{"location":"Std/#parameters_204","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#bit_xor_7","title":"bit_xor","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p>Calculates bitwise XOR of two values.</p>"},{"location":"Std/#parameters_205","title":"Parameters","text":"<ul> <li><code>x</code> - The first value.</li> <li><code>y</code> - The second value.</li> </ul>"},{"location":"Std/#maximum_7","title":"maximum","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Std/#minimum_7","title":"minimum","text":"<p>Type: <code>Std::U8</code></p>"},{"location":"Std/#shift_left_7","title":"shift_left","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p><code>v.shift_left(bits)</code> shifts <code>v</code> to left by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_206","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#shift_right_7","title":"shift_right","text":"<p>Type: <code>Std::U8 -&gt; Std::U8 -&gt; Std::U8</code></p> <p><code>v.shift_right(bits)</code> shifts <code>v</code> to right by <code>bits</code> bits.</p>"},{"location":"Std/#parameters_207","title":"Parameters","text":"<ul> <li><code>bits</code> - The number of bits to shift.</li> <li><code>v</code> - The value to shift.</li> </ul>"},{"location":"Std/#to_cchar_9","title":"to_CChar","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CChar</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CChar</code>.</p>"},{"location":"Std/#to_cdouble_9","title":"to_CDouble","text":"<p>Type: <code>Std::U8 -&gt; Std::F64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CDouble</code>.</p>"},{"location":"Std/#to_cfloat_9","title":"to_CFloat","text":"<p>Type: <code>Std::U8 -&gt; Std::F32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CFloat</code>.</p>"},{"location":"Std/#to_cint_9","title":"to_CInt","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CInt</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CInt</code>.</p>"},{"location":"Std/#to_clong_9","title":"to_CLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CLong</code>.</p>"},{"location":"Std/#to_clonglong_9","title":"to_CLongLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CLongLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CLongLong</code>.</p>"},{"location":"Std/#to_cshort_9","title":"to_CShort","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CShort</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CShort</code>.</p>"},{"location":"Std/#to_csizet_9","title":"to_CSizeT","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CSizeT</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CSizeT</code>.</p>"},{"location":"Std/#to_cunsignedchar_9","title":"to_CUnsignedChar","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedChar</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedChar</code>.</p>"},{"location":"Std/#to_cunsignedint_9","title":"to_CUnsignedInt","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedInt</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedInt</code>.</p>"},{"location":"Std/#to_cunsignedlong_9","title":"to_CUnsignedLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedLong</code>.</p>"},{"location":"Std/#to_cunsignedlonglong_9","title":"to_CUnsignedLongLong","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedLongLong</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedLongLong</code>.</p>"},{"location":"Std/#to_cunsignedshort_9","title":"to_CUnsignedShort","text":"<p>Type: <code>Std::U8 -&gt; Std::FFI::CUnsignedShort</code></p> <p>Casts a value of <code>U8</code> into a value of <code>CUnsignedShort</code>.</p>"},{"location":"Std/#to_f32_9","title":"to_F32","text":"<p>Type: <code>Std::U8 -&gt; Std::F32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>F32</code>.</p>"},{"location":"Std/#to_f64_9","title":"to_F64","text":"<p>Type: <code>Std::U8 -&gt; Std::F64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>F64</code>.</p>"},{"location":"Std/#to_i16_9","title":"to_I16","text":"<p>Type: <code>Std::U8 -&gt; Std::I16</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I16</code>.</p>"},{"location":"Std/#to_i32_9","title":"to_I32","text":"<p>Type: <code>Std::U8 -&gt; Std::I32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I32</code>.</p>"},{"location":"Std/#to_i64_9","title":"to_I64","text":"<p>Type: <code>Std::U8 -&gt; Std::I64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I64</code>.</p>"},{"location":"Std/#to_i8_9","title":"to_I8","text":"<p>Type: <code>Std::U8 -&gt; Std::I8</code></p> <p>Casts a value of <code>U8</code> into a value of <code>I8</code>.</p>"},{"location":"Std/#to_u16_9","title":"to_U16","text":"<p>Type: <code>Std::U8 -&gt; Std::U16</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U16</code>.</p>"},{"location":"Std/#to_u32_9","title":"to_U32","text":"<p>Type: <code>Std::U8 -&gt; Std::U32</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U32</code>.</p>"},{"location":"Std/#to_u64_9","title":"to_U64","text":"<p>Type: <code>Std::U8 -&gt; Std::U64</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U64</code>.</p>"},{"location":"Std/#to_u8_9","title":"to_U8","text":"<p>Type: <code>Std::U8 -&gt; Std::U8</code></p> <p>Casts a value of <code>U8</code> into a value of <code>U8</code>.</p>"},{"location":"Std/#namespace-stdzero","title":"namespace Std::Zero","text":""},{"location":"Std/#zero","title":"zero","text":"<p>Type: <code>[a : Std::Zero] a</code></p>"},{"location":"Std/#types-and-aliases","title":"Types and aliases","text":""},{"location":"Std/#namespace-std_1","title":"namespace Std","text":""},{"location":"Std/#array","title":"Array","text":"<p>Defined as: <code>type Array a = box { built-in }</code></p> <p>The type of variable length arrays. This is a boxed type.</p>"},{"location":"Std/#arrow","title":"Arrow","text":"<p>Defined as: <code>type Arrow a b = unbox { built-in }</code></p> <p><code>Arrow a b</code> represents the type of a function that takes a value of type <code>a</code> and returns a value of type <code>b</code>. Usually written as <code>a -&gt; b</code>.</p>"},{"location":"Std/#bool","title":"Bool","text":"<p>Defined as: <code>type Bool = unbox { built-in }</code></p> <p>The type of boolean values.</p>"},{"location":"Std/#box","title":"Box","text":"<p>Defined as: <code>type Box a = box struct { ...fields... }</code></p> <p>Boxed wrapper for a type.</p>"},{"location":"Std/#field-value","title":"field <code>value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#errmsg","title":"ErrMsg","text":"<p>Defined as: <code>type ErrMsg = Std::String</code></p> <p>A type (alias) for error message.</p>"},{"location":"Std/#f32","title":"F32","text":"<p>Defined as: <code>type F32 = unbox { built-in }</code></p> <p>The type of 32-bit floating point values.</p>"},{"location":"Std/#f64","title":"F64","text":"<p>Defined as: <code>type F64 = unbox { built-in }</code></p> <p>The type of 64-bit floating point values.</p>"},{"location":"Std/#i16","title":"I16","text":"<p>Defined as: <code>type I16 = unbox { built-in }</code></p> <p>The type of 16-bit signed integers.</p>"},{"location":"Std/#i32","title":"I32","text":"<p>Defined as: <code>type I32 = unbox { built-in }</code></p> <p>The type of 32-bit signed integers.</p>"},{"location":"Std/#i64","title":"I64","text":"<p>Defined as: <code>type I64 = unbox { built-in }</code></p> <p>The type of 64-bit signed integers.</p>"},{"location":"Std/#i8","title":"I8","text":"<p>Defined as: <code>type I8 = unbox { built-in }</code></p> <p>The type of 8-bit signed integers.</p>"},{"location":"Std/#io","title":"IO","text":"<p>Defined as: <code>type IO a = unbox struct { ...fields... }</code></p> <p><code>IO a</code> is a type representing I/O actions which return values of type <code>a</code>.</p>"},{"location":"Std/#field-runner","title":"field <code>runner</code>","text":"<p>Type: <code>Std::IO::IOState -&gt; (Std::IO::IOState, a)</code></p>"},{"location":"Std/#lazy","title":"Lazy","text":"<p>Defined as: <code>type Lazy a = () -&gt; a</code></p> <p>The type of lazily generated values.</p> <p>You can create a lazy value by <code>|_| (...an expression to generate the value...)</code>, and you can evaluate a lazy value <code>v</code> by <code>v()</code>.</p>"},{"location":"Std/#loopstate","title":"LoopState","text":"<p>Defined as: <code>type LoopState s r = unbox union { ...variants... }</code></p> <p>A union type with variants <code>continue</code> and <code>break</code>.</p> <p>This type is used to represent the result of a loop body function passed to <code>Std::loop</code> or other similar functions.</p>"},{"location":"Std/#variant-continue","title":"variant <code>continue</code>","text":"<p>Type: <code>s</code></p>"},{"location":"Std/#variant-break","title":"variant <code>break</code>","text":"<p>Type: <code>r</code></p>"},{"location":"Std/#option","title":"Option","text":"<p>Defined as: <code>type Option a = unbox union { ...variants... }</code></p>"},{"location":"Std/#variant-none","title":"variant <code>none</code>","text":"<p>Type: <code>()</code></p>"},{"location":"Std/#variant-some","title":"variant <code>some</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#path","title":"Path","text":"<p>Defined as: <code>type Path = Std::String</code></p> <p>The type for file path.</p>"},{"location":"Std/#ptr","title":"Ptr","text":"<p>Defined as: <code>type Ptr = unbox { built-in }</code></p> <p>The type of pointers.</p>"},{"location":"Std/#punchedarray","title":"PunchedArray","text":"<p>Defined as: <code>type PunchedArray a = unbox struct { ...fields... }</code></p> <p>The type of punched arrays.</p> <p>A punched array is an array from which a certain element has been removed. This is used in the implementation of <code>Array::act</code>.</p>"},{"location":"Std/#field-_arr","title":"field <code>_arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#field-idx","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#result","title":"Result","text":"<p>Defined as: <code>type Result e o = unbox union { ...variants... }</code></p> <p>A type of result value for a computation that may fail.</p>"},{"location":"Std/#variant-ok","title":"variant <code>ok</code>","text":"<p>Type: <code>o</code></p>"},{"location":"Std/#variant-err","title":"variant <code>err</code>","text":"<p>Type: <code>e</code></p>"},{"location":"Std/#string","title":"String","text":"<p>Defined as: <code>type String = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-_data","title":"field <code>_data</code>","text":"<p>Type: <code>Std::Array Std::U8</code></p>"},{"location":"Std/#tuple0","title":"Tuple0","text":"<p>Defined as: <code>type Tuple0 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#tuple1","title":"Tuple1","text":"<p>Defined as: <code>type Tuple1 t0 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-0","title":"field <code>0</code>","text":"<p>Type: <code>t0</code></p>"},{"location":"Std/#tuple2","title":"Tuple2","text":"<p>Defined as: <code>type Tuple2 t0 t1 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-0_1","title":"field <code>0</code>","text":"<p>Type: <code>t0</code></p>"},{"location":"Std/#field-1","title":"field <code>1</code>","text":"<p>Type: <code>t1</code></p>"},{"location":"Std/#tuple3","title":"Tuple3","text":"<p>Defined as: <code>type Tuple3 t0 t1 t2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-0_2","title":"field <code>0</code>","text":"<p>Type: <code>t0</code></p>"},{"location":"Std/#field-1_1","title":"field <code>1</code>","text":"<p>Type: <code>t1</code></p>"},{"location":"Std/#field-2","title":"field <code>2</code>","text":"<p>Type: <code>t2</code></p>"},{"location":"Std/#u16","title":"U16","text":"<p>Defined as: <code>type U16 = unbox { built-in }</code></p> <p>The type of 16-bit unsigned integers.</p>"},{"location":"Std/#u32","title":"U32","text":"<p>Defined as: <code>type U32 = unbox { built-in }</code></p> <p>The type of 32-bit unsigned integers.</p>"},{"location":"Std/#u64","title":"U64","text":"<p>Defined as: <code>type U64 = unbox { built-in }</code></p> <p>The type of 64-bit unsigned integers.</p>"},{"location":"Std/#u8","title":"U8","text":"<p>Defined as: <code>type U8 = unbox { built-in }</code></p> <p>The type of 8-bit unsinged integers.</p>"},{"location":"Std/#namespace-stdffi_1","title":"namespace Std::FFI","text":""},{"location":"Std/#cchar","title":"CChar","text":"<p>Defined as: <code>type CChar = Std::I8</code></p>"},{"location":"Std/#cdouble","title":"CDouble","text":"<p>Defined as: <code>type CDouble = Std::F64</code></p>"},{"location":"Std/#cfloat","title":"CFloat","text":"<p>Defined as: <code>type CFloat = Std::F32</code></p>"},{"location":"Std/#cint","title":"CInt","text":"<p>Defined as: <code>type CInt = Std::I32</code></p>"},{"location":"Std/#clong","title":"CLong","text":"<p>Defined as: <code>type CLong = Std::I64</code></p>"},{"location":"Std/#clonglong","title":"CLongLong","text":"<p>Defined as: <code>type CLongLong = Std::I64</code></p>"},{"location":"Std/#cshort","title":"CShort","text":"<p>Defined as: <code>type CShort = Std::I16</code></p>"},{"location":"Std/#csizet","title":"CSizeT","text":"<p>Defined as: <code>type CSizeT = Std::U64</code></p>"},{"location":"Std/#cunsignedchar","title":"CUnsignedChar","text":"<p>Defined as: <code>type CUnsignedChar = Std::U8</code></p>"},{"location":"Std/#cunsignedint","title":"CUnsignedInt","text":"<p>Defined as: <code>type CUnsignedInt = Std::U32</code></p>"},{"location":"Std/#cunsignedlong","title":"CUnsignedLong","text":"<p>Defined as: <code>type CUnsignedLong = Std::U64</code></p>"},{"location":"Std/#cunsignedlonglong","title":"CUnsignedLongLong","text":"<p>Defined as: <code>type CUnsignedLongLong = Std::U64</code></p>"},{"location":"Std/#cunsignedshort","title":"CUnsignedShort","text":"<p>Defined as: <code>type CUnsignedShort = Std::U16</code></p>"},{"location":"Std/#destructor","title":"Destructor","text":"<p>Defined as: <code>type Destructor a = box struct { ...fields... }</code></p> <p><code>Destructor a</code> is a wrapper type for <code>a</code>, which can have a destructor function <code>a -&gt; IO a</code>. Just before a value of type <code>Destructor a</code> is dropped, the destructor function is called on the contained value, and the value can be modified by the <code>IO</code> action.</p> <p>This type is used to create a Fix's type that wraps a resource allocated by FFI. In such cases, the destructor release the resource by FFI.</p> <p>NOTE: In the destructor, only IO actions for finalizing the passed value are allowed, and you should not perform other IO actions such as writing standard output.</p> <p>NOTE: Of course, if the value stored in <code>Destructor</code> also exists outside of <code>Destructor</code>, the value still exists in the Fix program even after the destructor function is called, and there is a possibility that the value is used after the destructor function is called.</p>"},{"location":"Std/#field-_value","title":"field <code>_value</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#field-dtor","title":"field <code>dtor</code>","text":"<p>Type: <code>a -&gt; Std::IO a</code></p>"},{"location":"Std/#namespace-stdio_1","title":"namespace Std::IO","text":""},{"location":"Std/#iofail","title":"IOFail","text":"<p>Defined as: <code>type IOFail a = unbox struct { ...fields... }</code></p> <p>The type for I/O actions which may fail.</p>"},{"location":"Std/#field-_data_1","title":"field <code>_data</code>","text":"<p>Type: <code>Std::IO (Std::Result Std::ErrMsg a)</code></p>"},{"location":"Std/#iohandle","title":"IOHandle","text":"<p>Defined as: <code>type IOHandle = unbox struct { ...fields... }</code></p> <p>A handle type for read / write operations on files, stdin, stdout, stderr.</p> <p>You can create <code>IOHandle</code> value by <code>IO::open_file</code>, and close it by <code>IO::close_file</code>. There are also global <code>IO::IOHandle::stdin</code>, <code>IO::IOHandle::stdout</code>, <code>IO::IOHandle::stderr</code>.</p> <p><code>IOHandle</code> is different from C's <code>FILE</code> structure in that it is safe to close it twice. If you try to get a file pointer by <code>file_ptr</code> from a closed <code>IOHandle</code>, you will get <code>nullptr</code>.</p> <p>NOTE: <code>IOHandle</code> is implemented by <code>Destructor</code>, but the destructor function does not close the file pointer. (The destructor function only frees the management memory area.) You should explicitly close the file pointer by <code>IO::close_file</code>.</p>"},{"location":"Std/#field-_data_2","title":"field <code>_data</code>","text":"<p>Type: <code>Std::FFI::Destructor Std::Ptr</code></p>"},{"location":"Std/#iostate","title":"IOState","text":"<p>Defined as: <code>type IOState = unbox { built-in }</code></p> <p>The type of the \"state\"s modified by I/O operations. </p> <p>The type <code>IO a</code> is isomorphic to <code>IOState -&gt; (IOState, a)</code>.</p> <p>Values of type <code>IOState</code> must be used linearly, i.e., each value must be used exactly once and must not be duplicated or discarded.</p> <p>Values of type <code>IOState</code> are generated by the runtime when executing <code>IO</code> actions like <code>main</code> and passed linearly to various places in the program. At some places, <code>IOState</code> values are consumed by <code>FFI_CALL_IOS</code> expressions and new <code>IOState</code> values are generated. When <code>IO</code> actions like <code>main</code> finish, they are consumed by the runtime and disappear.</p> <p>Technically, <code>IOState</code> exists to specify the execution of I/O operations to the optimizer in the compiler.</p>"},{"location":"Std/#namespace-stditerator_1","title":"namespace Std::Iterator","text":""},{"location":"Std/#appenditerator","title":"AppendIterator","text":"<p>Defined as: <code>type AppendIterator i1 i2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1","title":"field <code>iter1</code>","text":"<p>Type: <code>Std::Option i1</code></p>"},{"location":"Std/#field-iter2","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#arrayiterator","title":"ArrayIterator","text":"<p>Defined as: <code>type ArrayIterator a = unbox struct { ...fields... }</code></p> <p>Iterators that yields elements of an array.</p>"},{"location":"Std/#field-arr","title":"field <code>arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#field-idx_1","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#consiterator","title":"ConsIterator","text":"<p>Defined as: <code>type ConsIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-head","title":"field <code>head</code>","text":"<p>Type: <code>Std::Option a</code></p>"},{"location":"Std/#field-tail","title":"field <code>tail</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#countupiterator","title":"CountUpIterator","text":"<p>Defined as: <code>type CountUpIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-next","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#dyniterator","title":"DynIterator","text":"<p>Defined as: <code>type DynIterator a = unbox struct { ...fields... }</code></p> <p>The type of dynamic iterators.</p> <p><code>DynIterator</code> has a field, <code>next</code>, which is a function that returns the next element and the next iterator. Therefore, the process to advance <code>DynIterator</code> can be determined dynamically at runtime, not at compile time.</p> <p>The main advantage of dynamic iterator is that since it has a simple type, <code>DynIterator a</code>, - <code>DynIterator</code> can be instances of traits such as <code>Monad</code>, <code>Eq</code>, etc. - it is possible to return two dynamic iterators with different constructions depending on the branch.</p> <p>However, iterating over <code>DynIterator</code> are much slower than iterating over other iterators provided in this namespace. Therefore, if performance is important, you should avoid using <code>DynIterator</code>. In particular, if you iterate over the same <code>DynIterator</code> multiple times, consider converting it to an <code>ArrayIterator</code> using <code>bang</code> before iterating.</p>"},{"location":"Std/#field-next_1","title":"field <code>next</code>","text":"<p>Type: <code>() -&gt; Std::Option (Std::Iterator::DynIterator a, a)</code></p>"},{"location":"Std/#emptyiterator","title":"EmptyIterator","text":"<p>Defined as: <code>type EmptyIterator a = unbox struct { ...fields... }</code></p> <p>Iterators that yields no elements.</p>"},{"location":"Std/#filteriterator","title":"FilterIterator","text":"<p>Defined as: <code>type FilterIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-pred","title":"field <code>pred</code>","text":"<p>Type: <code>a -&gt; Std::Bool</code></p>"},{"location":"Std/#filtermapiterator","title":"FilterMapIterator","text":"<p>Defined as: <code>type FilterMapIterator i a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_1","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-f","title":"field <code>f</code>","text":"<p>Type: <code>a -&gt; Std::Option b</code></p>"},{"location":"Std/#flatmapiterator","title":"FlatMapIterator","text":"<p>Defined as: <code>type FlatMapIterator i1 a i2 = Std::Iterator::FlattenIterator (Std::Iterator::MapIterator i1 a i2) i2</code></p>"},{"location":"Std/#flatteniterator","title":"FlattenIterator","text":"<p>Defined as: <code>type FlattenIterator i2 i1 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-i2","title":"field <code>i2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#field-i1","title":"field <code>i1</code>","text":"<p>Type: <code>Std::Option i1</code></p>"},{"location":"Std/#intersperseiterator","title":"IntersperseIterator","text":"<p>Defined as: <code>type IntersperseIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_2","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-sep","title":"field <code>sep</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#field-next_is_sep","title":"field <code>next_is_sep</code>","text":"<p>Type: <code>Std::Bool</code></p>"},{"location":"Std/#mapiterator","title":"MapIterator","text":"<p>Defined as: <code>type MapIterator i a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_3","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-f_1","title":"field <code>f</code>","text":"<p>Type: <code>a -&gt; b</code></p>"},{"location":"Std/#productiterator","title":"ProductIterator","text":"<p>Defined as: <code>type ProductIterator i1 i2 a b = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1_1","title":"field <code>iter1</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#field-iter2_1","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#field-e2","title":"field <code>e2</code>","text":"<p>Type: <code>Std::Option b</code></p>"},{"location":"Std/#field-iter1_org","title":"field <code>iter1_org</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#rangeiterator","title":"RangeIterator","text":"<p>Defined as: <code>type RangeIterator = unbox struct { ...fields... }</code></p> <p>Iterators that yields reversed elements of an iterator.</p>"},{"location":"Std/#field-next_2","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-end","title":"field <code>end</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#rangestepiterator","title":"RangeStepIterator","text":"<p>Defined as: <code>type RangeStepIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-next_3","title":"field <code>next</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-end_1","title":"field <code>end</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-step","title":"field <code>step</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#reverseiterator","title":"ReverseIterator","text":"<p>Defined as: <code>type ReverseIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-idx_2","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-arr_1","title":"field <code>arr</code>","text":"<p>Type: <code>Std::Array a</code></p>"},{"location":"Std/#stateiterator","title":"StateIterator","text":"<p>Defined as: <code>type StateIterator s a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-state","title":"field <code>state</code>","text":"<p>Type: <code>Std::Option s</code></p>"},{"location":"Std/#field-transit","title":"field <code>transit</code>","text":"<p>Type: <code>s -&gt; Std::Option (s, a)</code></p>"},{"location":"Std/#takeiterator","title":"TakeIterator","text":"<p>Defined as: <code>type TakeIterator i = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_4","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-n","title":"field <code>n</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#takewhileiterator","title":"TakeWhileIterator","text":"<p>Defined as: <code>type TakeWhileIterator i a = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter_5","title":"field <code>iter</code>","text":"<p>Type: <code>i</code></p>"},{"location":"Std/#field-pred_1","title":"field <code>pred</code>","text":"<p>Type: <code>a -&gt; Std::Bool</code></p>"},{"location":"Std/#zipiterator","title":"ZipIterator","text":"<p>Defined as: <code>type ZipIterator i1 i2 = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-iter1_2","title":"field <code>iter1</code>","text":"<p>Type: <code>i1</code></p>"},{"location":"Std/#field-iter2_2","title":"field <code>iter2</code>","text":"<p>Type: <code>i2</code></p>"},{"location":"Std/#namespace-stdoption_1","title":"namespace Std::Option","text":""},{"location":"Std/#optioniterator","title":"OptionIterator","text":"<p>Defined as: <code>type OptionIterator opt = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-opt","title":"field <code>opt</code>","text":"<p>Type: <code>opt</code></p>"},{"location":"Std/#namespace-stdstring_1","title":"namespace Std::String","text":""},{"location":"Std/#stringsplititerator","title":"StringSplitIterator","text":"<p>Defined as: <code>type StringSplitIterator = unbox struct { ...fields... }</code></p>"},{"location":"Std/#field-idx_3","title":"field <code>idx</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-str","title":"field <code>str</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Std/#field-strlen","title":"field <code>strlen</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#field-sep_1","title":"field <code>sep</code>","text":"<p>Type: <code>Std::String</code></p>"},{"location":"Std/#field-sep_len","title":"field <code>sep_len</code>","text":"<p>Type: <code>Std::I64</code></p>"},{"location":"Std/#traits-and-aliases","title":"Traits and aliases","text":""},{"location":"Std/#namespace-std_2","title":"namespace Std","text":""},{"location":"Std/#trait-a-add","title":"trait <code>a : Add</code>","text":"<p>Trait for infix operator <code>+</code>.</p>"},{"location":"Std/#method-add","title":"method <code>add</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Adds two values. An expression <code>x + y</code> is translated to <code>add(x, y)</code>.</p>"},{"location":"Std/#parameters_208","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-boxed","title":"trait <code>a : Boxed</code>","text":"<p>Marker trait for boxed types.</p> <p>This trait is automatically implemented for all boxed types. Implementing this trait manually is not allowed.</p>"},{"location":"Std/#trait-a-div","title":"trait <code>a : Div</code>","text":"<p>Trait for infix operator <code>/</code>.</p>"},{"location":"Std/#method-div","title":"method <code>div</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Divides a value by another value. An expression <code>x / y</code> is translated to <code>div(x, y)</code>.</p>"},{"location":"Std/#parameters_209","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-eq","title":"trait <code>a : Eq</code>","text":"<p>Trait for infix operator <code>==</code>.</p>"},{"location":"Std/#method-eq","title":"method <code>eq</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Checks equality of two values. An expression <code>x == y</code> is translated to <code>eq(x, y)</code>.</p>"},{"location":"Std/#parameters_210","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-frombytes","title":"trait <code>a : FromBytes</code>","text":""},{"location":"Std/#method-from_bytes","title":"method <code>from_bytes</code>","text":"<p>Type: <code>Std::Array Std::U8 -&gt; Std::Result Std::String a</code></p> <p>Converts a byte array into a value by parsing it.</p>"},{"location":"Std/#parameters_211","title":"Parameters","text":"<ul> <li><code>byte_array</code> - The byte array to be converted.</li> </ul>"},{"location":"Std/#trait-a-fromstring","title":"trait <code>a : FromString</code>","text":""},{"location":"Std/#method-from_string","title":"method <code>from_string</code>","text":"<p>Type: <code>Std::String -&gt; Std::Result Std::String a</code></p> <p>Converts a string into a value by parsing it.</p>"},{"location":"Std/#parameters_212","title":"Parameters","text":"<ul> <li><code>str</code> - The string to be converted.</li> </ul>"},{"location":"Std/#trait-f-f-functor","title":"trait <code>[f : *-&gt;*] f : Functor</code>","text":"<p>The trait for functors.</p>"},{"location":"Std/#method-map","title":"method <code>map</code>","text":"<p>Type: <code>(a -&gt; b) -&gt; f a -&gt; f b</code></p> <p>Applies a function to the value inside the functor.</p>"},{"location":"Std/#parameters_213","title":"Parameters","text":"<ul> <li><code>f</code> - The function to be applied.</li> <li><code>value</code> - The functor value to be transformed.</li> </ul>"},{"location":"Std/#trait-iter-iterator","title":"trait <code>iter : Iterator</code>","text":"<p>The trait of iterators.</p> <p>Iterator is a concept of a sequence of elements that can be iterated. More precisely, an iterator is a type whose data is \"the current state\" and has a method <code>advance</code> which returns the next element and the next state.</p>"},{"location":"Std/#type-item","title":"type <code>Item</code>","text":"<p>Defined as: <code>Item iter</code></p>"},{"location":"Std/#method-advance","title":"method <code>advance</code>","text":"<p>Type: <code>iter -&gt; Std::Option (iter, Std::Iterator::Item iter)</code></p>"},{"location":"Std/#trait-a-lessthan","title":"trait <code>a : LessThan</code>","text":"<p>Trait for infix operator <code>&lt;</code>.</p>"},{"location":"Std/#method-less_than","title":"method <code>less_than</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt; y</code> is translated to <code>less_than(x, y)</code>.</p>"},{"location":"Std/#parameters_214","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-lessthanoreq","title":"trait <code>a : LessThanOrEq</code>","text":"<p>Trait for infix operator <code>&lt;=</code>.</p>"},{"location":"Std/#method-less_than_or_eq","title":"method <code>less_than_or_eq</code>","text":"<p>Type: <code>a -&gt; a -&gt; Std::Bool</code></p> <p>Compares two values. An expression <code>x &lt;= y</code> is translated to <code>less_than_or_eq(x, y)</code>.</p>"},{"location":"Std/#parameters_215","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-m-m-monad","title":"trait <code>[m : *-&gt;*] m : Monad</code>","text":"<p>The trait for monads.</p>"},{"location":"Std/#method-bind","title":"method <code>bind</code>","text":"<p>Type: <code>(a -&gt; m b) -&gt; m a -&gt; m b</code></p> <p>Evaluate a monadic action, and pass the result to the next action.</p>"},{"location":"Std/#parameters_216","title":"Parameters","text":"<ul> <li><code>continuation</code> - The following action.</li> <li><code>action</code> - The first action.</li> </ul>"},{"location":"Std/#method-pure","title":"method <code>pure</code>","text":"<p>Type: <code>a -&gt; m a</code></p> <p>Creates a pure monadic action which just returns a specified value.</p>"},{"location":"Std/#parameters_217","title":"Parameters","text":"<ul> <li><code>value</code></li> </ul>"},{"location":"Std/#trait-a-mul","title":"trait <code>a : Mul</code>","text":"<p>Trait for infix operator <code>*</code>.</p>"},{"location":"Std/#method-mul","title":"method <code>mul</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Multiplies a value by another value. An expression <code>x * y</code> is translated to <code>mul(x, y)</code>.</p>"},{"location":"Std/#parameters_218","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-neg","title":"trait <code>a : Neg</code>","text":"<p>Trait for prefix operator <code>-</code>.</p>"},{"location":"Std/#method-neg","title":"method <code>neg</code>","text":"<p>Type: <code>a -&gt; a</code></p> <p>Negates a value. An expression <code>-x</code> is translated to <code>neg(x)</code>.</p>"},{"location":"Std/#trait-a-not","title":"trait <code>a : Not</code>","text":"<p>Trait for prefix operator <code>!</code>.</p>"},{"location":"Std/#method-not","title":"method <code>not</code>","text":"<p>Type: <code>a -&gt; a</code></p> <p>Logical NOT of a value. An expression <code>!x</code> is translated to <code>not(x)</code>.</p>"},{"location":"Std/#trait-a-rem","title":"trait <code>a : Rem</code>","text":"<p>Trait for infix operator <code>%</code>.</p>"},{"location":"Std/#method-rem","title":"method <code>rem</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Calculate remainder of a value dividing another value. An expression <code>x % y</code> is translated to <code>rem(x, y)</code>.</p>"},{"location":"Std/#parameters_219","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-sub","title":"trait <code>a : Sub</code>","text":"<p>Trait for infix operator <code>-</code>.</p>"},{"location":"Std/#method-sub","title":"method <code>sub</code>","text":"<p>Type: <code>a -&gt; a -&gt; a</code></p> <p>Subtracts a value from another value. An expression <code>x - y</code> is translated to <code>sub(x, y)</code>.</p>"},{"location":"Std/#parameters_220","title":"Parameters","text":"<ul> <li><code>lhs</code></li> <li><code>rhs</code></li> </ul>"},{"location":"Std/#trait-a-tobytes","title":"trait <code>a : ToBytes</code>","text":""},{"location":"Std/#method-to_bytes","title":"method <code>to_bytes</code>","text":"<p>Type: <code>a -&gt; Std::Array Std::U8</code></p>"},{"location":"Std/#trait-a-tostring","title":"trait <code>a : ToString</code>","text":""},{"location":"Std/#method-to_string","title":"method <code>to_string</code>","text":"<p>Type: <code>a -&gt; Std::String</code></p>"},{"location":"Std/#trait-a-zero","title":"trait <code>a : Zero</code>","text":""},{"location":"Std/#method-zero","title":"method <code>zero</code>","text":"<p>Type: <code>a</code></p>"},{"location":"Std/#trait-implementations","title":"Trait implementations","text":""},{"location":"Std/#impl-stdeq","title":"impl <code>() : Std::Eq</code>","text":""},{"location":"Std/#impl-stdtostring","title":"impl <code>() : Std::ToString</code>","text":"<p>Returns \"()\".</p>"},{"location":"Std/#impl-t0-stdeq-t1-stdeq-t0-t1-stdeq","title":"impl <code>[t0 : Std::Eq, t1 : Std::Eq] (t0, t1) : Std::Eq</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthan-t1-stdeq-t1-stdlessthan-t0-t1-stdlessthan","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThan, t1 : Std::Eq, t1 : Std::LessThan] (t0, t1) : Std::LessThan</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthanoreq-t1-stdeq-t1-stdlessthanoreq-t0-t1-stdlessthanoreq","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThanOrEq, t1 : Std::Eq, t1 : Std::LessThanOrEq] (t0, t1) : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-t0-stdtostring-t1-stdtostring-t0-t1-stdtostring","title":"impl <code>[t0 : Std::ToString, t1 : Std::ToString] (t0, t1) : Std::ToString</code>","text":""},{"location":"Std/#impl-t0-stdeq-t1-stdeq-t2-stdeq-t0-t1-t2-stdeq","title":"impl <code>[t0 : Std::Eq, t1 : Std::Eq, t2 : Std::Eq] (t0, t1, t2) : Std::Eq</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthan-t1-stdeq-t1-stdlessthan-t2-stdeq-t2-stdlessthan-t0-t1-t2-stdlessthan","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThan, t1 : Std::Eq, t1 : Std::LessThan, t2 : Std::Eq, t2 : Std::LessThan] (t0, t1, t2) : Std::LessThan</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthanoreq-t1-stdeq-t1-stdlessthanoreq-t2-stdeq-t2-stdlessthanoreq-t0-t1-t2-stdlessthanoreq","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThanOrEq, t1 : Std::Eq, t1 : Std::LessThanOrEq, t2 : Std::Eq, t2 : Std::LessThanOrEq] (t0, t1, t2) : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-t0-stdtostring-t1-stdtostring-t2-stdtostring-t0-t1-t2-stdtostring","title":"impl <code>[t0 : Std::ToString, t1 : Std::ToString, t2 : Std::ToString] (t0, t1, t2) : Std::ToString</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdeq","title":"impl <code>[t0 : Std::Eq] (t0,) : Std::Eq</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthan-t0-stdlessthan","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThan] (t0,) : Std::LessThan</code>","text":""},{"location":"Std/#impl-t0-stdeq-t0-stdlessthanoreq-t0-stdlessthanoreq","title":"impl <code>[t0 : Std::Eq, t0 : Std::LessThanOrEq] (t0,) : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-t0-stdtostring-t0-stdtostring","title":"impl <code>[t0 : Std::ToString] (t0,) : Std::ToString</code>","text":""},{"location":"Std/#impl-stdarray-stdfunctor","title":"impl <code>Std::Array : Std::Functor</code>","text":""},{"location":"Std/#impl-stdarray-stdmonad","title":"impl <code>Std::Array : Std::Monad</code>","text":""},{"location":"Std/#impl-stdarray-a-stdadd","title":"impl <code>Std::Array a : Std::Add</code>","text":"<p>Concatenates two arrays.</p>"},{"location":"Std/#impl-stdarray-a-stdboxed","title":"impl <code>Std::Array a : Std::Boxed</code>","text":""},{"location":"Std/#impl-a-stdeq-stdarray-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Array a : Std::Eq</code>","text":""},{"location":"Std/#impl-a-stdeq-a-stdlessthan-stdarray-a-stdlessthan","title":"impl <code>[a : Std::Eq, a : Std::LessThan] Std::Array a : Std::LessThan</code>","text":"<p><code>LessThan</code> implementation for <code>Array a</code>.</p> <p>Compares two arrays by lexicographic order.</p>"},{"location":"Std/#impl-a-stdeq-a-stdlessthanoreq-stdarray-a-stdlessthanoreq","title":"impl <code>[a : Std::Eq, a : Std::LessThanOrEq] Std::Array a : Std::LessThanOrEq</code>","text":"<p><code>LessThanOrEq</code> implementation for <code>Array a</code>.</p> <p>Compares two arrays by lexicographic order.</p>"},{"location":"Std/#impl-a-stdtostring-stdarray-a-stdtostring","title":"impl <code>[a : Std::ToString] Std::Array a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdarray-a-stdzero","title":"impl <code>Std::Array a : Std::Zero</code>","text":"<p>The empty array with zero capacity.</p>"},{"location":"Std/#impl-stdarrow-a-stdfunctor","title":"impl <code>Std::Arrow a : Std::Functor</code>","text":""},{"location":"Std/#impl-stdarrow-a-stdmonad","title":"impl <code>Std::Arrow a : Std::Monad</code>","text":""},{"location":"Std/#impl-stdbool-stdeq","title":"impl <code>Std::Bool : Std::Eq</code>","text":""},{"location":"Std/#impl-stdbool-stdnot","title":"impl <code>Std::Bool : Std::Not</code>","text":""},{"location":"Std/#impl-stdbool-stdtostring","title":"impl <code>Std::Bool : Std::ToString</code>","text":""},{"location":"Std/#impl-stdbox-a-stdboxed","title":"impl <code>Std::Box a : Std::Boxed</code>","text":""},{"location":"Std/#impl-stdf32-stdadd","title":"impl <code>Std::F32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdf32-stddiv","title":"impl <code>Std::F32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdf32-stdeq","title":"impl <code>Std::F32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdf32-stdfrombytes","title":"impl <code>Std::F32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdf32-stdfromstring","title":"impl <code>Std::F32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdf32-stdlessthan","title":"impl <code>Std::F32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdf32-stdlessthanoreq","title":"impl <code>Std::F32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdf32-stdmul","title":"impl <code>Std::F32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdf32-stdneg","title":"impl <code>Std::F32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdf32-stdsub","title":"impl <code>Std::F32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdf32-stdtobytes","title":"impl <code>Std::F32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdf32-stdtostring","title":"impl <code>Std::F32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdf32-stdzero","title":"impl <code>Std::F32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdf64-stdadd","title":"impl <code>Std::F64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdf64-stddiv","title":"impl <code>Std::F64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdf64-stdeq","title":"impl <code>Std::F64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdf64-stdfrombytes","title":"impl <code>Std::F64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdf64-stdfromstring","title":"impl <code>Std::F64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdf64-stdlessthan","title":"impl <code>Std::F64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdf64-stdlessthanoreq","title":"impl <code>Std::F64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdf64-stdmul","title":"impl <code>Std::F64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdf64-stdneg","title":"impl <code>Std::F64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdf64-stdsub","title":"impl <code>Std::F64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdf64-stdtobytes","title":"impl <code>Std::F64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdf64-stdtostring","title":"impl <code>Std::F64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdf64-stdzero","title":"impl <code>Std::F64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdffidestructor-a-stdboxed","title":"impl <code>Std::FFI::Destructor a : Std::Boxed</code>","text":""},{"location":"Std/#impl-stdi16-stdadd","title":"impl <code>Std::I16 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi16-stddiv","title":"impl <code>Std::I16 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi16-stdeq","title":"impl <code>Std::I16 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi16-stdfrombytes","title":"impl <code>Std::I16 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi16-stdfromstring","title":"impl <code>Std::I16 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi16-stdlessthan","title":"impl <code>Std::I16 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi16-stdlessthanoreq","title":"impl <code>Std::I16 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi16-stdmul","title":"impl <code>Std::I16 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi16-stdneg","title":"impl <code>Std::I16 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi16-stdrem","title":"impl <code>Std::I16 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi16-stdsub","title":"impl <code>Std::I16 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi16-stdtobytes","title":"impl <code>Std::I16 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi16-stdtostring","title":"impl <code>Std::I16 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi16-stdzero","title":"impl <code>Std::I16 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi32-stdadd","title":"impl <code>Std::I32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi32-stddiv","title":"impl <code>Std::I32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi32-stdeq","title":"impl <code>Std::I32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi32-stdfrombytes","title":"impl <code>Std::I32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi32-stdfromstring","title":"impl <code>Std::I32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi32-stdlessthan","title":"impl <code>Std::I32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi32-stdlessthanoreq","title":"impl <code>Std::I32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi32-stdmul","title":"impl <code>Std::I32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi32-stdneg","title":"impl <code>Std::I32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi32-stdrem","title":"impl <code>Std::I32 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi32-stdsub","title":"impl <code>Std::I32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi32-stdtobytes","title":"impl <code>Std::I32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi32-stdtostring","title":"impl <code>Std::I32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi32-stdzero","title":"impl <code>Std::I32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi64-stdadd","title":"impl <code>Std::I64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi64-stddiv","title":"impl <code>Std::I64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi64-stdeq","title":"impl <code>Std::I64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi64-stdfrombytes","title":"impl <code>Std::I64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi64-stdfromstring","title":"impl <code>Std::I64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi64-stdlessthan","title":"impl <code>Std::I64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi64-stdlessthanoreq","title":"impl <code>Std::I64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi64-stdmul","title":"impl <code>Std::I64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi64-stdneg","title":"impl <code>Std::I64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi64-stdrem","title":"impl <code>Std::I64 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi64-stdsub","title":"impl <code>Std::I64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi64-stdtobytes","title":"impl <code>Std::I64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi64-stdtostring","title":"impl <code>Std::I64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi64-stdzero","title":"impl <code>Std::I64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdi8-stdadd","title":"impl <code>Std::I8 : Std::Add</code>","text":""},{"location":"Std/#impl-stdi8-stddiv","title":"impl <code>Std::I8 : Std::Div</code>","text":""},{"location":"Std/#impl-stdi8-stdeq","title":"impl <code>Std::I8 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdi8-stdfrombytes","title":"impl <code>Std::I8 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdi8-stdfromstring","title":"impl <code>Std::I8 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdi8-stdlessthan","title":"impl <code>Std::I8 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdi8-stdlessthanoreq","title":"impl <code>Std::I8 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdi8-stdmul","title":"impl <code>Std::I8 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdi8-stdneg","title":"impl <code>Std::I8 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdi8-stdrem","title":"impl <code>Std::I8 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdi8-stdsub","title":"impl <code>Std::I8 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdi8-stdtobytes","title":"impl <code>Std::I8 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdi8-stdtostring","title":"impl <code>Std::I8 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdi8-stdzero","title":"impl <code>Std::I8 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdio-stdfunctor","title":"impl <code>Std::IO : Std::Functor</code>","text":""},{"location":"Std/#impl-stdio-stdmonad","title":"impl <code>Std::IO : Std::Monad</code>","text":""},{"location":"Std/#impl-stdioiofail-stdfunctor","title":"impl <code>Std::IO::IOFail : Std::Functor</code>","text":""},{"location":"Std/#impl-stdioiofail-stdmonad","title":"impl <code>Std::IO::IOFail : Std::Monad</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorappenditerator-i1-i2-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::AppendIterator i1 i2 : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorarrayiterator-a-stditerator","title":"impl <code>Std::Iterator::ArrayIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorconsiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::ConsIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorcountupiterator-stditerator","title":"impl <code>Std::Iterator::CountUpIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-stdfunctor","title":"impl <code>Std::Iterator::DynIterator : Std::Functor</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-stdmonad","title":"impl <code>Std::Iterator::DynIterator : Std::Monad</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stdadd","title":"impl <code>Std::Iterator::DynIterator a : Std::Add</code>","text":"<p>Concatenates two dynamic iterators.</p>"},{"location":"Std/#impl-a-stdeq-stditeratordyniterator-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Iterator::DynIterator a : Std::Eq</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stditerator","title":"impl <code>Std::Iterator::DynIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratordyniterator-a-stdzero","title":"impl <code>Std::Iterator::DynIterator a : Std::Zero</code>","text":"<p>Creates an empty dynamic iterator.</p>"},{"location":"Std/#impl-stditeratoremptyiterator-a-stditerator","title":"impl <code>Std::Iterator::EmptyIterator a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorfilteriterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::FilterIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorfiltermapiterator-i-a-b-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::FilterMapIterator i a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-i2-stditerator-i1-stditerator-stditeratorflatteniterator-i2-i1-stditerator","title":"impl <code>[i2 : Std::Iterator, i1 : Std::Iterator] Std::Iterator::FlattenIterator i2 i1 : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorintersperseiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::IntersperseIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratormapiterator-i-a-b-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::MapIterator i a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorproductiterator-i1-i2-a-b-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::ProductIterator i1 i2 a b : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorrangeiterator-stditerator","title":"impl <code>Std::Iterator::RangeIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorrangestepiterator-stditerator","title":"impl <code>Std::Iterator::RangeStepIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratorreverseiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::ReverseIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-stditeratorstateiterator-s-a-stditerator","title":"impl <code>Std::Iterator::StateIterator s a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratortakeiterator-i-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::TakeIterator i : Std::Iterator</code>","text":""},{"location":"Std/#impl-i-stditerator-stditeratortakewhileiterator-i-a-stditerator","title":"impl <code>[i : Std::Iterator] Std::Iterator::TakeWhileIterator i a : Std::Iterator</code>","text":""},{"location":"Std/#impl-i1-stditerator-i2-stditerator-stditeratorzipiterator-i1-i2-stditerator","title":"impl <code>[i1 : Std::Iterator, i2 : Std::Iterator] Std::Iterator::ZipIterator i1 i2 : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdoption-stdfunctor","title":"impl <code>Std::Option : Std::Functor</code>","text":""},{"location":"Std/#impl-stdoption-stdmonad","title":"impl <code>Std::Option : Std::Monad</code>","text":""},{"location":"Std/#impl-a-stdeq-stdoption-a-stdeq","title":"impl <code>[a : Std::Eq] Std::Option a : Std::Eq</code>","text":""},{"location":"Std/#impl-a-stdtostring-stdoption-a-stdtostring","title":"impl <code>[a : Std::ToString] Std::Option a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdoptionoptioniterator-stdoption-a-stditerator","title":"impl <code>Std::Option::OptionIterator (Std::Option a) : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdptr-stdeq","title":"impl <code>Std::Ptr : Std::Eq</code>","text":""},{"location":"Std/#impl-stdptr-stdtostring","title":"impl <code>Std::Ptr : Std::ToString</code>","text":""},{"location":"Std/#impl-stdresult-e-stdfunctor","title":"impl <code>Std::Result e : Std::Functor</code>","text":""},{"location":"Std/#impl-stdresult-e-stdmonad","title":"impl <code>Std::Result e : Std::Monad</code>","text":""},{"location":"Std/#impl-e-stdeq-a-stdeq-stdresult-e-a-stdeq","title":"impl <code>[e : Std::Eq, a : Std::Eq] Std::Result e a : Std::Eq</code>","text":""},{"location":"Std/#impl-e-stdtostring-a-stdtostring-stdresult-e-a-stdtostring","title":"impl <code>[e : Std::ToString, a : Std::ToString] Std::Result e a : Std::ToString</code>","text":""},{"location":"Std/#impl-stdstring-stdadd","title":"impl <code>Std::String : Std::Add</code>","text":"<p>Concatenates two strings.</p>"},{"location":"Std/#impl-stdstring-stdeq","title":"impl <code>Std::String : Std::Eq</code>","text":""},{"location":"Std/#impl-stdstring-stdfrombytes","title":"impl <code>Std::String : Std::FromBytes</code>","text":"<p>Creates a string from a byte array.</p> <p>The byte array must include a null terminator (<code>'\\0'</code>). If not, <code>from_bytes</code> returns an error.</p> <p>The length of the string is the number of bytes until the first null character.</p>"},{"location":"Std/#impl-stdstring-stdlessthan","title":"impl <code>Std::String : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdstring-stdlessthanoreq","title":"impl <code>Std::String : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdstring-stdtobytes","title":"impl <code>Std::String : Std::ToBytes</code>","text":"<p>Converts a string into a byte array.</p> <p>The byte array ends with a null terminator (<code>'\\0'</code>).</p>"},{"location":"Std/#impl-stdstring-stdtostring","title":"impl <code>Std::String : Std::ToString</code>","text":""},{"location":"Std/#impl-stdstring-stdzero","title":"impl <code>Std::String : Std::Zero</code>","text":"<p>The empty string.</p>"},{"location":"Std/#impl-stdstringstringsplititerator-stditerator","title":"impl <code>Std::String::StringSplitIterator : Std::Iterator</code>","text":""},{"location":"Std/#impl-stdtuple1-stdfunctor","title":"impl <code>Std::Tuple1 : Std::Functor</code>","text":""},{"location":"Std/#impl-stdtuple2-t0-stdfunctor","title":"impl <code>Std::Tuple2 t0 : Std::Functor</code>","text":""},{"location":"Std/#impl-stdtuple3-t0-t1-stdfunctor","title":"impl <code>Std::Tuple3 t0 t1 : Std::Functor</code>","text":""},{"location":"Std/#impl-stdu16-stdadd","title":"impl <code>Std::U16 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu16-stddiv","title":"impl <code>Std::U16 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu16-stdeq","title":"impl <code>Std::U16 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu16-stdfrombytes","title":"impl <code>Std::U16 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu16-stdfromstring","title":"impl <code>Std::U16 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu16-stdlessthan","title":"impl <code>Std::U16 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu16-stdlessthanoreq","title":"impl <code>Std::U16 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu16-stdmul","title":"impl <code>Std::U16 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu16-stdneg","title":"impl <code>Std::U16 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu16-stdrem","title":"impl <code>Std::U16 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu16-stdsub","title":"impl <code>Std::U16 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu16-stdtobytes","title":"impl <code>Std::U16 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu16-stdtostring","title":"impl <code>Std::U16 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu16-stdzero","title":"impl <code>Std::U16 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu32-stdadd","title":"impl <code>Std::U32 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu32-stddiv","title":"impl <code>Std::U32 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu32-stdeq","title":"impl <code>Std::U32 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu32-stdfrombytes","title":"impl <code>Std::U32 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu32-stdfromstring","title":"impl <code>Std::U32 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu32-stdlessthan","title":"impl <code>Std::U32 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu32-stdlessthanoreq","title":"impl <code>Std::U32 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu32-stdmul","title":"impl <code>Std::U32 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu32-stdneg","title":"impl <code>Std::U32 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu32-stdrem","title":"impl <code>Std::U32 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu32-stdsub","title":"impl <code>Std::U32 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu32-stdtobytes","title":"impl <code>Std::U32 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu32-stdtostring","title":"impl <code>Std::U32 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu32-stdzero","title":"impl <code>Std::U32 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu64-stdadd","title":"impl <code>Std::U64 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu64-stddiv","title":"impl <code>Std::U64 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu64-stdeq","title":"impl <code>Std::U64 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu64-stdfrombytes","title":"impl <code>Std::U64 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu64-stdfromstring","title":"impl <code>Std::U64 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu64-stdlessthan","title":"impl <code>Std::U64 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu64-stdlessthanoreq","title":"impl <code>Std::U64 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu64-stdmul","title":"impl <code>Std::U64 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu64-stdneg","title":"impl <code>Std::U64 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu64-stdrem","title":"impl <code>Std::U64 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu64-stdsub","title":"impl <code>Std::U64 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu64-stdtobytes","title":"impl <code>Std::U64 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu64-stdtostring","title":"impl <code>Std::U64 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu64-stdzero","title":"impl <code>Std::U64 : Std::Zero</code>","text":""},{"location":"Std/#impl-stdu8-stdadd","title":"impl <code>Std::U8 : Std::Add</code>","text":""},{"location":"Std/#impl-stdu8-stddiv","title":"impl <code>Std::U8 : Std::Div</code>","text":""},{"location":"Std/#impl-stdu8-stdeq","title":"impl <code>Std::U8 : Std::Eq</code>","text":""},{"location":"Std/#impl-stdu8-stdfrombytes","title":"impl <code>Std::U8 : Std::FromBytes</code>","text":""},{"location":"Std/#impl-stdu8-stdfromstring","title":"impl <code>Std::U8 : Std::FromString</code>","text":""},{"location":"Std/#impl-stdu8-stdlessthan","title":"impl <code>Std::U8 : Std::LessThan</code>","text":""},{"location":"Std/#impl-stdu8-stdlessthanoreq","title":"impl <code>Std::U8 : Std::LessThanOrEq</code>","text":""},{"location":"Std/#impl-stdu8-stdmul","title":"impl <code>Std::U8 : Std::Mul</code>","text":""},{"location":"Std/#impl-stdu8-stdneg","title":"impl <code>Std::U8 : Std::Neg</code>","text":""},{"location":"Std/#impl-stdu8-stdrem","title":"impl <code>Std::U8 : Std::Rem</code>","text":""},{"location":"Std/#impl-stdu8-stdsub","title":"impl <code>Std::U8 : Std::Sub</code>","text":""},{"location":"Std/#impl-stdu8-stdtobytes","title":"impl <code>Std::U8 : Std::ToBytes</code>","text":""},{"location":"Std/#impl-stdu8-stdtostring","title":"impl <code>Std::U8 : Std::ToString</code>","text":""},{"location":"Std/#impl-stdu8-stdzero","title":"impl <code>Std::U8 : Std::Zero</code>","text":""}]}