module Main;

import Subprocess;
import Minilib.Encoding.Json.JsonDecoder;
import Minilib.Encoding.Json;
import Minilib.Collection.OrderedMap;

type ProcessName = String;

check_exit_staus : ExitStatus -> ProcessName -> IO ();
check_exit_staus = |status, process_name| (
    match status {
        exit(code) => (
            if code == 0_U8 {
                pure()
            } else {
                let msg = "error: " + process_name + " exited with code " + code.to_string;
                eprintln(msg);;
                exit(1)
            }
        ),
        signaled(signal) => (
            let msg = "error: " + process_name + " terminated by signal " + signal.to_string;
            eprintln(msg);;
            exit(1)
        ),
        wait_failed() => (
            let msg = "error: " + "failed to waiting termination of " + process_name;
            eprintln(msg);;
            exit(1)
        )
    }
);

is_exit_status_ok : ExitStatus -> Bool;
is_exit_status_ok = |status| (
    match status {
        exit(code) => code == 0_U8,
        _ => false
    }
);

change_dir : String -> IO ();
change_dir = |dir| (
    let code = *dir.borrow_c_str_io(|c_str| FFI_CALL_IO[CInt chdir(Ptr), c_str]);
    when(code != 0.to_CInt, 
        let msg = "error: failed to change directory to " + dir;
        eprintln(msg);;
        exit(1)
    );;
    pure()
);

// The directory to store the documentation.
c_docs_dir : String;
c_docs_dir = "docs";

// Information of a project.
type ProjInfo = box struct {
    name : String,
    loc : String,
    ver : String,
};

build_docs : IO ();
build_docs = (
    // Prepare a directory to store the documentation temporarily.
    let docs_dir = "tmpdocs";   
    // Remove the directory if it exists.
    let commands = ["rm", "-rf", docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;
    // Create the directory.
    let commands = ["mkdir", "-p", docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("mkdir", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;

    // Download `https://raw.githubusercontent.com/tttmmmyyyy/fixlang/refs/heads/main/std_doc/Std.md`.
    let std_doc_url = "https://raw.githubusercontent.com/tttmmmyyyy/fixlang/refs/heads/main/std_doc/Std.md";
    let std_doc = docs_dir + "/" + "Std.md";
    let (_, status) = *Subprocess::run_string("wget", ["wget", "-q", std_doc_url, "-O", std_doc], "").try(exit_with_msg(1));

    // Run `fix deps list --json` to get the list of all available fix projects.
    let ((deps_list, err), status) = *Subprocess::run_string("fix", ["fix", "deps", "list", "--json"], "").try(exit_with_msg(1));
    when(err.get_size > 0, eprintln(err));;
    check_exit_staus(status, "`fix deps list --locs-only`");;

    // Parse `deps_list`.
    let deps_list = JsonDecoder::decode(deps_list);
    if deps_list.is_err {
        eprintln("error: failed to parse the output of `fix deps list --json`: ");;
        eprintln(deps_list.as_err);;
        exit(1)
    };
    let deps_list = deps_list.as_ok;
    let deps_list : Result ErrMsg (Array ProjInfo) = do {
        match deps_list {
            Json::array(deps_list) => (
                Result::ok $ *deps_list.to_iter.loop_iter_m([], |entry, deps_list|
                    if !entry.is_object { Result::err $ "error: failed to parse the output of `fix deps list --json`: expected an array of objects" };
                    let entry = entry.as_object;

                    let name = entry.find("name");
                    if name.is_none { Result::err $ "error: failed to parse the output of `fix deps list --json`: expected a field `name`" };
                    let name = name.as_some;
                    if !name.is_string { Result::err $ "error: failed to parse the output of `fix deps list --json`: expected a string for the field `name`" };
                    let name = name.as_string;

                    let loc = entry.find("git");
                    if loc.is_none { Result::err $ "error: failed to parse the output of `fix deps list --json`: expected a field `git`" };
                    let loc = loc.as_some;
                    if !loc.is_string { Result::err $ "error: failed to parse the output of `fix deps list --json`: expected a string for the field `git`" };
                    let loc = loc.as_string;

                    let prj_info = ProjInfo { name : name, loc : loc, ver : "" };
                    let deps_list = deps_list.push_back(prj_info);
                    continue_m $ deps_list
                )
            ),
            _ => Result::err $ "error: failed to parse the output of `fix deps list --json`: expected an array",
        }
    };
    if deps_list.is_err {
        eprintln(deps_list.as_err);;
        exit(1)
    };
    let deps_list = deps_list.as_ok;

    // Remove the working directory if it exists.
    let work_dir = "fixprojs";
    let commands = ["rm", "-rf", work_dir];
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // Create working directory.
    let commands = ["mkdir", "-p", work_dir];
    let (_, status) = *Subprocess::run_string("mkdir", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // cd to working directory.
    change_dir(work_dir);;

    // Clone each projects.
    deps_list.to_iter.loop_iter_m((), |prj_info, _|
        // Create working directory using `idx`.
        let work_dir = prj_info.@name;
        let (_, status) = *Subprocess::run_string("mkdir", ["mkdir", "-p", work_dir], "").try(exit_with_msg(1));
        check_exit_staus(status, "`mkdir -p " + work_dir + "`");;

        // Clone the repository.
        let commands = ["git", "clone", "--quiet", "--tags", prj_info.@loc, work_dir];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // cd to the working directory.
        change_dir(work_dir);;

        // Get the latest tag by `git describe --tags --abbrev=0`.
        let commands = ["git", "describe", "--tags", "--abbrev=0"];
        let ((tag, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

        // If the latest tag found, checkout it.
        when(status.is_exit_status_ok, 
            let tag = tag.strip_spaces;
            when(tag.get_size > 0, 
                let commands = ["git", "checkout", "--quiet", tag];
                let commands_str = commands.to_iter.join(" ");
                println(commands_str);;
                let ((out, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
                when(err.get_size > 0, eprintln(err));;
                check_exit_staus(status, "`" + commands_str + "`")
            )
        );;

        // Run `fix deps install`
        let commands = ["fix", "deps", "install"];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("fix", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // Run `fix docs -o ../../"temp_docs"`.
        let commands = ["fix", "docs", "-o", "../../" + docs_dir];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("fix", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // Pop the working directory.
        change_dir("..");;

        continue_m $ ()
    );;

    // Pop the working directory.
    change_dir("..");;

    // Change the working directory to `docs_dir`.
    change_dir(docs_dir);;

    // Get the list of markdown files in `temp_docs` by `find "temp_docs" -name "*.md"`.
    let commands = ["find", ".", "-name", "*.md"];
    let ((md_files, err), status) = *Subprocess::run_string("find", commands, "").try(exit_with_msg(1));
    when(err.get_size > 0, eprintln(err));;
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // Parse md_files.
    let md_files = md_files.split("\n").map(strip_spaces).filter(|s| s.get_size > 0).to_array.sort_by(|(a, b)| a < b);

    // Create `index.md`.
    let index_md = "index.md";
    with_file(index_md, "w", |file|
        write_string(file, "# Index\n\n");;
        write_string(file, "This page contains the documentation of the following modules: ");;
        let mod_links = md_files.to_iter.map(|md_file| 
            let module_name = md_file.get_sub("./".get_size, md_file.get_size - ".md".get_size);
            "[" + module_name + "](" + md_file + ")"
        );
        let mod_links = mod_links.join(", ");
        write_string(file, mod_links + ".\n\n");;
        write_string(file, "This page was generated by [fixlang-docpage-generator](https://github.com/tttmmmyyyy/fixlang-docpage-generator/).\n\n")
    ).try(exit_with_msg(1));;

    // Pop the working directory.
    change_dir("..");;

    // Now remove `c_docs_dir` and rename `docs_dir` to `c_docs_dir`.
    let commands = ["rm", "-rf", c_docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;

    let commands = ["mv", docs_dir, c_docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("mv", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;
    
    pure()
);

main : IO ();
main = (
    build_docs
);
