module Main;

import Subprocess;
import Minilib.Encoding.Json.JsonDecoder;
import Minilib.Encoding.Json;
import Minilib.Collection.OrderedMap;
import EZS;

// Information of a package.
type ProjInfo = box struct {
    name : String,
    loc : String,
    ver : String,
    modules : Array String
};

namespace ProjInfo {
    structure : Json -> Result ErrMsg (Array ProjInfo);
    structure = |json| (
        let errmsg_base = "error: failed to parse the output of `fix deps list --json`: ";
        match json {
            Json::array(packages) => (
                packages.to_iter.map(|entry|
                    if !entry.is_object { Result::err $ errmsg_base + "expected an array of objects" };
                    let entry = entry.as_object;

                    let name = entry.find("name");
                    if name.is_none { Result::err $ errmsg_base + "expected a field `name`" };
                    let name = name.as_some;
                    if !name.is_string { Result::err $ errmsg_base + "expected a string for the field `name`" };
                    let name = name.as_string;

                    let loc = entry.find("git");
                    if loc.is_none { Result::err $ errmsg_base + "expected a field `git`" };
                    let loc = loc.as_some;
                    if !loc.is_string { Result::err $ errmsg_base + "expected a string for the field `git`" };
                    let loc = loc.as_string;

                    Result::ok $ ProjInfo { name : name, loc : loc, ver : "", modules : [] }
                ).collect_m
            ),
            _ => Result::err $ errmsg_base + "expected an array",
        }
    );
}

build_docs : IO ();
build_docs = (
    let ezsc = EZSConfig::default.set_eprint_stderr(true).set_execution_trace(true);

    // Prepare a directory to store the documentation.
    let docs_dir = "docs";
    ["rm", "-rf", docs_dir].ez_run_o(ezsc);;    // Remove the directory if it exists.
    ["mkdir", "-p", docs_dir].ez_run_o(ezsc);;    // Create the directory.

    // Download the standard library documentation.
    let std_doc_url = "https://raw.githubusercontent.com/tttmmmyyyy/fixlang/refs/heads/main/std_doc/Std.md";
    let std_doc = docs_dir + "/" + "Std.md";
    ["wget", "-q", std_doc_url, "-O", std_doc].ez_run_o(ezsc);;

    // Run `fix deps list --json` to get the list of all available fix projects.
    let packages = *["fix", "deps", "list", "--json"].ez_run_o(ezsc);

    // Parse `packages`.
    let packages = JsonDecoder::decode(packages);
    if packages.is_err {
        eprintln("error: failed to parse the output of `fix deps list --json`: ");;
        eprintln(packages.as_err);;
        exit(1)
    };
    let packages = packages.as_ok;
    let packages = packages.structure;
    if packages.is_err {
        eprintln(packages.as_err);;
        exit(1)
    };
    let packages = packages.as_ok;

    // Remove the working directory if it exists.
    let packages_dir = "packages";
    ["rm", "-rf", packages_dir].ez_run_o(ezsc);;

    // Create working directory.
    ["mkdir", "-p", packages_dir].ez_run_o(ezsc);;

    // Move to working directory.
    ez_cd(packages_dir);;

    // Clone each projects.
    let packages = *packages.to_iter.loop_iter_m([], |prj_info, packages|
        // Create the directory to clone the repository.
        let work_dir = prj_info.@name;
        ["mkdir", "-p", work_dir].ez_run_o(ezsc);;

        // Clone the repository.
        ["git", "clone", "--quiet", "--tags", prj_info.@loc, work_dir].ez_run_o(ezsc);;

        // cd to the working directory.
        ez_cd(work_dir);;

        // Get the latest tag.
        let tag = *["git", "describe", "--tags", "--abbrev=0"].ez_run_o(ezsc);
        let tag = tag.strip_spaces;

        // If the latest tag found, checkout it.
        when(tag.get_size > 0, 
            ["git", "checkout", "--quiet", tag].ez_run_o(ezsc).forget
        );;

        // Install dependencies.
        ["fix", "deps", "install"].ez_run_o(ezsc);;

        // Prepare empty `tmp` directory.
        let tmp = "../../tmp";
        ["rm", "-rf", tmp].ez_run_o(ezsc);; // Remove the directory if it exists.
        ["mkdir", "-p", tmp].ez_run_o(ezsc);; // Create the directory.

        // Generate documentation in `tmp`.
        ["fix", "docs", "-o", tmp].ez_run_o(ezsc);;

        // Get the list of markdown files in `tmp`.
        let md_files = *["find", tmp, "-name", "*.md"].ez_run_o(ezsc);

        // Parse `md_files` to get the list of module names.
        let md_files = md_files.split("\n").map(strip_spaces).filter(|s| s.get_size > 0);
        let modules = md_files.map(|md_file| md_file.get_sub((tmp + "/").get_size, md_file.get_size - ".md".get_size));
        let modules = modules.to_array.sort_by(|(a, b)| a < b);

        // Move all contents in `tmp` to `docs_dir`.
        modules.to_iter.fold_m((), |mod, _|
            ["mv", tmp + "/" + mod + ".md", "../../" + docs_dir].ez_run_o(ezsc).forget
        );;

        // Pop the working directory.
        ez_cd("..");;

        let prj_info = prj_info.set_ver(tag).set_modules(modules);
        let packages = packages.push_back(prj_info);

        continue_m $ packages
    );

    // Pop the working directory.
    ez_cd("..");;

    // Create `index.md`.
    println("Creating index.md...");;
    let index_md = "docs/index.md";
    with_file(index_md, "w", |file|
        write_string(file, "# Index\n\n");;
        write_string(file, "This page contains the documentation of the following projects and modules (and \"Std\"): \n\n");;
        packages.to_iter.fold_m((), |prj_info, _|
            write_string(file, "- [" + prj_info.@name + "](" + prj_info.@loc + ")@" + prj_info.@ver + "\n");;
            let mod_links = prj_info.@modules.to_iter.map(|mod| "[" + mod + "](" + mod + ".md)").join(", ");
            write_string(file, "    - " + mod_links + "\n")
        );;
        write_string(file, "\n");;
        write_string(file, "This page was generated by [fixlang-docpage-generator](https://github.com/tttmmmyyyy/fixlang-docpage-generator/).\n\n")
    ).try(exit_with_msg(1));;

    // Done.
    println("Done.");;
    
    pure()
);

main : IO ();
main = (
    build_docs
);
