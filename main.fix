module Main;
import Subprocess;

type ProcessName = String;

check_exit_staus : ExitStatus -> ProcessName -> IO ();
check_exit_staus = |status, process_name| (
    match status {
        exit(code) => (
            if code == 0_U8 {
                pure()
            } else {
                let msg = "error: " + process_name + " exited with code " + code.to_string;
                eprintln(msg);;
                exit(1)
            }
        ),
        signaled(signal) => (
            let msg = "error: " + process_name + " terminated by signal " + signal.to_string;
            eprintln(msg);;
            exit(1)
        ),
        wait_failed() => (
            let msg = "error: " + "failed to waiting termination of " + process_name;
            eprintln(msg);;
            exit(1)
        )
    }
);

is_exit_status_ok : ExitStatus -> Bool;
is_exit_status_ok = |status| (
    match status {
        exit(code) => code == 0_U8,
        _ => false
    }
);

change_dir : String -> IO ();
change_dir = |dir| (
    let code = *dir.borrow_c_str_io(|c_str| FFI_CALL_IO[CInt chdir(Ptr), c_str]);
    when(code != 0.to_CInt, 
        let msg = "error: failed to change directory to " + dir;
        eprintln(msg);;
        exit(1)
    );;
    pure()
);

// The directory to store the documentation.
c_docs_dir : String;
c_docs_dir = "docs";

build_docs : IO ();
build_docs = (
    // Prepare a directory to store the documentation temporarily.
    let docs_dir = "tmpdocs";   
    // Remove the directory if it exists.
    let commands = ["rm", "-rf", docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;
    // Create the directory.
    let commands = ["mkdir", "-p", docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("mkdir", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;

    // Download `https://raw.githubusercontent.com/tttmmmyyyy/fixlang/refs/heads/main/std_doc/Std.md`.
    let std_doc_url = "https://raw.githubusercontent.com/tttmmmyyyy/fixlang/refs/heads/main/std_doc/Std.md";
    let std_doc = docs_dir + "/" + "Std.md";
    let (_, status) = *Subprocess::run_string("wget", ["wget", "-q", std_doc_url, "-O", std_doc], "").try(exit_with_msg(1));

    // Run `fix deps list --locs-only` to get the locations of all available fix projects.
    let ((locs_list, err), status) = *Subprocess::run_string("fix", ["fix", "deps", "list", "--locs-only"], "").try(exit_with_msg(1));
    when(err.get_size > 0, eprintln(err));;
    check_exit_staus(status, "`fix deps list --locs-only`");;

    // Parse `locs_list`.
    let locs = locs_list.split("\n").map(strip_spaces).filter(|s| s.get_size > 0);

    // Remove the working directory if it exists.
    let work_dir = "fixprojs";
    let commands = ["rm", "-rf", work_dir];
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // Create working directory.
    let commands = ["mkdir", "-p", work_dir];
    let (_, status) = *Subprocess::run_string("mkdir", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // cd to working directory.
    change_dir(work_dir);;

    // Clone each projects.
    locs.zip(count_up(0)).loop_iter_m((), |(loc, idx), _|
        // Create working directory using `idx`.
        let work_dir = "proj_" + idx.to_string;
        let (_, status) = *Subprocess::run_string("mkdir", ["mkdir", "-p", work_dir], "").try(exit_with_msg(1));
        check_exit_staus(status, "`mkdir -p " + work_dir + "`");;

        // Clone the repository.
        let commands = ["git", "clone", "--quiet", "--tags", loc, work_dir];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // cd to the working directory.
        change_dir(work_dir);;

        // Get the latest tag by `git describe --tags --abbrev=0`.
        let commands = ["git", "describe", "--tags", "--abbrev=0"];
        let ((tag, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

        // If the latest tag found, checkout it.
        when(status.is_exit_status_ok, 
            let tag = tag.strip_spaces;
            when(tag.get_size > 0, 
                let commands = ["git", "checkout", "--quiet", tag];
                let commands_str = commands.to_iter.join(" ");
                println(commands_str);;
                let ((out, err), status) = *Subprocess::run_string("git", commands, "").try(exit_with_msg(1));
                when(err.get_size > 0, eprintln(err));;
                check_exit_staus(status, "`" + commands_str + "`")
            )
        );;

        // Run `fix deps install`
        let commands = ["fix", "deps", "install"];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("fix", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // Run `fix docs -o ../../"temp_docs"`.
        let commands = ["fix", "docs", "-o", "../../" + docs_dir];
        let commands_str = commands.to_iter.join(" ");
        println(commands_str);;
        let ((out, err), status) = *Subprocess::run_string("fix", commands, "").try(exit_with_msg(1));
        when(err.get_size > 0, eprintln(err));;
        check_exit_staus(status, "`" + commands_str + "`");;

        // Pop the working directory.
        change_dir("..");;

        continue_m $ ()
    );;

    // Pop the working directory.
    change_dir("..");;

    // Change the working directory to `docs_dir`.
    change_dir(docs_dir);;

    // Get the list of markdown files in `temp_docs` by `find "temp_docs" -name "*.md"`.
    let commands = ["find", ".", "-name", "*.md"];
    let ((md_files, err), status) = *Subprocess::run_string("find", commands, "").try(exit_with_msg(1));
    when(err.get_size > 0, eprintln(err));;
    check_exit_staus(status, "`" + commands.to_iter.join(" ") + "`");;

    // Parse md_files.
    let md_files = md_files.split("\n").map(strip_spaces).filter(|s| s.get_size > 0).to_array.sort_by(|(a, b)| a < b);

    // Create `index.md`.
    let index_md = "index.md";
    with_file(index_md, "w", |file|
        write_string(file, "# Index\n\n");;
        write_string(file, "This document contains the documentation of the following Fix modules:\n");;
        md_files.to_iter.fold_m((), |md_file, _|
            let module_name = md_file.get_sub("./".get_size, md_file.get_size - ".md".get_size);
            let line = "- [" + module_name + "](" + md_file + ")\n";
            write_string(file, line)
        );;
        write_string(file, "\n\nThis page was generated by [fixlang-docpage-generator](https://github.com/tttmmmyyyy/fixlang-docpage-generator/).")
    ).try(exit_with_msg(1));;

    // Pop the working directory.
    change_dir("..");;

    // Now remove `c_docs_dir` and rename `docs_dir` to `c_docs_dir`.
    let commands = ["rm", "-rf", c_docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("rm", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;

    let commands = ["mv", docs_dir, c_docs_dir];
    let command_str = commands.to_iter.join(" ");
    let (_, status) = *Subprocess::run_string("mv", commands, "").try(exit_with_msg(1));
    check_exit_staus(status, "`" + command_str + "`");;
    
    pure()
);

main : IO ();
main = (
    build_docs
);
